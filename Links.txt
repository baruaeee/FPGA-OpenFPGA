https://2m0l1s-my.sharepoint.com/personal/baruaeee_2m0l1s_onmicrosoft_com/_layouts/15/onedrive.aspx?ga=1&id=%2Fpersonal%2Fbaruaeee%5F2m0l1s%5Fonmicrosoft%5Fcom%2FDocuments%2FGitRepo%2FFPGA%2DOpenFPGA
https://2m0l1s-my.sharepoint.com/:w:/r/personal/baruaeee_2m0l1s_onmicrosoft_com/_layouts/15/Doc.aspx?sourcedoc=%7B750d5684-9f88-4b8e-872a-930f071d26b7%7D&action=default


Digital design
https://www.eng.biu.ac.il/temanad/teaching/
https://github.com/mirkat1206/2021_Spring_NCTU_ICLAB/tree/main/Lab06
https://hackmd.io/@derek8955/r149dnNaj
https://schaumont.dyn.wpi.edu/ece574f24/10fclayout.html

IO pad placement
https://www.reddit.com/r/chipdesign/comments/148bmgx/io_placement_of_a_netlist_using_innovus/

https://openfpga.readthedocs.io/en/master/

OpenFPGA Intro--
https://youtu.be/ocODUGcYGqo?list=PLs-JA7mhcMRO9demDFIgWmKwAgAI3Yjd4

OpenFPGA overview-
https://www.youtube.com/watch?v=HH8fh5wBysY&t=1s&pp=ygUIb3BlbmZwZ2E%3D

https://www.youtube.com/watch?v=nwb5Yk5Uz5w&pp=ygUIb3BlbmZwZ2E%3D

Tutorial on OpenFPGA
https://sites.google.com/view/openfpgaatfpga23

https://docs.verilogtorouting.org/en/latest/vpr/

https://github.com/lnis-uofu/OpenFPGA/blob/master/docs/source/tutorials/arch_modeling/quick_start.rst

https://gitee.com/curliph/OpenFPGA

https://docs.verilogtorouting.org/en/latest/vpr/basic_flow/

https://compedulabs.org/id/organisation/22

https://semiconductorclub.com/course-category/asic-design-verification/
or
https://www.youtube.com/playlist?list=PLai-xIlqf4JmAdNYzthdI2lv-5Bu_O5bv

https://semiconductorclub.com/courses/full-chip-drc-lvs/
or
https://www.youtube.com/playlist?list=PLZU5hLL_713xp5sDexQMVdOM86l_wP5w8

https://archive.org/details/academictorrents_625ae5f99f1cfdc2b8eb42577ca5271ad78967e0

https://cmosedu.com/

https://www.youtube.com/playlist?list=PLHTXmXoTo6L_Wg0t2v_GB2lEgWf7hTGq6


SkyWater OpenFPGA
https://github.com/lnis-uofu/SOFA

https://downloadly.ir/elearning/video-tutorials/embedded-fun-with-risc-v-part-1-the-risc-v-isa/

https://hardwarebee.com/the-ultimate-guide-to-fpga-architecture/
https://hardwarebee.com/fpga-architecture/
https://hardwarebee.com/cpld-vs-fpga-difference/
https://hardwarebee.com/ultimate-guide-fpga-design-flow/
https://hardwarebee.com/fpga-design-flow-introduction/

https://verificationguide.com/systemverilog
https://verificationguide.com/systemverilog/introduction/

PDK-ASAP7
https://github.com/The-OpenROAD-Project/asap7

PDK-ASAP5
https://github.com/The-OpenROAD-Project/asap5

PDK-SkyWater130(only standard cells)
https://github.com/stineje/sky130_cds

Cadence design flow tutorial
https://github.com/abdelazeem201/Cadence-RTL-to-GDSII-Flow
https://www.youtube.com/@vlsiclasses/videos
https://www.youtube.com/watch?v=_qyBenY6vCQ&list=PLuXu2WnxwfB1c9f4Zpr-rP_Gfyq7LKS4N&index=5
https://github.com/arm-university/VLSI-Fundamentals-Education-Kit

Genus Synthesis
https://digitalsystemdesign.in/genus-synthesis-without-constraints/
https://digitalsystemdesign.in/genus-synthesis-using-scripts/

PnR
https://www.youtube.com/watch?v=1kLUdi0qNBo&list=PLC7JCwKQnjL5QPkGGEtO2TFAW9oW8c_W3&index=8
https://digitalsystemdesign.in/mmmc-file-setup-for-pnr-using-innovus/

dependencies:
ctags-already installed in mint 21.3


What is VPR in FPGA?
VPR, or Versatile Place and Route, is an open-source CAD (Computer-Aided Design) tool specifically designed for the packing, placement, and routing of circuits on Field-Programmable Gate Arrays (FPGAs). Developed primarily by the University of Toronto, VPR allows researchers and engineers to explore and evaluate various FPGA architectures and CAD algorithms.

What are PnR Constraints?
PnR constraints refer to specific guidelines and limitations that are applied during the Place and Route (PnR) process in digital circuit design, particularly for FPGAs and ASICs. These constraints are crucial for ensuring that the final design meets performance, timing, and physical requirements.

What is an FPGA Bitstream?
An FPGA bitstream is a binary file that contains the configuration data necessary to program an FPGA (Field-Programmable Gate Array). This file encodes all the information required to set up the FPGA's internal logic elements, interconnections, and other functionalities to implement a specific design.


what is channel in FPGA?
In the context of Field-Programmable Gate Arrays (FPGAs), a channel refers to the routing pathways that connect various components within the FPGA, such as logic blocks and input/output (I/O) pads. These channels are essential for facilitating communication between different parts of the FPGA, allowing signals to travel from one location to another.

what is CLB inFPGA?
A Configurable Logic Block (CLB) is a fundamental building block of Field-Programmable Gate Arrays (FPGAs). It serves as the primary resource for implementing digital logic functions within the FPGA architecture.

what is FPGA-SDC?
FPGA-SDC refers to Field-Programmable Gate Array - Synopsys Design Constraints. It is a file format used to specify timing and design constraints for FPGA designs, particularly when using tools from Synopsys or other EDA (Electronic Design Automation) tools that support the SDC format.

What is the BLIF VPR Flow?
The BLIF VPR flow refers to the process of using the Versatile Place and Route (VPR) tool to handle digital designs represented in the BLIF (Berkeley Logic Interchange Format). This flow is commonly used in the context of FPGA (Field-Programmable Gate Array) design and synthesis.

What is BRAM Technology?
BRAM, or Block Random Access Memory, is a type of memory technology commonly found in Field-Programmable Gate Arrays (FPGAs). It is designed to provide efficient data storage and access within the FPGA architecture.

What is Channel Width in VPR Architecture?
In the context of VPR (Versatile Place and Route) architecture, channel width refers to the number of routing tracks available in the routing channels of an FPGA. These channels are the pathways that connect different logic blocks and allow signals to be routed between them.

What is a Fracturable LUT?
A fracturable LUT (FLUT) is a type of look-up table used in modern FPGA architectures that allows for flexible configuration of its input size. The key feature of a fracturable LUT is that it can be "fractured" or divided into smaller LUTs, enabling more efficient use of resources when implementing digital logic functions.

Definition of Wire Length: Wire length in FPGA architectures typically indicates the number of logic blocks or cells that a wire can span. A wire length of 4 means that the wire can connect components that are up to four logic blocks apart.

Physical Mode in VPR
In the context of VPR (Versatile Place and Route), physical mode refers to a specific configuration of a logic block that is designed to represent the physical implementation of that block. This mode is typically used for components that have a defined physical layout and characteristics, such as I/O pads or specialized logic blocks that are not intended for general-purpose logic packing.
Purpose: The physical mode is essential for accurately modeling the physical aspects of the FPGA architecture, ensuring that the placement and routing algorithms consider the actual physical constraints and characteristics of the components.

What is PB in FPGA?
In the context of FPGAs (Field-Programmable Gate Arrays), PB typically stands for "Physical Block" or "Logic Block". It refers to the fundamental building blocks within the FPGA architecture that can be configured to implement various digital logic functions.


what is K4N4 meaning?
The term K4N4 in the context of FPGA architecture refers to a specific configuration of the Configurable Logic Block (CLB) structure within the FPGA. The notation can be broken down as follows:
K: This typically represents the number of Basic Logic Elements (BLEs) within a single Configurable Logic Block. In the case of K4N4, it indicates that each CLB contains 4 BLEs.
N: This denotes the number of inputs that each BLE can handle. For K4N4, each BLE is capable of processing 4 inputs.
Thus, the K4N4 architecture is characterized by its 4 BLEs per CLB, with each BLE supporting 4 inputs. This configuration allows for efficient logic implementation and flexibility in designing digital circuits, making it suitable for various applications in programmable logic devices.

what is dangling port?
In digital design, particularly in the context of hardware description languages like VHDL and Verilog, a dangling port refers to a situation where a port of a module or component is not properly connected to any signal or net. This can occur in both input and output ports.

what is packer in VPR architecture?
In the context of VPR (Versatile Place and Route) architecture, the packer is a crucial component responsible for the initial stage of the FPGA design flow. Its primary function is to group logic elements into larger blocks, optimizing the mapping of the circuit's netlist onto the FPGA architecture.

what is pass gate
A pass gate is a type of electronic switch used in digital circuits, particularly in pass-transistor logic (PTL) and transmission gate configurations. It typically consists of a combination of NMOS and PMOS transistors, allowing it to control the flow of signals based on a control input.

what is ADDF?
In the context of FPGAs, ADDF stands for Add with Carry. It is a specialized arithmetic function that performs addition of two binary numbers along with an additional carry input. This operation is particularly useful in digital circuits where multiple additions are performed, such as in arithmetic logic units (ALUs) or digital signal processing applications.

what is Spypads?
In the context of FPGAs, Spypads are specialized physical output pins on an FPGA chip that allow for the observation of internal signals during silicon-level debugging. They serve as a valuable tool for engineers and developers when testing and verifying the functionality of their designs.

what is vpr activity file
The VPR activity file is associated with the VPR (Versatile Place and Route) tool, which is part of the FPGA design flow. VPR is used for placing and routing digital circuits on FPGAs, and the activity file plays a crucial role in the simulation and analysis of the design.

The VPR activity file contains information about the activity levels of various signals in a digital circuit during simulation. This data is essential for understanding how the circuit behaves under different conditions and for optimizing performance.

what is dffr?
In the context of FPGAs, DFFR refers to a D Flip-Flop with Reset. This is a specific type of D Flip-Flop (DFF) that includes an asynchronous reset feature, allowing the output to be set to a predefined state (usually low or zero) regardless of the clock signal.

tap_buf4
tap_buf4 can be interpreted as an inverter with a fanout of 4

Workarround

OpenFPGA root and source initialization
>>export OPENFPGA_PATH=<path-to-openfpga-repository-root>
>>cd ${OPENFPGA_PATH} && source openfpga.sh

Prepare Task Configuration File
## specify the openfpga shell script to be executed. an example script which is golden reference to generate Verilog netlists
[OpenFPGA_SHELL]
openfpga_shell_template=${PATH:OPENFPGA_PATH}/openfpga_flow/openfpga_shell_scripts/generate_fabric_example_script.openfpga
## Specify XML-based Architecture file, e.g.
[OpenFPGA_SHELL]
openfpga_arch_file=${PATH:OPENFPGA_PATH}/openfpga_flow/openfpga_arch/k6_frac_N10_40nm_openfpga.xml
## Describe the architecture of the FPGA fabric, e.g.
[ARCHITECTURES]
arch0=${PATH:OPENFPGA_PATH}/openfpga_flow/vpr_arch/k6_frac_N10_tileable_40nm.xml
## select fixed sized layout grid size
## NxN==> layout name should be in the vpr architecture file
## look for "<layout tileable="true">" in the architecture file
openfpga_vpr_device=NxN
## number of wire/connection/signal
openfpga_vpr_route_chan_width=20

Run OpenFPGA Task
## run the task by calling the python script with the given path to task configuration file. (here the content of tasks basic_tests/generate_fabric copied to new tasks directory 'fabric' to keep original files intact)
>>python3 openfpga_flow/scripts/run_fpga_task.py Fabric/generate_fabric

run-task /home/cae1/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog --debug --show_thread_logs

## The Verilog netlists are generated in the following directory: (and2 refers to the bechmarks section of task configuration)
## https://openfpga.readthedocs.io/en/master/manual/fpga_verilog/fabric_netlist/#fabric-netlists-logic-blocks
${OPENFPGA_PATH}/openfpga_flow/tasks/Fabric/generate_fabric/latest/k6_frac_N10_tileable_40nm/and2/MIN_ROUTE_CHAN_WIDTH/SRC

Run icarus iVerilog Compilation
## Go to the directory
>>cd ${OPENFPGA_PATH}/openfpga_flow/tasks/Fabric/generate_fabric/latest/k6_frac_N10_tileable_40nm/and2/MIN_ROUTE_CHAN_WIDTH
# Compile with iVerilog command:
>>iverilog SRC/fabric_netlists.v
# If compilation is successful, you can see a file a.out in the directory.

----------------
/home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/
/home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/arch/k6_frac_N10_stdcell_mux_sky130_openfpga_synthesizable.xml

--INVTX1--
--line 32--
<circuit_model type="inv_buf" name="sky130_fd_sc_hd__inv_1" prefix="sky130_fd_sc_hd__inv_1" is_default="true" verilog_netlist="/home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/inv/sky130_fd_sc_hd__inv_1.v">
      <design_technology type="cmos" topology="inverter" size="1"/>
      <device_technology device_model_name="logic"/>
      <port type="input" prefix="in" lib_name="A" size="1"/>
      <port type="output" prefix="out" lib_name="Y" size="1"/>
      <delay_matrix type="rise" in_port="in" out_port="out">
        10e-12
      </delay_matrix>
      <delay_matrix type="fall" in_port="in" out_port="out">
        10e-12
      </delay_matrix>
    </circuit_model>
replace-INVTX1==>sky130_fd_sc_hd__inv_1

--buf4--
--line 44--
<circuit_model type="inv_buf" name="sky130_fd_sc_hd__buf_4" prefix="sky130_fd_sc_hd__buf_4" is_default="false" verilog_netlist="/home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/buf/sky130_fd_sc_hd__buf_4.v">
      <design_technology type="cmos" topology="buffer" size="1" num_level="2" f_per_stage="4"/>
      <device_technology device_model_name="logic"/>
      <port type="input" prefix="in" lib_name="A" size="1"/>
      <port type="output" prefix="out" lib_name="X" size="1"/>
      <delay_matrix type="rise" in_port="in" out_port="out">
        10e-12
      </delay_matrix>
      <delay_matrix type="fall" in_port="in" out_port="out">
        10e-12
      </delay_matrix>
    </circuit_model>
replace-"buf4"==>"sky130_fd_sc_hd__buf_4"

--tap_buf4--
--line 56--
<circuit_model type="inv_buf" name="sky130_fd_sc_hd__inv_4" prefix="sky130_fd_sc_hd__inv_4" is_default="false" verilog_netlist="/home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/inv/sky130_fd_sc_hd__inv_4.v">
      <design_technology type="cmos" topology="buffer" size="1" num_level="3" f_per_stage="4"/>
      <device_technology device_model_name="logic"/>
      <port type="input" prefix="in" lib_name="A" size="1"/>
      <port type="output" prefix="out" lib_name="Y" size="1"/>
      <delay_matrix type="rise" in_port="in" out_port="out">
        10e-12
      </delay_matrix>
      <delay_matrix type="fall" in_port="in" out_port="out">
        10e-12
      </delay_matrix>
    </circuit_model>
replace-tap_buf4==>sky130_fd_sc_hd__inv_4

--OR2--
--line 68--
<circuit_model type="gate" name="sky130_fd_sc_hd__or2_1" prefix="sky130_fd_sc_hd__or2_1" is_default="true" verilog_netlist="/home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/or2/sky130_fd_sc_hd__or2_1.v">
      <design_technology type="cmos" topology="OR"/>
      <device_technology device_model_name="logic"/>
      <input_buffer exist="false"/>
      <output_buffer exist="false"/>
      <port type="input" prefix="a" lib_name="A" size="1"/>
      <port type="input" prefix="b" lib_name="B" size="1"/>
      <port type="output" prefix="out" lib_name="X" size="1"/>
      <delay_matrix type="rise" in_port="a b" out_port="out">
        10e-12 5e-12
      </delay_matrix>
      <delay_matrix type="fall" in_port="a b" out_port="out">
        10e-12 5e-12
      </delay_matrix>
    </circuit_model>
replace-"OR2"==>"sky130_fd_sc_hd__or2_1"

--MUX2--
--line 90--
<circuit_model type="gate" name="sky130_fd_sc_hd__mux2_1" prefix="sky130_fd_sc_hd__mux2_1" verilog_netlist="/home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/mux2/sky130_fd_sc_hd__mux2_1.v">
      <design_technology type="cmos" topology="MUX2"/>
      <device_technology device_model_name="logic"/>
      <input_buffer exist="false"/>
      <output_buffer exist="false"/>
      <port type="input" prefix="in0" lib_name="A1" size="1"/>
      <port type="input" prefix="in1" lib_name="A0" size="1"/>
      <port type="input" prefix="sel" lib_name="S" size="1"/>
      <port type="output" prefix="out" lib_name="X" size="1"/>
    </circuit_model>
replace-"MUX2"==>"sky130_fd_sc_hd__mux2_1"

--DFFSRQ--
--line 137--
<circuit_model type="ff" name="sky130_fd_sc_hd__sdfbbp_1" prefix="sky130_fd_sc_hd__sdfbbp_1" verilog_netlist="/home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/sdfbbp/sky130_fd_sc_hd__sdfbbp_1.v">
      <design_technology type="cmos"/>
      <input_buffer exist="true" circuit_model_name="sky130_fd_sc_hd__inv_1"/>
      <output_buffer exist="true" circuit_model_name="sky130_fd_sc_hd__inv_1"/>
      <port type="input" prefix="D" size="1"/>
      <port type="input" prefix="set" lib_name="SET_B" size="1" is_global="true" default_val="1" is_set="true"/>
      <port type="input" prefix="reset" lib_name="RESET_B" size="1" is_global="true" default_val="1" is_reset="true"/>
      <port type="output" prefix="Q" size="1"/>
      <port type="clock" prefix="clk" lib_name="CLK" size="1" is_global="true" default_val="0"/>
    </circuit_model>
replace-DFFSRQ==>sky130_fd_sc_hd__sdfbbp_1

--DFFR--
--line 162--canned be verfied with iverilog
<circuit_model type="ccff" name="sky130_fd_sc_hd__dfrbp_1" prefix="sky130_fd_sc_hd__dfrbp_1" verilog_netlist="/home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/dfrbp/sky130_fd_sc_hd__dfrbp_1.v">
      <design_technology type="cmos"/>
      <input_buffer exist="true" circuit_model_name="sky130_fd_sc_hd__inv_1"/>
      <output_buffer exist="true" circuit_model_name="sky130_fd_sc_hd__inv_1"/>
      <port type="input" prefix="pReset" lib_name="RESET_B" size="1" is_global="true" default_val="1" is_reset="true" is_prog="true"/>
      <port type="input" prefix="D" size="1"/>
      <port type="output" prefix="Q" size="1"/>
      <port type="output" prefix="QN" lib_name="Q_N" size="1"/>
      <port type="clock" prefix="prog_clk" lib_name="CLK" size="1" is_global="true" default_val="0" is_prog="true"/>
    </circuit_model>
replace-DFFR==>sky130_fd_sc_hd__dfrbp_1
----------------
iverilog -o compiled_and2 ./SRC/and2_include_netlists.v -s and2_autocheck_top_tb \
     -I ./SRC \
     -I /home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/inv \
     -I /home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/buf \
	 -I /home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/or2 \
	 -I /home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/mux2 \
	 -I /home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/sdfbbp \
	 -I /home/ubuntu/Desktop/FPGA-OpenFPGA/Fabric/tasks/synthesizable_verilog/sky130/cells/dfrbp
----------------
xrun ./SRC/and2_include_netlists.v -access +rwc \
	-incdir ./SRC/sky130/cells/inv \
	-incdir ./SRC/sky130/cells/buf \
	-incdir ./SRC/sky130/cells/or2 \
	-incdir ./SRC/sky130/cells/mux2 \
	-incdir ./SRC/sky130/cells/sdfbbp \
	-64bit
	-gui &

xrun ./SRC/and2_include_netlists.v -access +rwc -gui &
----------------
genus -gui
read_libs <lib name>
read_hdl <hdl--verilog file>
elaborate <top_module name>
set_db syn_generic_effort medium
set_db syn_map_effort medium
set_db syn_opt_effort medium
syn_generic
syn_map
syn_opt
write_hdl > hdl.v
----------------
----Innovus commands----
before importing hierarchical netlists run--
set init_design_uniquify 1
read_netlist <netlist_file.v>
get_cells
saveNetlist -flat <flatten_netlist_file.v>

--get core area--
dbGet top.fPlan.coreBox_size
dbGet top.fPlan.coreBox_sizex
dbGet top.fPlan.coreBox_sizey

----------------

write me a python code to read the current cbbi value from https://colintalkscrypto.com/cbbi/ and calculate a the ratio of my crypto portfolio in way that it will keep btc/usd ratio to-
uptrand => cbbi 0-60 => 0.9
uptrand => cbbi 61-90 => 0.85
uptrand => cbbi 91-96 => 0.80
uptrand => cbbi > 96 => 0.1
after cbbi>96 => bull market topped, take profit => wait for the market bottom => down trande keep ratio to 0.1
downtrand => cbbi 10-100 => 0.1
after cbbi <10 bear market bottomed, change ratio to 0.9 again and uptrand starts. repeat uptrand ratio again.

	

