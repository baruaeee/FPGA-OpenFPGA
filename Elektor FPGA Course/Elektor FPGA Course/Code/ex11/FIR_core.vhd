-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2005 Altera Corporation
-- Your use of Altera Corporation's design tools, logic functions 
-- and other software and tools, and its AMPP partner logic 
-- functions, and any output files any of the foregoing 
-- (including device programming or simulation files), and any 
-- associated documentation or information are expressly subject 
-- to the terms and conditions of the Altera Program License 
-- Subscription Agreement, Altera MegaCore Function License 
-- Agreement, or other applicable license agreement, including,
-- without limitation, that your use is for the sole purpose of 
-- programming logic devices manufactured by Altera and sold by 
-- Altera or its authorized distributors.  Please refer to the 
-- applicable agreement for further details.


-- Generated by Quartus II Version 5.1 (Build Build 176 10/26/2005)
-- Created on Tue May 09 09:01:06 2006

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

--  Entity Declaration

ENTITY FIR_core IS
    -- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
    PORT
    (
        CLK : IN STD_LOGIC;
        RESET : IN STD_LOGIC;
        SAMPLE_IN : IN STD_LOGIC_VECTOR(15 downto 0);
        START : IN STD_LOGIC;
        SAMPLE_OUT : OUT STD_LOGIC_VECTOR(15 downto 0);
        READY : OUT STD_LOGIC
       
    );
    -- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!

END FIR_core;



--  Architecture Body
ARCHITECTURE FIR_core_architecture OF FIR_core IS
TYPE MEM_ARRAY is array (1023 downto 0) of std_logic_vector (15 downto 0);
TYPE CTRL_ST IS (IDLE_STATE,START_STATE,RUNNING_STATE,DONE_STATE);

-- SYNCHROUNOUS MEMORIES
--SIGNAL H_IN, COEF : MEM_ARRAY;
SIGNAL H_ADR, H_ADR_R : STD_LOGIC_VECTOR (6 DOWNTO 0);
SIGNAL H_WE,H_WE_R : STD_LOGIC;
SIGNAL H_DATA : STD_LOGIC_VECTOR (15 DOWNTO 0);
SIGNAL COEF_ADR,COEF_ADR_R : STD_LOGIC_VECTOR (6 DOWNTO 0);
SIGNAL COEF_DATA : STD_LOGIC_VECTOR (15 DOWNTO 0);

-- INDEX
SIGNAL START_INDEX : INTEGER RANGE 0 TO 256;
SIGNAL H_INDEX,COEF_INDEX : INTEGER RANGE 0 TO 256;

-- STATE IDENTIFIERS
SIGNAL LAST,RUNNING :  STD_LOGIC;
SIGNAL ACCU : SIGNED (39 DOWNTO 0);

-- MEMORY INPUT SAMPLES        (SYNCHROUNOUS MEMORY!)
component CYCLONE_RAM IS
	PORT
	(
		address		: IN STD_LOGIC_VECTOR (6 DOWNTO 0);
		clock		: IN STD_LOGIC ;
		data		: IN STD_LOGIC_VECTOR (15 DOWNTO 0);
		wren		: IN STD_LOGIC ;
		q		    : OUT STD_LOGIC_VECTOR (15 DOWNTO 0)
	);
end component;

COMPONENT CYCLONE_ROM IS
	PORT
	(
		address		: IN STD_LOGIC_VECTOR (6 DOWNTO 0);
		clock		: IN STD_LOGIC ;
		q		: OUT STD_LOGIC_VECTOR (15 DOWNTO 0)
	);
END COMPONENT;


BEGIN

  H_WE <= '1' WHEN (START='1') AND (RUNNING='0') ELSE '0'; -- NEXT POSEDGDE CLK THE INPUT SAMPLE WILL BE WRITTEN INTO MEMORY
														   -- WHEN START-SIGNAL IS ACTIVE AND THE FIR-FILTER IS CURRENTLY IDLE
  H_ADR <= STD_LOGIC_VECTOR(TO_SIGNED(H_INDEX,7));


Altera_ram : CYCLONE_RAM
  		port map(
  			clock   => CLK,
  			wren    => H_WE,
  			address => H_ADR (6 downto 0),
  			data    => SAMPLE_IN,
  			q       => H_DATA);

  COEF_ADR<=STD_LOGIC_VECTOR(TO_SIGNED(COEF_INDEX,7));

Altera_rom : CYCLONE_ROM
	PORT MAP
	(
		address => COEF_ADR,
		clock	=> CLK,
		q		=> COEF_DATA
	);

-- KEEP TRACK OP THE H_INDEX AND COEF_INDEX AND START_INDEX
  PROCESS (CLK,RESET)
  BEGIN
    IF (RESET='1') THEN
      H_INDEX <= 0;
      COEF_INDEX <= 0;
    ELSE
      IF (CLK'EVENT AND CLK='1') THEN
        IF (LAST='1') THEN           -- SET INDEX TO START POSITION
          COEF_INDEX <= 0;
          H_INDEX <= START_INDEX-1;
          START_INDEX <= START_INDEX-1;
        ELSE
          IF (RUNNING='1' or START='1') THEN
            COEF_INDEX <= COEF_INDEX+1;
            H_INDEX <= H_INDEX+1;
          END IF; -- RUNNING
        END IF ; -- LAST
      END IF; -- POSEDGE (CLK)
    END IF; -- RESET
  END PROCESS;

-- PROCESS THE STATE-SIGNALS
  PROCESS (CLK,RESET)
  BEGIN
    IF (RESET='1') THEN
      RUNNING<='0';
      LAST<='0';
      READY<='0';
    ELSE
      IF (CLK'EVENT AND CLK='1') THEN
        IF (START='1' AND RUNNING = '0') THEN
          RUNNING <='1';
          LAST <='0';
          READY<='0';
        ELSE
          IF (COEF_INDEX = 126) THEN
            LAST<='1';
          ELSE
            IF (LAST='1') THEN
              RUNNING<='0';
		      LAST<='0';
		      READY<='1';
            END IF; -- LAST
          END IF; -- COEF_INDEX = LAST_COEF
        END IF; -- START
      END IF;
    END IF;
  END PROCESS;

-- ACCU
  PROCESS (CLK,RESET)
  BEGIN
    IF (CLK'EVENT AND CLK='1') THEN
      IF (START='1' AND RUNNING='0') THEN
        ACCU <= TO_SIGNED(0,40);
      ELSE
        IF (RUNNING='1') THEN
          ACCU <= ACCU + ((SIGNED (H_DATA))*(SIGNED (COEF_DATA)));
        END IF; -- RUNNING
      END IF; -- START
    END IF; -- POSEDGE CLK
  END PROCESS;

-- SAMPLE OUT
  PROCESS (CLK,RESET)
  BEGIN
    IF (CLK'EVENT AND CLK='1') THEN
      IF (LAST='1') THEN SAMPLE_OUT <= STD_LOGIC_VECTOR (ACCU(31 DOWNTO 16)); 
      END IF;
    END IF; -- POSEDGE CLK
  END PROCESS;


END FIR_core_architecture;
