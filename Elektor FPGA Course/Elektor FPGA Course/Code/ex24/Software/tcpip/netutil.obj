objectfile:netutil.obj
time:Wed Dec 13 13:00:41 2006
cpuname:i8051
import:_Read_Frame_long_Phy
import:_Read_Frame_word_Phy
import:__cmp_i4
import:__ld_a_r47
import:__st_a_r47
import:__movel_4_0
export:_net_match_ulong @3:0
export:_ip_check @8:0
export:_net_match_uint @7:0
export:_ip_check_more @8:3
export:_xram_fast_copy @9:0
segment:_net_match_ulong_formal_near @0:m s:0 u:0 n f c:dram
segment:_net_match_ulong_local_near @1:m s:4 u:0 n f c:dram
segment:_Read_Frame_long_Phy_formal_near @2:m s:0 u:0 n f c:dram
segment:__net_match_ulong @3:m u:1d
74 00 12 00 00 12 00 00 12 00 00 74 00 12 00 00
c3 12 00 00 60 00 7f 01 80 00 e4 ff 22
segment:_net_match_uint_formal_near @4:m s:0 u:0 n f c:dram
segment:_net_match_uint_local_near @5:m s:2 u:0 n f c:dram
segment:_Read_Frame_word_Phy_formal_near @6:m s:0 u:0 n f c:dram
segment:__net_match_uint @7:m u:1e
8e 00 8f 00 12 00 00 ac 06 ad 07 ae 00 af 00 ef
6d 70 00 ee 6c 60 00 7f 01 80 00 e4 ff 22
segment:__ip_check @8:m u:36
e4 fa fb 8f 82 8e 83 ae 02 af 03 75 f0 00 ec 4d
60 00 ed 60 00 0c e0 a3 30 f0 00 2f ff 50 00 0e
ee 70 00 0f 80 00 2e fe 50 00 0f ef 70 00 0e 05
f0 dd 00 dc 00 22
segment:__xram_fast_copy @9:m u:1d
eb 60 00 0a 8f 82 8e 83 e0 a3 af 82 ae 83 8d 82
8c 83 f0 a3 ad 82 ac 83 db 00 da 00 22
sgraph:_net_match_ulong_formal_near _net_match_ulong_local_near __net_match_ulong
sgraph:_net_match_ulong_local_near _Read_Frame_long_Phy_formal_near __net_match_ulong 4
sgraph:_net_match_uint_formal_near _net_match_uint_local_near __net_match_uint
sgraph:_net_match_uint_local_near _Read_Frame_word_Phy_formal_near __net_match_uint 2
src:tcpip\netutil.s51 #0
src:C:\uC51\include\reg51.def #1
ref byte #0:32 @3:1 @1:0 0 +
ref w_hl #0:33 @3:3 __st_a_r47
ref w_hl #0:35 @3:6 _Read_Frame_long_Phy
ref w_hl #0:36 @3:9 __movel_4_0
ref byte #0:37 @3:c @1:0 0 +
ref w_hl #0:38 @3:e __ld_a_r47
ref w_hl #0:3a @3:12 __cmp_i4
ref rbyte #0:3b @3:15 @3:1a
ref rbyte #0:3e @3:19 @3:1c
ref byte #0:55 @7:1 @5:0 0 +
ref byte #0:56 @7:3 @5:0 0 + 1 +
ref w_hl #0:58 @7:5 _Read_Frame_word_Phy
ref byte #0:5b @7:c @5:0 0 +
ref byte #0:5c @7:e @5:0 0 + 1 +
ref rbyte #0:5f @7:12 @7:17
ref rbyte #0:62 @7:16 @7:1b
ref rbyte #0:66 @7:1a @7:1d
ref rbyte #0:7f @8:11 @8:35
ref rbyte #0:81 @8:14 @8:16
ref rbyte #0:85 @8:1a @8:26
ref rbyte #0:88 @8:1e @8:2f
ref rbyte #0:8b @8:22 @8:2f
ref rbyte #0:8d @8:25 @8:2f
ref rbyte #0:90 @8:29 @8:2f
ref rbyte #0:93 @8:2d @8:2f
ref rbyte #0:96 @8:32 @8:16
ref rbyte #0:97 @8:34 @8:16
ref rbyte #0:a1 @9:2 @9:4
ref rbyte #0:b2 @9:19 @9:4
ref rbyte #0:b3 @9:1b @9:4
objectdebug
dtx ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
dtx ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
dtx ; sourcefile: 'tcpip\netutil.c', time: Wed Dec 13 13:00:41 2006
dtx 
dtx  .hide
dtx  .show
dtx XDS=0
dtx COS=1
dtx NES=2
dtx INS=2
dtx .macro __line
dtx lcall $0006 ; uC/51 debugger
dtx .endmacro
dtx         .include <reg51.def>
dtx ; **** 8051 standard defs ***
dtx ; common registers to all 8051's
dtx         .hide
dtx         .show
dtx  .export _net_match_ulong ; unsigned char net_match_ulong(unsigned long)
dtx  .hide
dtx  .show
dtx 
dtx  .segment __net_match_ulong
dtx _net_match_ulong: ; unsigned char net_match_ulong(unsigned long)
dtx  ; parameter 'm' in 'RL4567' moved and assigned to local '?net_match_ulong_m'
dco @3:0 u:2  mov A,#?net_match_ulong_m
dco @3:2 u:3  lcall __st_a_r47
dhl /**********************************************************************************
dhl * Netutil.c
dhl *
dhl * Some TCP/IP utility functions
dhl *
dhl * V2.01 (C) 2004 WWW.WICKENHAEUSER.DE
dhl *
dhl * Please support us:
dhl * ==================
dhl * 
dhl * The offer the uC/51-ANSI-C-Compiler at a very low price. So we do not have a
dhl * large budget for advertisements. Every link to our Internet pages
dhl * (WWW.WICKENHAEUSER.COM, WWW.WICKENHAEUSER.DE, WWW.FLEXGATE.COM, WWW.FLEXGATE.DE)
dhl * is welcome! 
dhl *
dhl **********************************************************************************/
dhl 
dhl 
dhl #include <stdio.h>
dhl #include <reg51.h>
dhl 
dhl #include "phy.h"                // Physical Layer
dhl #include "netutil.h"            // Utilities
dhl 
dhl 
dhl /**********************************************************************************
dhl * uchar net_match_ulong(unsigned long m)
dhl * 
dhl * function, that returns 0 only if the nrext read word from the Ethernet matches
dhl * matches a fixed one
dhl **********************************************************************************/
dhl uchar net_match_ulong(unsigned long m){
dco @3:5 u:3  lcall _Read_Frame_long_Phy
dco @3:8 u:3  lcall __movel_4_0
dco @3:b u:2  mov A,#?net_match_ulong_m
dco @3:d u:3  lcall __ld_a_r47
dco @3:10 u:1  clr C
dco @3:11 u:3  lcall __cmp_i4
dco @3:14 u:2  jz ?2
dhl         if(Read_Frame_long_Phy()!=m) return 1;
dco @3:16 u:2  mov R7,#1
dco @3:18 u:2  sjmp ?1
dtx ?2:
dhl         return 0;       // MATCH!
dco @3:1a u:1  clr A
dco @3:1b u:1  mov R7,A
dtx ?1:
dco @3:1c u:1  ret
dtx ; end of function net_match_ulong
dtx ; used: R01234567 BR01234567 DPTR ACC PSW B locals:4 bytes
dtx 
dtx  .export _net_match_uint ; unsigned char net_match_uint(unsigned int)
dtx  .hide
dtx  .show
dtx 
dtx  .segment __net_match_uint
dtx _net_match_uint: ; unsigned char net_match_uint(unsigned int)
dtx  ; parameter 'm' in 'RW67' moved and assigned to local '?net_match_uint_m'
dco @7:0 u:2  mov ?net_match_uint_m,R6
dco @7:2 u:2  mov ?net_match_uint_m+1,R7
dhl }
dhl /**********************************************************************************
dhl * uchar net_match_uint(uint m){
dhl * 
dhl * function, that returns 0 only if the next read long from the Ethernet matches
dhl * matches a fixed one
dhl **********************************************************************************/
dhl uchar net_match_uint(uint m){
dco @7:4 u:3  lcall _Read_Frame_word_Phy
dco @7:7 u:2  mov R4,AR6
dco @7:9 u:2  mov R5,AR7
dco @7:b u:2  mov R6,?net_match_uint_m
dco @7:d u:2  mov R7,?net_match_uint_m+1
dco @7:f u:1  mov A,R7
dco @7:10 u:1  xrl A,R5
dco @7:11 u:2  jnz ?_2
dco @7:13 u:1  mov A,R6
dco @7:14 u:1  xrl A,R4
dco @7:15 u:2  jz ?5
dtx ?_2:
dhl         if(Read_Frame_word_Phy()!=m) return 1;
dco @7:17 u:2  mov R7,#1
dco @7:19 u:2  sjmp ?4
dtx ?5:
dhl         return 0;       // MATCH!
dco @7:1b u:1  clr A
dco @7:1c u:1  mov R7,A
dtx ?4:
dco @7:1d u:1  ret
dtx ; end of function net_match_uint
dtx ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
dtx 
dtx         .segment __ip_check
dtx         .export _ip_check, _ip_check_more
dtx _ip_check:              ; Adr: R6:R7, len: R4:R5, tmp: B
dco @8:0 u:1         clr A           ; R6:7 working reg. (delayed in R2:3)
dco @8:1 u:1         mov R2,A
dco @8:2 u:1         mov R3,A
dtx 
dtx _ip_check_more:         ; Adr: R6:R7, len: R4:R5, tmp: B, old_cs in R2:R3
dco @8:3 u:2         mov DPL,R7
dco @8:5 u:2         mov DPH,R6
dco @8:7 u:2         mov R6,2        ; CS Working register, copy from R2
dco @8:9 u:2         mov R7,3        ; R3
dco @8:b u:3         mov B,#0        ;
dco @8:e u:1         mov A,R4        ; omit 0 words len
dco @8:f u:1         orl A,R5
dco @8:10 u:2         jz ?csx
dco @8:12 u:1         mov A,R5        ; prepare to use 2 djnz
dco @8:13 u:2         jz ?cs1
dco @8:15 u:1         inc R4
dco @8:16 u:1 ?cs1:   movx A,@DPTR
dco @8:17 u:1         inc DPTR
dco @8:18 u:3         jnb B.0,?csh
dco @8:1b u:1         add A,R7
dco @8:1c u:1         mov R7,A
dco @8:1d u:2         jnc ?cs2
dco @8:1f u:1         inc R6
dco @8:20 u:1         mov A,R6
dco @8:21 u:2         jnz ?cs2
dco @8:23 u:1         inc R7
dco @8:24 u:2         sjmp ?cs2
dco @8:26 u:1 ?csh:   add A,R6
dco @8:27 u:1         mov R6,A
dco @8:28 u:2         jnc ?cs2
dco @8:2a u:1         inc R7
dco @8:2b u:1         mov A,R7
dco @8:2c u:2         jnz ?cs2
dco @8:2e u:1         inc R6
dco @8:2f u:2 ?cs2:   inc B
dco @8:31 u:2         djnz R5,?cs1
dco @8:33 u:2         djnz R4,?cs1
dtx ?csx:
dco @8:35 u:1         ret
dtx         .segment __xram_fast_copy
dtx         .export _xram_fast_copy
dtx _xram_fast_copy:
dtx         ; src in R6/R7
dtx         ; dest in R4/R5
dtx         ; len in R2/R3
dco @9:0 u:1         mov A,R3        ; prepare to use 2 djnz
dco @9:1 u:2         jz ?xfc1
dco @9:3 u:1         inc R2
dtx ?xfc1:  ; get from source byte
dco @9:4 u:2         mov DPL,R7
dco @9:6 u:2         mov DPH,R6
dco @9:8 u:1         movx A,@DPTR
dco @9:9 u:1         inc DPTR
dco @9:a u:2         mov R7,DPL
dco @9:c u:2         mov R6,DPH
dtx         ; write to dest byte
dco @9:e u:2         mov DPL,R5
dco @9:10 u:2         mov DPH,R4
dco @9:12 u:1         movx @DPTR,A
dco @9:13 u:1         inc DPTR
dco @9:14 u:2         mov R5,DPL
dco @9:16 u:2         mov R4,DPH
dtx         ; loop
dco @9:18 u:2         djnz R3,?xfc1
dco @9:1a u:2         djnz R2,?xfc1
dco @9:1c u:1         ret
dtx  .import _Read_Frame_long_Phy ; unsigned long Read_Frame_long_Phy(void)
dtx  .import _Read_Frame_word_Phy ; unsigned int Read_Frame_word_Phy(void)
dtx  .end
dhl }
dhl 
dhl /**********************************************************************************
dhl * unsigned int ip_check(xdata uchar* ps, uint len);
dhl * unsigned int ip_check_more(xdata uchar* ps, uint len, uint old_cs);
dhl *
dhl * Calculate an IP Checksum of Xram Block Block , 
dhl * Used Assembler: This is really FAST! 
dhl * ip_check_more: Takes a given CS and adds some more bytes. This is necessary
dhl * for TCP-segments (and optional UDP too), if data are not in a continous block...
dhl * ip_check_more is only allowed if previously an even number of bytes was read...
dhl **********************************************************************************/
dhl #asm
dhl         .segment __ip_check
dhl         .export _ip_check, _ip_check_more
dhl _ip_check:              ; Adr: R6:R7, len: R4:R5, tmp: B
dhl         clr A           ; R6:7 working reg. (delayed in R2:3)
dhl         mov R2,A
dhl         mov R3,A
dhl 
dhl _ip_check_more:         ; Adr: R6:R7, len: R4:R5, tmp: B, old_cs in R2:R3
dhl         mov DPL,R7
dhl         mov DPH,R6
dhl         mov R6,2        ; CS Working register, copy from R2
dhl         mov R7,3        ; R3
dhl         mov B,#0        ; 
dhl         mov A,R4        ; omit 0 words len
dhl         orl A,R5
dhl         jz ?csx
dhl         mov A,R5        ; prepare to use 2 djnz
dhl         jz ?cs1
dhl         inc R4  
dhl ?cs1:   movx A,@DPTR
dhl         inc DPTR
dhl         jnb B.0,?csh
dhl         add A,R7
dhl         mov R7,A
dhl         jnc ?cs2
dhl         inc R6
dhl         mov A,R6
dhl         jnz ?cs2
dhl         inc R7
dhl         sjmp ?cs2
dhl ?csh:   add A,R6
dhl         mov R6,A
dhl         jnc ?cs2
dhl         inc R7
dhl         mov A,R7
dhl         jnz ?cs2
dhl         inc R6
dhl ?cs2:   inc B
dhl         djnz R5,?cs1    
dhl         djnz R4,?cs1    
dhl ?csx:   
dhl         ret
dhl #endasm
dhl 
dhl /**********************************************************************************
dhl * void xram_fast_copy(xdata uchar* src,xdata uchar* dest,uint size);
dhl * 
dhl * Copy size data in XRAM
dhl **********************************************************************************/
dhl void xram_fast_copy(xdata uchar* src,xdata uchar* dest,uint size);
dhl #asm
dhl         .segment __xram_fast_copy
dhl         .export _xram_fast_copy
dhl _xram_fast_copy:
dhl         ; src in R6/R7
dhl         ; dest in R4/R5
dhl         ; len in R2/R3
dhl         mov A,R3        ; prepare to use 2 djnz
dhl         jz ?xfc1
dhl         inc R2  
dhl ?xfc1:  ; get from source byte
dhl         mov DPL,R7
dhl         mov DPH,R6
dhl         movx A,@DPTR
dhl         inc DPTR
dhl         mov R7,DPL
dhl         mov R6,DPH
dhl         ; write to dest byte
dhl         mov DPL,R5
dhl         mov DPH,R4
dhl         movx @DPTR,A
dhl         inc DPTR
dhl         mov R5,DPL
dhl         mov R4,DPH
dhl         ; loop
dhl         djnz R3,?xfc1
dhl         djnz R2,?xfc1
dhl         ret
dhl #endasm
dhl 
dhl // END
def:_net_match_ulong @3:0
def:_ip_check @8:0
def:_net_match_uint @7:0
def:_ip_check_more @8:3
def:_xram_fast_copy @9:0
objectend
