listing:fg1_http.lst, Wed Dec 13 13:00:42 2006
objectfile:tcpip\open_ether.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'tcpip\open_ether.c', time: Wed Dec 13 13:00:40 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :         .include <reg52.def>
                        : ; **** 80C52 (extended) defs ***
                        : 
                        :         .hide
                        :         .show
                        :         P0    = $80
                        :         sevseg_ctrl  = $C0;
                        :   sevseg_data0 = $C1;
                        :   sevseg_data1 = $C2;
                        :   sevseg_data2 = $C3;
                        :   sevseg_data3 = $C4;
                        :   sevseg_en    = $C5;
                        :   _sevseg_ctrl  = sevseg_ctrl;
                        :   _sevseg_data0 = sevseg_data0;
                        :   _sevseg_data1 = sevseg_data1;
                        :   _sevseg_data2 = sevseg_data2;
                        :   _sevseg_data3 = sevseg_data3;
                        :   _sevseg_en    = sevseg_en;
                        : 
                        :  .export _set_mac_add ; void set_mac_add(xdata unsigned char *)
                        :  .segment _set_mac_add_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _set_mac_add_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _set_mac_add_formal_near, _set_mac_add_local_near, __set_mac_add
                        : 
                        :  .segment __set_mac_add
                        : _set_mac_add: ; (leaf function) void set_mac_add(xdata unsigned char *)
                        :  ; parameter 'addr' in 'RW67' assigned to 'RW01'
co:24e5: a8 06          :  mov R0,AR6
co:24e7: a9 07          :  mov R1,AR7
                        :>/*********************************************************************************
                        :>* open_ether.c
                        :>*
                        :>* This is the network driver for a OpenCores Ethernet MAC
                        :>* -> The Physical Layer ('PHY.C') <-
                        :>*
                        :>* V1.02 (C) 2006 Andreas Voggeneder
                        :>*
                        :>*
                        :>**********************************************************************************/
                        :>
                        :>#include <stdio.h>
                        :>
                        :>#include <reg52.h>
                        :>
                        :>#include "net.h"                // MAC
                        :>
                        :>#include "phy.h"                      // Physical Layer
                        :>#include "open_ether.h"         // OpenCores Ethernet MAC Register Definitions 
                        :>
                        :>#ifndef PHY_ETH
                        :> #error Ethernet-Phy must be defined in net.h
                        :>#endif
                        :>
                        :>xdata uchar* near pRxPtr;
                        :>
                        :>void set_mac_add(xdata uchar *addr)
                        :>{ 
co:24e9: 74 01          :  mov A,#1
co:24eb: 29             :  add A,R1
co:24ec: ff             :  mov R7,A
co:24ed: e4             :  clr A
co:24ee: 38             :  addc A,R0
co:24ef: fe             :  mov R6,A
co:24f0: 85 06 83       :  mov DPH,AR6
co:24f3: 85 07 82       :  mov DPL,AR7
co:24f6: e0             :  movx A,@DPTR
co:24f7: ff             :  mov R7,A
co:24f8: ab 07          :  mov R3,AR7
co:24fa: 7a 00          :  mov R2,#0
co:24fc: 85 00 83       :  mov DPH,AR0
co:24ff: 85 01 82       :  mov DPL,AR1
co:2502: e0             :  movx A,@DPTR
co:2503: ff             :  mov R7,A
co:2504: ad 07          :  mov R5,AR7
co:2506: 7c 00          :  mov R4,#0
co:2508: 7f 08          :  mov R7,#8
co:250a: ae 04          :  mov R6,AR4
co:250c: ed             :  mov A,R5
co:250d: 8f f0          :  mov B,R7
co:250f: 05 f0          :  inc B
co:2511: 80 05          :  sjmp ?_1
                        : ?_2:
co:2513: c3             :  clr C
co:2514: 33             :  rlc A
co:2515: ce             :  xch A,R6
co:2516: 33             :  rlc A
co:2517: ce             :  xch A,R6
                        : ?_1:
co:2518: d5 f0 f8       :  djnz B,?_2
co:251b: ff             :  mov R7,A
co:251c: 4b             :  orl A,R3
co:251d: ff             :  mov R7,A
co:251e: ee             :  mov A,R6
co:251f: 4a             :  orl A,R2
co:2520: fe             :  mov R6,A
co:2521: e4             :  clr A
co:2522: fd             :  mov R5,A
co:2523: fc             :  mov R4,A
co:2524: 90 d0 44       :  mov DPTR,#53316
co:2527: 12 04 f1       :  lcall __st_dptr_r47
                        :>  *MAC_ADDR2 =  addr[0] << 8    |       addr[1];
                        :>  *MAC_ADDR1 = *((unsigned long*)       &addr[2]);
co:252a: 74 02          :  mov A,#2
co:252c: 29             :  add A,R1
co:252d: ff             :  mov R7,A
co:252e: e4             :  clr A
co:252f: 38             :  addc A,R0
co:2530: fe             :  mov R6,A
co:2531: 7c 00          :  mov R4,#XDS
co:2533: 12 21 59       :  lcall __gen_read32_i4
co:2536: 90 d0 40       :  mov DPTR,#53312
co:2539: 12 04 f1       :  lcall __st_dptr_r47
co:253c: 22             :  ret
                        : ; end of function set_mac_add
                        : ; used: R01234567 BR-------- DPTR ACC PSW B
                        : 
                        :  .export _Init_Mac ; unsigned char Init_Mac(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __Init_Mac
                        : _Init_Mac: ; unsigned char Init_Mac(void)
                        :>}
                        :>
                        :>uchar Init_Mac(void) {
co:2281: 90 d0 00       :  mov DPTR,#53248
co:2284: e4             :  clr A
co:2285: f0             :  movx @DPTR,A
co:2286: a3             :  inc DPTR
co:2287: f0             :  movx @DPTR,A
co:2288: a3             :  inc DPTR
co:2289: 74 08          :  mov A,#8
co:228b: f0             :  movx @DPTR,A
co:228c: a3             :  inc DPTR
co:228d: e4             :  clr A
co:228e: f0             :  movx @DPTR,A
                        :>  unsigned char i;
                        :>  volatile xdata oeth_bd* rxtx_bd;
                        :>  
                        :>  *MODER = OETH_MODER_RST;      /* Reset ON */
                        :>        *MODER &= ~OETH_MODER_RST;      /* Reset OFF */
co:228f: 90 d0 00       :  mov DPTR,#53248
co:2292: 12 01 71       :  lcall __ld_dptr_r47
co:2295: 53 06 f7       :  anl AR6,#247
co:2298: e4             :  clr A
co:2299: fd             :  mov R5,A
co:229a: fc             :  mov R4,A
co:229b: 90 d0 00       :  mov DPTR,#53248
co:229e: 12 04 f1       :  lcall __st_dptr_r47
                        :>  *TX_BD_NUM=OETH_TXBD_NUM;
co:22a1: 90 d0 23       :  mov DPTR,#53283
co:22a4: 74 01          :  mov A,#1
co:22a6: f0             :  movx @DPTR,A
                        :>  *PACKETLEN = 0x00400600;
co:22a7: 90 d0 18       :  mov DPTR,#53272
co:22aa: e4             :  clr A
co:22ab: f0             :  movx @DPTR,A
co:22ac: a3             :  inc DPTR
co:22ad: 74 40          :  mov A,#64
co:22af: f0             :  movx @DPTR,A
co:22b0: a3             :  inc DPTR
co:22b1: 74 06          :  mov A,#6
co:22b3: f0             :  movx @DPTR,A
co:22b4: a3             :  inc DPTR
co:22b5: e4             :  clr A
co:22b6: f0             :  movx @DPTR,A
                        :>  *IPGT = 0x00000012;
co:22b7: 90 d0 0f       :  mov DPTR,#53263
co:22ba: 74 12          :  mov A,#18
co:22bc: f0             :  movx @DPTR,A
                        :>  *IPGR1 = 0x0000000c;
co:22bd: 90 d0 13       :  mov DPTR,#53267
co:22c0: 74 0c          :  mov A,#12
co:22c2: f0             :  movx @DPTR,A
                        :>  *IPGR2 = 0x00000012;
co:22c3: 90 d0 17       :  mov DPTR,#53271
co:22c6: 74 12          :  mov A,#18
co:22c8: f0             :  movx @DPTR,A
                        :>  *COLLCONF = 0x000f003f;
co:22c9: 90 d0 1c       :  mov DPTR,#53276
co:22cc: e4             :  clr A
co:22cd: f0             :  movx @DPTR,A
co:22ce: a3             :  inc DPTR
co:22cf: 74 0f          :  mov A,#15
co:22d1: f0             :  movx @DPTR,A
co:22d2: a3             :  inc DPTR
co:22d3: e4             :  clr A
co:22d4: f0             :  movx @DPTR,A
co:22d5: a3             :  inc DPTR
co:22d6: 74 3f          :  mov A,#63
co:22d8: f0             :  movx @DPTR,A
                        :>  *CTRLMODER = 0;
co:22d9: 90 d0 27       :  mov DPTR,#53287
co:22dc: e4             :  clr A
co:22dd: f0             :  movx @DPTR,A
                        :  ; variable 'rxtx_bd' assigned to register 'B1_RW89'
                        :>
                        :>/*
                        :>// Activate Fullduplex Mode
                        :>  i=0;
                        :>  *MIIADDRESS = 4<<8;
                        :>  *MII_TX_DATA = 0x1e1;
                        :>  *MIICOMMAND = OETH_MIICOMMAND_WCTRLDATA; 
                        :>  while(*MII_STATUS & OETH_MIISTATUS_BUSY) {
                        :>    i++;
                        :>  }
                        :>
                        :>  
                        :>  i=0;
                        :>  *MIIADDRESS = 0<<8;
                        :>  *MII_TX_DATA = 0x3300;
                        :>  *MIICOMMAND = OETH_MIICOMMAND_WCTRLDATA; 
                        :>  while(*MII_STATUS & OETH_MIISTATUS_BUSY) {
                        :>    i++;
                        :>  }   */ 
                        :>
                        :>  // Set up TX Descriptors
                        :>  // Mapped between A400 and A40f
                        :>  rxtx_bd = OETH_BD_BASE;
co:22de: 75 08 d4       :  mov AR8,#212
                        :>  for(i = 0; i < OETH_TXBD_NUM; i++) {
co:22e1: e4             :  clr A
co:22e2: f5 09          :  mov AR9,A
co:22e4: f9             :  mov R1,A
                        :  ; variable 'i' assigned to register 'R1'
                        : ?9:
                        : 
co:22e5: ad 01          :  mov R5,AR1
co:22e7: 7c 00          :  mov R4,#0
co:22e9: 7f 03          :  mov R7,#3
co:22eb: ae 04          :  mov R6,AR4
co:22ed: ed             :  mov A,R5
co:22ee: 8f f0          :  mov B,R7
co:22f0: 05 f0          :  inc B
co:22f2: 80 05          :  sjmp ?_3
                        : ?_4:
co:22f4: c3             :  clr C
co:22f5: 33             :  rlc A
co:22f6: ce             :  xch A,R6
co:22f7: 33             :  rlc A
co:22f8: ce             :  xch A,R6
                        : ?_3:
co:22f9: d5 f0 f8       :  djnz B,?_4
co:22fc: ff             :  mov R7,A
co:22fd: e5 09          :  mov A,AR9
co:22ff: 2f             :  add A,R7
co:2300: fb             :  mov R3,A
co:2301: e5 08          :  mov A,AR8
co:2303: 3e             :  addc A,R6
co:2304: fa             :  mov R2,A
co:2305: e4             :  clr A
co:2306: fc             :  mov R4,A
co:2307: fd             :  mov R5,A
co:2308: 7e 58          :  mov R6,#88
co:230a: 7f 00          :  mov R7,#0
co:230c: 8a 83          :  mov DPH,R2
co:230e: 8b 82          :  mov DPL,R3
co:2310: 12 04 f1       :  lcall __st_dptr_r47
                        :>    rxtx_bd[i].u.len_status = OETH_TX_BD_PAD | OETH_TX_BD_CRC | OETH_RX_BD_IRQ;
                        :>    rxtx_bd[i].addr = TX_BD_BASE+(MAX_FRAME_SIZE*i);
co:2313: ad 01          :  mov R5,AR1
co:2315: 7c 00          :  mov R4,#0
co:2317: 7f 03          :  mov R7,#3
co:2319: ae 04          :  mov R6,AR4
co:231b: ed             :  mov A,R5
co:231c: 8f f0          :  mov B,R7
co:231e: 05 f0          :  inc B
co:2320: 80 05          :  sjmp ?_5
                        : ?_6:
co:2322: c3             :  clr C
co:2323: 33             :  rlc A
co:2324: ce             :  xch A,R6
co:2325: 33             :  rlc A
co:2326: ce             :  xch A,R6
                        : ?_5:
co:2327: d5 f0 f8       :  djnz B,?_6
co:232a: ff             :  mov R7,A
co:232b: e5 09          :  mov A,AR9
co:232d: 2f             :  add A,R7
co:232e: ff             :  mov R7,A
co:232f: e5 08          :  mov A,AR8
co:2331: 3e             :  addc A,R6
co:2332: fe             :  mov R6,A
co:2333: 74 04          :  mov A,#4
co:2335: 2f             :  add A,R7
co:2336: fb             :  mov R3,A
co:2337: e4             :  clr A
co:2338: 3e             :  addc A,R6
co:2339: fa             :  mov R2,A
co:233a: ae 04          :  mov R6,AR4
co:233c: af 05          :  mov R7,AR5
co:233e: 7c 06          :  mov R4,#6
co:2340: 7d 00          :  mov R5,#0
co:2342: 12 22 2a       :  lcall __mul_i2
co:2345: e4             :  clr A
co:2346: 2f             :  add A,R7
co:2347: ff             :  mov R7,A
co:2348: 74 18          :  mov A,#24
co:234a: 3e             :  addc A,R6
co:234b: fe             :  mov R6,A
co:234c: e4             :  clr A
co:234d: fd             :  mov R5,A
co:234e: fc             :  mov R4,A
co:234f: 8a 83          :  mov DPH,R2
co:2351: 8b 82          :  mov DPL,R3
co:2353: 12 04 f1       :  lcall __st_dptr_r47
                        :>  }
co:2356: 09             :  inc R1
                        : 
co:2357: b9 01 02       :  cjne R1,#1,?_7
co:235a: 80 03          :  sjmp ?_8
                        : ?_7:
co:235c: 02 22 e5       :  ljmp ?9
                        : ?_8:
                        :>  rxtx_bd[OETH_TXBD_NUM - 1].u.len_status |= OETH_TX_BD_WRAP;
co:235f: ae 08          :  mov R6,AR8
co:2361: af 09          :  mov R7,AR9
co:2363: 8e 83          :  mov DPH,R6
co:2365: 8f 82          :  mov DPL,R7
co:2367: 12 01 71       :  lcall __ld_dptr_r47
co:236a: 43 06 20       :  orl AR6,#32
co:236d: aa 08          :  mov R2,AR8
co:236f: ab 09          :  mov R3,AR9
co:2371: 8a 83          :  mov DPH,R2
co:2373: 8b 82          :  mov DPL,R3
co:2375: 12 04 f1       :  lcall __st_dptr_r47
                        :>
                        :>  // Set up RX Descriptors
                        :>  rxtx_bd = (xdata oeth_bd*)((uint)OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd));   //RX_BD_BASE|OETH_BD
co:2378: 7e d4          :  mov R6,#212
co:237a: 7f 00          :  mov R7,#0
co:237c: 74 08          :  mov A,#8
co:237e: 2f             :  add A,R7
co:237f: ff             :  mov R7,A
co:2380: e4             :  clr A
co:2381: 3e             :  addc A,R6
co:2382: fe             :  mov R6,A
                        :  ; variable 'rxtx_bd' assigned to register 'B1_RW89'
co:2383: 8e 08          :  mov AR8,R6
co:2385: 8f 09          :  mov AR9,R7
                        :>
                        :>  
                        :>  for(i = 0; i < OETH_RXBD_NUM; i++) {
co:2387: e4             :  clr A
co:2388: f9             :  mov R1,A
                        :  ; variable 'i' assigned to register 'R1'
                        : ?13:
                        : 
co:2389: ad 01          :  mov R5,AR1
co:238b: 7c 00          :  mov R4,#0
co:238d: 7f 03          :  mov R7,#3
co:238f: ae 04          :  mov R6,AR4
co:2391: ed             :  mov A,R5
co:2392: 8f f0          :  mov B,R7
co:2394: 05 f0          :  inc B
co:2396: 80 05          :  sjmp ?_9
                        : ?_10:
co:2398: c3             :  clr C
co:2399: 33             :  rlc A
co:239a: ce             :  xch A,R6
co:239b: 33             :  rlc A
co:239c: ce             :  xch A,R6
                        : ?_9:
co:239d: d5 f0 f8       :  djnz B,?_10
co:23a0: ff             :  mov R7,A
co:23a1: e5 09          :  mov A,AR9
co:23a3: 2f             :  add A,R7
co:23a4: fb             :  mov R3,A
co:23a5: e5 08          :  mov A,AR8
co:23a7: 3e             :  addc A,R6
co:23a8: fa             :  mov R2,A
co:23a9: 7d 10          :  mov R5,#16
co:23ab: e4             :  clr A
co:23ac: fe             :  mov R6,A
co:23ad: ff             :  mov R7,A
co:23ae: 8d f0          :  mov B,R5
co:23b0: 05 f0          :  inc B
co:23b2: 80 05          :  sjmp ?_11
                        : ?_12:
co:23b4: c3             :  clr C
co:23b5: 33             :  rlc A
co:23b6: ce             :  xch A,R6
co:23b7: 33             :  rlc A
co:23b8: ce             :  xch A,R6
                        : ?_11:
co:23b9: d5 f0 f8       :  djnz B,?_12
co:23bc: ff             :  mov R7,A
co:23bd: ff             :  mov R7,A
co:23be: 43 06 80       :  orl AR6,#128
co:23c1: 43 06 40       :  orl AR6,#64
co:23c4: e4             :  clr A
co:23c5: fd             :  mov R5,A
co:23c6: fc             :  mov R4,A
co:23c7: 8a 83          :  mov DPH,R2
co:23c9: 8b 82          :  mov DPL,R3
co:23cb: 12 04 f1       :  lcall __st_dptr_r47
                        :>    rxtx_bd[i].u.len_status = (0 << 16) | OETH_RX_BD_EMPTY | OETH_RX_BD_IRQ;
                        :>    rxtx_bd[i].addr = RX_BD_BASE+(MAX_FRAME_SIZE*i);
co:23ce: ad 01          :  mov R5,AR1
co:23d0: 7c 00          :  mov R4,#0
co:23d2: 7f 03          :  mov R7,#3
co:23d4: ae 04          :  mov R6,AR4
co:23d6: ed             :  mov A,R5
co:23d7: 8f f0          :  mov B,R7
co:23d9: 05 f0          :  inc B
co:23db: 80 05          :  sjmp ?_13
                        : ?_14:
co:23dd: c3             :  clr C
co:23de: 33             :  rlc A
co:23df: ce             :  xch A,R6
co:23e0: 33             :  rlc A
co:23e1: ce             :  xch A,R6
                        : ?_13:
co:23e2: d5 f0 f8       :  djnz B,?_14
co:23e5: ff             :  mov R7,A
co:23e6: e5 09          :  mov A,AR9
co:23e8: 2f             :  add A,R7
co:23e9: ff             :  mov R7,A
co:23ea: e5 08          :  mov A,AR8
co:23ec: 3e             :  addc A,R6
co:23ed: fe             :  mov R6,A
co:23ee: 74 04          :  mov A,#4
co:23f0: 2f             :  add A,R7
co:23f1: fb             :  mov R3,A
co:23f2: e4             :  clr A
co:23f3: 3e             :  addc A,R6
co:23f4: fa             :  mov R2,A
co:23f5: ae 04          :  mov R6,AR4
co:23f7: af 05          :  mov R7,AR5
co:23f9: 7c 06          :  mov R4,#6
co:23fb: 7d 00          :  mov R5,#0
co:23fd: 12 22 2a       :  lcall __mul_i2
co:2400: e4             :  clr A
co:2401: fd             :  mov R5,A
co:2402: fc             :  mov R4,A
co:2403: 8a 83          :  mov DPH,R2
co:2405: 8b 82          :  mov DPL,R3
co:2407: 12 04 f1       :  lcall __st_dptr_r47
                        :>  }
co:240a: 09             :  inc R1
                        : 
co:240b: b9 04 02       :  cjne R1,#4,?_15
co:240e: 80 03          :  sjmp ?_16
                        : ?_15:
co:2410: 02 23 89       :  ljmp ?13
                        : ?_16:
                        :>  rxtx_bd[OETH_RXBD_NUM - 1].u.len_status |= OETH_RX_BD_WRAP;
co:2413: 74 18          :  mov A,#24
co:2415: 25 09          :  add A,AR9
co:2417: f5 09          :  mov AR9,A
co:2419: e4             :  clr A
co:241a: 35 08          :  addc A,AR8
co:241c: f5 08          :  mov AR8,A
co:241e: ae 08          :  mov R6,AR8
co:2420: af 09          :  mov R7,AR9
co:2422: 8e 83          :  mov DPH,R6
co:2424: 8f 82          :  mov DPL,R7
co:2426: 12 01 71       :  lcall __ld_dptr_r47
co:2429: 43 06 20       :  orl AR6,#32
co:242c: aa 08          :  mov R2,AR8
co:242e: ab 09          :  mov R3,AR9
co:2430: 8a 83          :  mov DPH,R2
co:2432: 8b 82          :  mov DPL,R3
co:2434: 12 04 f1       :  lcall __st_dptr_r47
                        :>
                        :>  set_mac_add(my_mac);
co:2437: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:2439: 7f 00          :  mov R7,#(_my_mac)&255
co:243b: 12 24 e5       :  lcall _set_mac_add
                        :>
                        :>  *INT_SOURCE = 0xffffffff;
co:243e: 7c ff          :  mov R4,#255
co:2440: 7d ff          :  mov R5,#255
co:2442: 7e ff          :  mov R6,#255
co:2444: 7f ff          :  mov R7,#255
co:2446: 90 d0 07       :  mov DPTR,#53255
co:2449: ef             :  mov A,R7
co:244a: f0             :  movx @DPTR,A
                        :>  *INT_MASK = OETH_INT_MASK_TXB         | 
co:244b: 90 d0 0b       :  mov DPTR,#53259
co:244e: 74 7f          :  mov A,#127
co:2450: f0             :  movx @DPTR,A
                        :>                                OETH_INT_MASK_TXE       | 
                        :>                                OETH_INT_MASK_RXF       | 
                        :>                                OETH_INT_MASK_RXE       |
                        :>                                OETH_INT_MASK_BUSY      |
                        :>                                OETH_INT_MASK_TXC         |
                        :>                                OETH_INT_MASK_RXC;
                        :>  *MODER |=  OETH_MODER_PAD | OETH_MODER_IFG | OETH_MODER_CRCEN
co:2451: 90 d0 00       :  mov DPTR,#53248
co:2454: 12 01 71       :  lcall __ld_dptr_r47
co:2457: 43 07 43       :  orl AR7,#67
co:245a: 43 06 a0       :  orl AR6,#160
co:245d: 90 d0 00       :  mov DPTR,#53248
co:2460: 12 04 f1       :  lcall __st_dptr_r47
                        :>         | OETH_MODER_RXEN | OETH_MODER_TXEN ;
                        :>  return 0;
co:2463: e4             :  clr A
co:2464: ff             :  mov R7,A
co:2465: 22             :  ret
                        : ; end of function Init_Mac
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _init_rx ; void init_rx(void)
                        :  .segment _init_rx_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _init_rx_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _init_rx_formal_near, _init_rx_local_near, __init_rx
                        : 
                        :  .segment __init_rx
                        : _init_rx: ; (leaf function) void init_rx(void)
                        :>}
                        :>
                        :>extern xdata oeth_bd* near rx_bd;
                        :>
                        :>void init_rx(void) {
co:24af: ae 42          :  mov R6,_rx_bd
co:24b1: af 43          :  mov R7,_rx_bd+1
co:24b3: 74 06          :  mov A,#6
co:24b5: 2f             :  add A,R7
co:24b6: ff             :  mov R7,A
co:24b7: e4             :  clr A
co:24b8: 3e             :  addc A,R6
co:24b9: fe             :  mov R6,A
co:24ba: 8e 83          :  mov DPH,R6
co:24bc: 8f 82          :  mov DPL,R7
co:24be: 12 0a af       :  lcall __ld_dptr_r67
                        :  ; variable 'ptmp' assigned to register 'RW67'
                        :>//    pRxPtr=(xdata uchar*)((*((xdata uint*)(rx_bd->addr)+1))|((uint)ETH_BUFFER_BASE));
                        :>// stupid compiler :-(
                        :>    xdata uint* ptmp= (xdata uint*)*((xdata uint*)(&rx_bd->addr)+1);
                        :>    pRxPtr=(xdata uchar*)((uint)ptmp|ETH_BUFFER_BASE);
co:24c1: 43 06 e0       :  orl AR6,#224
co:24c4: 8e 3b          :  mov _pRxPtr,R6
co:24c6: 8f 3c          :  mov _pRxPtr+1,R7
co:24c8: 22             :  ret
                        : ; end of function init_rx
                        : ; used: R------67 BR-------- DPTR ACC PSW
                        : 
                        :  .export _find_RX_Buffer ; xdata oeth_bd *find_RX_Buffer(void)
                        :  .segment _find_RX_Buffer_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _find_RX_Buffer_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _find_RX_Buffer_formal_near, _find_RX_Buffer_local_near, __find_RX_Buffer
                        : 
                        :  .segment __find_RX_Buffer
                        : _find_RX_Buffer: ; (leaf function) xdata oeth_bd *find_RX_Buffer(void)
                        :>}
                        :>
                        :>xdata oeth_bd* find_RX_Buffer() {
co:261c: 7e d4          :  mov R6,#212
co:261e: 7f 00          :  mov R7,#0
co:2620: 74 08          :  mov A,#8
co:2622: 2f             :  add A,R7
co:2623: fd             :  mov R5,A
co:2624: e4             :  clr A
co:2625: 3e             :  addc A,R6
co:2626: fc             :  mov R4,A
                        :  ; variable 'rx_bd' assigned to register 'RW45'
                        :>  volatile xdata oeth_bd *rx_bd=(xdata oeth_bd*)((uint)OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd));
                        :>  uchar i;
                        :>  for(i=0;i < OETH_RXBD_NUM; i++,rx_bd++) {
co:2627: e4             :  clr A
co:2628: fb             :  mov R3,A
                        :  ; variable 'i' assigned to register 'R3'
                        : ?21:
                        : 
co:2629: 74 02          :  mov A,#2
co:262b: 2d             :  add A,R5
co:262c: ff             :  mov R7,A
co:262d: e4             :  clr A
co:262e: 3c             :  addc A,R4
co:262f: fe             :  mov R6,A
co:2630: 8e 83          :  mov DPH,R6
co:2632: 8f 82          :  mov DPL,R7
co:2634: 12 0a af       :  lcall __ld_dptr_r67
co:2637: 7f 00          :  mov R7,#0
co:2639: 53 06 80       :  anl AR6,#128
co:263c: ee             :  mov A,R6
co:263d: 4f             :  orl A,R7
                        :>    if (!(rx_bd->u.ls.status & OETH_RX_BD_EMPTY)){
co:263e: 60 0f          :  jz ?23
                        :>      break;
                        :>    }
                        :>    
                        :>  }
co:2640: 0b             :  inc R3
co:2641: 74 08          :  mov A,#8
co:2643: 2d             :  add A,R5
co:2644: fd             :  mov R5,A
co:2645: e4             :  clr A
co:2646: 3c             :  addc A,R4
co:2647: fc             :  mov R4,A
                        : 
co:2648: 7f 04          :  mov R7,#4
co:264a: c3             :  clr C
co:264b: eb             :  mov A,R3
co:264c: 9f             :  subb A,R7
co:264d: 40 da          :  jc ?21
                        : ?23:
                        :>  if(i== OETH_RXBD_NUM) return 0;
co:264f: bb 04 05       :  cjne R3,#4,?27
                        : 
co:2652: e4             :  clr A
co:2653: fe             :  mov R6,A
co:2654: ff             :  mov R7,A
co:2655: 80 04          :  sjmp ?20
                        : ?27:
                        :>  return rx_bd;
co:2657: ae 04          :  mov R6,AR4
co:2659: af 05          :  mov R7,AR5
                        : ?20:
co:265b: 22             :  ret
                        : ; end of function find_RX_Buffer
                        : ; used: R---34567 BR-------- DPTR ACC PSW
                        : 
                        :  .segment neardata, sclass dram
                        :  .export _pTxPtr ; xdata unsigned char *near pTxPtr
                        : _pTxPtr: ; xdata unsigned char *near pTxPtr
dr:0040: 00 00          :  .dc.w 0
                        :  .export _RequestSend_Phy ; void RequestSend_Phy(unsigned int)
                        :  .segment _RequestSend_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _RequestSend_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _RequestSend_Phy_formal_near, _RequestSend_Phy_local_near, __RequestSend_Phy
                        : 
                        :  .segment __RequestSend_Phy
                        : _RequestSend_Phy: ; (leaf function) void RequestSend_Phy(unsigned int)
                        :  ; parameter 'FrameSize' in 'RW67'
                        :>
                        :>}
                        :>
                        :>
                        :>/*********************************************************************************
                        :>* void RequestSend(uint FrameSize);
                        :>*
                        :>* Note: Frame-Size in BYTES
                        :>* Requests space in on-chip memory for storing an outgoing frame
                        :>* This function must only be called ONCE.
                        :>**********************************************************************************/
                        :>//#define TX_BD         (volatile struct _oeth_bd xdata*)(OETH_BD_BASE)
                        :>
                        :>xdata uchar* near pTxPtr=0;
                        :>
                        :>void RequestSend_Phy(uint FrameSize){
co:253d: 90 d4 00       :  mov DPTR,#54272
co:2540: 12 0a c1       :  lcall __st_dptr_r67
                        :>
                        :>  volatile xdata oeth_bd* tx_bd= OETH_BD_BASE;
                        :>  tx_bd->u.ls.len    = FrameSize;
                        :>  tx_bd->u.ls.status = OETH_TX_BD_PAD | OETH_TX_BD_CRC | OETH_RX_BD_IRQ | OETH_TX_BD_WRAP;
co:2543: 7c d4          :  mov R4,#212
co:2545: 7d 00          :  mov R5,#0
co:2547: 74 02          :  mov A,#2
co:2549: 2d             :  add A,R5
co:254a: fb             :  mov R3,A
co:254b: e4             :  clr A
co:254c: 3c             :  addc A,R4
co:254d: fa             :  mov R2,A
co:254e: 7c 78          :  mov R4,#120
co:2550: 7d 00          :  mov R5,#0
co:2552: 8a 83          :  mov DPH,R2
co:2554: 8b 82          :  mov DPL,R3
co:2556: 12 04 eb       :  lcall __st_dptr_r45
                        :>  tx_bd->addr = TX_BD_BASE;
co:2559: 7c d4          :  mov R4,#212
co:255b: 7d 00          :  mov R5,#0
co:255d: 74 04          :  mov A,#4
co:255f: 2d             :  add A,R5
co:2560: fd             :  mov R5,A
co:2561: e4             :  clr A
co:2562: 3c             :  addc A,R4
co:2563: fc             :  mov R4,A
co:2564: e4             :  clr A
co:2565: f8             :  mov R0,A
co:2566: f9             :  mov R1,A
co:2567: 7a 18          :  mov R2,#24
co:2569: 7b 00          :  mov R3,#0
co:256b: 8c 83          :  mov DPH,R4
co:256d: 8d 82          :  mov DPL,R5
co:256f: 12 0a b5       :  lcall __st_dptr_r03
                        :>  pTxPtr=(volatile xdata unsigned long*)(TX_BD_BASE|(ETH_BUFFER_BASE));
co:2572: 75 40 f8       :  mov _pTxPtr,#248
co:2575: 75 41 00       :  mov _pTxPtr+1,#0
co:2578: 22             :  ret
                        : ; end of function RequestSend_Phy
                        : ; used: R01234567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _CommitSend_Phy ; void CommitSend_Phy(void)
                        :  .segment _CommitSend_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _CommitSend_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _CommitSend_Phy_formal_near, _CommitSend_Phy_local_near, __CommitSend_Phy
                        : 
                        :  .segment __CommitSend_Phy
                        : _CommitSend_Phy: ; (leaf function) void CommitSend_Phy(void)
                        :>  
                        :>}
                        :>
                        :>void CommitSend_Phy() {
co:2202: 7e d4          :  mov R6,#212
co:2204: 7f 00          :  mov R7,#0
co:2206: 74 02          :  mov A,#2
co:2208: 2f             :  add A,R7
co:2209: ff             :  mov R7,A
co:220a: e4             :  clr A
co:220b: 3e             :  addc A,R6
co:220c: fe             :  mov R6,A
co:220d: 8e 08          :  mov AR8,R6
co:220f: 8f 09          :  mov AR9,R7
co:2211: 8e 83          :  mov DPH,R6
co:2213: 8f 82          :  mov DPL,R7
co:2215: 12 0a af       :  lcall __ld_dptr_r67
co:2218: ef             :  mov A,R7
co:2219: fd             :  mov R5,A
co:221a: ee             :  mov A,R6
co:221b: 44 c8          :  orl A,#200
co:221d: fc             :  mov R4,A
co:221e: ae 08          :  mov R6,AR8
co:2220: af 09          :  mov R7,AR9
co:2222: 8e 83          :  mov DPH,R6
co:2224: 8f 82          :  mov DPL,R7
co:2226: 12 04 eb       :  lcall __st_dptr_r45
co:2229: 22             :  ret
                        : ; end of function CommitSend_Phy
                        : ; used: R----4567 BR01------ DPTR ACC PSW
                        : 
                        :  .export _Read_Frame_word_Phy ; unsigned int Read_Frame_word_Phy(void)
                        :  .segment _Read_Frame_word_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Read_Frame_word_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Read_Frame_word_Phy_formal_near, _Read_Frame_word_Phy_local_near, __Read_Frame_word_Phy
                        : 
                        :  .segment __Read_Frame_word_Phy
                        : _Read_Frame_word_Phy: ; (leaf function) unsigned int Read_Frame_word_Phy(void)
                        :>  volatile oeth_bd xdata *tx_bd= OETH_BD_BASE;
                        :>  tx_bd->u.ls.status |= (OETH_TX_BD_READY | OETH_TX_BD_IRQ | OETH_TX_BD_CRC);
                        :>}
                        :>
                        :>unsigned int Read_Frame_word_Phy(void) {
co:21bd: ae 3b          :  mov R6,_pRxPtr
co:21bf: af 3c          :  mov R7,_pRxPtr+1
co:21c1: 8e 83          :  mov DPH,R6
co:21c3: 8f 82          :  mov DPL,R7
co:21c5: 12 0a af       :  lcall __ld_dptr_r67
                        :  ; variable 'tmp' assigned to register 'RW67'
                        :>  unsigned int tmp= *((xdata unsigned int*)pRxPtr);
                        :>  pRxPtr+=2;
co:21c8: 74 02          :  mov A,#2
co:21ca: 25 3c          :  add A,_pRxPtr+1
co:21cc: f5 3c          :  mov _pRxPtr+1,A
co:21ce: e4             :  clr A
co:21cf: 35 3b          :  addc A,_pRxPtr
co:21d1: f5 3b          :  mov _pRxPtr,A
co:21d3: 22             :  ret
                        : ; end of function Read_Frame_word_Phy
                        : ; used: R------67 BR-------- DPTR ACC PSW
                        : 
                        :  .export _Read_Frame_long_Phy ; unsigned long Read_Frame_long_Phy(void)
                        :  .segment _Read_Frame_long_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Read_Frame_long_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Read_Frame_long_Phy_formal_near, _Read_Frame_long_Phy_local_near, __Read_Frame_long_Phy
                        : 
                        :  .segment __Read_Frame_long_Phy
                        : _Read_Frame_long_Phy: ; (leaf function) unsigned long Read_Frame_long_Phy(void)
                        :>  return tmp;
                        :>}
                        :>    
                        :>unsigned long Read_Frame_long_Phy(void) {
co:2142: ae 3b          :  mov R6,_pRxPtr
co:2144: af 3c          :  mov R7,_pRxPtr+1
co:2146: 8e 83          :  mov DPH,R6
co:2148: 8f 82          :  mov DPL,R7
co:214a: 12 01 71       :  lcall __ld_dptr_r47
                        :  ; variable 'tmp' assigned to register 'RL4567'
                        :>  unsigned long tmp= *((xdata unsigned long*)pRxPtr);
                        :>  pRxPtr+=4;
co:214d: 74 04          :  mov A,#4
co:214f: 25 3c          :  add A,_pRxPtr+1
co:2151: f5 3c          :  mov _pRxPtr+1,A
co:2153: e4             :  clr A
co:2154: 35 3b          :  addc A,_pRxPtr
co:2156: f5 3b          :  mov _pRxPtr,A
co:2158: 22             :  ret
                        : ; end of function Read_Frame_long_Phy
                        : ; used: R----4567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _Read_Frame_xdata_Phy ; void Read_Frame_xdata_Phy(xdata unsigned char *, unsigned int)
                        :  .segment _Read_Frame_xdata_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Read_Frame_xdata_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Read_Frame_xdata_Phy_formal_near, _Read_Frame_xdata_Phy_local_near, __Read_Frame_xdata_Phy
                        : 
                        :  .segment __Read_Frame_xdata_Phy
                        : _Read_Frame_xdata_Phy: ; (leaf function) void Read_Frame_xdata_Phy(xdata unsigned char *, unsigned int
                        :  ; parameter 'ps' in 'RW67' assigned to 'RW45'
                        :  ; parameter 'len' in 'RW45' assigned to 'RW01'
co:265c: a8 04          :  mov R0,AR4
co:265e: a9 05          :  mov R1,AR5
co:2660: ac 06          :  mov R4,AR6
co:2662: ad 07          :  mov R5,AR7
                        :>  return tmp;
                        :>}   
                        :>
                        :>void Read_Frame_xdata_Phy(xdata uchar*ps, uint len) {
co:2664: 80 2e          :  sjmp ?35
                        : ?34:
                        :>  while(len--) {
co:2666: 8c 08          :  mov AR8,R4
co:2668: 8d 09          :  mov AR9,R5
co:266a: aa 08          :  mov R2,AR8
co:266c: ab 09          :  mov R3,AR9
co:266e: 74 01          :  mov A,#1
co:2670: 2b             :  add A,R3
co:2671: fd             :  mov R5,A
co:2672: e4             :  clr A
co:2673: 3a             :  addc A,R2
co:2674: fc             :  mov R4,A
co:2675: ae 3b          :  mov R6,_pRxPtr
co:2677: af 3c          :  mov R7,_pRxPtr+1
co:2679: 74 01          :  mov A,#1
co:267b: 2f             :  add A,R7
co:267c: fb             :  mov R3,A
co:267d: e4             :  clr A
co:267e: 3e             :  addc A,R6
co:267f: fa             :  mov R2,A
co:2680: 8a 3b          :  mov _pRxPtr,R2
co:2682: 8b 3c          :  mov _pRxPtr+1,R3
co:2684: 85 06 83       :  mov DPH,AR6
co:2687: 85 07 82       :  mov DPL,AR7
co:268a: e0             :  movx A,@DPTR
co:268b: fb             :  mov R3,A
co:268c: 85 08 83       :  mov DPH,AR8
co:268f: 85 09 82       :  mov DPL,AR9
co:2692: eb             :  mov A,R3
co:2693: f0             :  movx @DPTR,A
                        :>    *ps++=*pRxPtr++;
                        :>  } 
                        : ?35:
                        : 
co:2694: ae 00          :  mov R6,AR0
co:2696: af 01          :  mov R7,AR1
co:2698: 74 ff          :  mov A,#255
co:269a: 2f             :  add A,R7
co:269b: f9             :  mov R1,A
co:269c: 74 ff          :  mov A,#255
co:269e: 3e             :  addc A,R6
co:269f: f8             :  mov R0,A
co:26a0: ee             :  mov A,R6
co:26a1: 4f             :  orl A,R7
co:26a2: 70 c2          :  jnz ?34
co:26a4: 22             :  ret
                        : ; end of function Read_Frame_xdata_Phy
                        : ; used: R01234567 BR01------ DPTR ACC PSW
                        : 
                        :  .export _Write_Frame_word_Phy ; void Write_Frame_word_Phy(unsigned int)
                        :  .segment _Write_Frame_word_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Write_Frame_word_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Write_Frame_word_Phy_formal_near, _Write_Frame_word_Phy_local_near, __Write_Frame_word_Phy
                        : 
                        :  .segment __Write_Frame_word_Phy
                        : _Write_Frame_word_Phy: ; (leaf function) void Write_Frame_word_Phy(unsigned int)
                        :  ; parameter 'Data' in 'RW67'
                        :>}
                        :>
                        :>
                        :>void Write_Frame_word_Phy(uint Data) {
co:21eb: ac 40          :  mov R4,_pTxPtr
co:21ed: ad 41          :  mov R5,_pTxPtr+1
co:21ef: 8c 83          :  mov DPH,R4
co:21f1: 8d 82          :  mov DPL,R5
co:21f3: 12 0a c1       :  lcall __st_dptr_r67
                        :>  (*((xdata unsigned int*)pTxPtr)=Data); 
                        :>  pTxPtr+=2;
co:21f6: 74 02          :  mov A,#2
co:21f8: 25 41          :  add A,_pTxPtr+1
co:21fa: f5 41          :  mov _pTxPtr+1,A
co:21fc: e4             :  clr A
co:21fd: 35 40          :  addc A,_pTxPtr
co:21ff: f5 40          :  mov _pTxPtr,A
co:2201: 22             :  ret
                        : ; end of function Write_Frame_word_Phy
                        : ; used: R----4567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _Write_Frame_long_Phy ; void Write_Frame_long_Phy(unsigned long)
                        :  .segment _Write_Frame_long_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Write_Frame_long_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Write_Frame_long_Phy_formal_near, _Write_Frame_long_Phy_local_near, __Write_Frame_long_Phy
                        : 
                        :  .segment __Write_Frame_long_Phy
                        : _Write_Frame_long_Phy: ; (leaf function) void Write_Frame_long_Phy(unsigned long)
                        :  ; parameter 'Data' in 'RL4567'
                        :>}
                        :>
                        :>void Write_Frame_long_Phy(unsigned long Data){
co:21d4: aa 40          :  mov R2,_pTxPtr
co:21d6: ab 41          :  mov R3,_pTxPtr+1
co:21d8: 8a 83          :  mov DPH,R2
co:21da: 8b 82          :  mov DPL,R3
co:21dc: 12 04 f1       :  lcall __st_dptr_r47
                        :>  (*((xdata unsigned long*)pTxPtr)=Data);
                        :>  pTxPtr+=4;
co:21df: 74 04          :  mov A,#4
co:21e1: 25 41          :  add A,_pTxPtr+1
co:21e3: f5 41          :  mov _pTxPtr+1,A
co:21e5: e4             :  clr A
co:21e6: 35 40          :  addc A,_pTxPtr
co:21e8: f5 40          :  mov _pTxPtr,A
co:21ea: 22             :  ret
                        : ; end of function Write_Frame_long_Phy
                        : ; used: R--234567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _Write_Frame_xdata_Phy ; void Write_Frame_xdata_Phy(xdata unsigned char *, unsigned int)
                        :  .segment _Write_Frame_xdata_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Write_Frame_xdata_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Write_Frame_xdata_Phy_formal_near, _Write_Frame_xdata_Phy_local_near, __Write_Frame_xdata_Ph
                        : 
                        :  .segment __Write_Frame_xdata_Phy
                        : _Write_Frame_xdata_Phy: ; (leaf function) void Write_Frame_xdata_Phy(xdata unsigned char *, unsigned i
                        :  ; parameter 'ps' in 'RW67' assigned to 'RW45'
                        :  ; parameter 'len' in 'RW45' assigned to 'RW01'
co:2724: a8 04          :  mov R0,AR4
co:2726: a9 05          :  mov R1,AR5
co:2728: ac 06          :  mov R4,AR6
co:272a: ad 07          :  mov R5,AR7
                        :>}
                        :>
                        :>void Write_Frame_xdata_Phy(xdata uchar* ps, uint len) {
co:272c: 80 2c          :  sjmp ?41
                        : ?40:
                        :>  while(len--) {
co:272e: 85 40 08       :  mov AR8,_pTxPtr
co:2731: 85 41 09       :  mov AR9,_pTxPtr+1
co:2734: 74 01          :  mov A,#1
co:2736: 25 09          :  add A,AR9
co:2738: f5 41          :  mov _pTxPtr+1,A
co:273a: e4             :  clr A
co:273b: 35 08          :  addc A,AR8
co:273d: f5 40          :  mov _pTxPtr,A
co:273f: ae 04          :  mov R6,AR4
co:2741: af 05          :  mov R7,AR5
co:2743: 74 01          :  mov A,#1
co:2745: 2f             :  add A,R7
co:2746: fd             :  mov R5,A
co:2747: e4             :  clr A
co:2748: 3e             :  addc A,R6
co:2749: fc             :  mov R4,A
co:274a: 85 06 83       :  mov DPH,AR6
co:274d: 85 07 82       :  mov DPL,AR7
co:2750: e0             :  movx A,@DPTR
co:2751: fb             :  mov R3,A
co:2752: 85 08 83       :  mov DPH,AR8
co:2755: 85 09 82       :  mov DPL,AR9
co:2758: eb             :  mov A,R3
co:2759: f0             :  movx @DPTR,A
                        :>    *pTxPtr++=*ps++;
                        :>  } 
                        : ?41:
                        : 
co:275a: ae 00          :  mov R6,AR0
co:275c: af 01          :  mov R7,AR1
co:275e: 74 ff          :  mov A,#255
co:2760: 2f             :  add A,R7
co:2761: f9             :  mov R1,A
co:2762: 74 ff          :  mov A,#255
co:2764: 3e             :  addc A,R6
co:2765: f8             :  mov R0,A
co:2766: ee             :  mov A,R6
co:2767: 4f             :  orl A,R7
co:2768: 70 c4          :  jnz ?40
co:276a: 22             :  ret
                        : ; end of function Write_Frame_xdata_Phy
                        : ; used: R01234567 BR01------ DPTR ACC PSW
                        : 
                        :  .import _rx_bd ; xdata oeth_bd *near rx_bd
                        :  .segment nearbss, sclass dram, notext
                        :  .export _pRxPtr ; xdata unsigned char *near pRxPtr
                        : _pRxPtr: ; xdata unsigned char *near pRxPtr
dr:003b: xx xx          :  .ds.b 2
                        :  .import _my_mac ; xdata unsigned char my_mac[6]
                        :  .end
                        :>}
                        :>
                        :>// END
                        :>
                        :>
=             _Init_Mac =  2281 (hex),   8833 (dez), text
=      _RequestSend_Phy =  253d (hex),   9533 (dez), text
=              _init_rx =  24af (hex),   9391 (dez), text
=  _Read_Frame_long_Phy =  2142 (hex),   8514 (dez), text
=  _Read_Frame_word_Phy =  21bd (hex),   8637 (dez), text
=               _pTxPtr =    40 (hex),     64 (dez), dram
=       _find_RX_Buffer =  261c (hex),   9756 (dez), text
=               _pRxPtr =    3b (hex),     59 (dez), dram
=  _Write_Frame_long_Ph =  21d4 (hex),   8660 (dez), text
=  _Write_Frame_word_Ph =  21eb (hex),   8683 (dez), text
=       _CommitSend_Phy =  2202 (hex),   8706 (dez), text
=  _Write_Frame_xdata_P =  2724 (hex),  10020 (dez), text
=  _Read_Frame_xdata_Ph =  265c (hex),   9820 (dez), text
=          _set_mac_add =  24e5 (hex),   9445 (dez), text

objectfile:tcpip\net.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'tcpip\net.c', time: Wed Dec 13 13:00:40 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :         .include <reg52.def>
                        : ; **** 80C52 (extended) defs ***
                        : 
                        :         .hide
                        :         .show
                        : .macro _irq_vector
                        :         .show
                        :         .segment @1, org @2
                        :         ljmp @3
                        :         .hide
                        : .endmacro
                        :         P0    = $80
                        :         sevseg_ctrl  = $C0;
                        :   sevseg_data0 = $C1;
                        :   sevseg_data1 = $C2;
                        :   sevseg_data2 = $C3;
                        :   sevseg_data3 = $C4;
                        :   sevseg_en    = $C5;
                        :   _sevseg_ctrl  = sevseg_ctrl;
                        :   _sevseg_data0 = sevseg_data0;
                        :   _sevseg_data1 = sevseg_data1;
                        :   _sevseg_data2 = sevseg_data2;
                        :   _sevseg_data3 = sevseg_data3;
                        :   _sevseg_en    = sevseg_en;
                        : 
                        :  .segment data, sclass xram
                        :  .export _my_mac ; xdata unsigned char my_mac[6]
                        : _my_mac: ; xdata unsigned char my_mac[6]
xr:0000: 00 06          :  .dc.b 0,6
xr:0002: 98 01          :  .dc.b 152,1
xr:0004: 00 00          :  .dc.b 0,0
                        :  .export _tx_bufleft ; xdata unsigned char tx_bufleft
                        : _tx_bufleft: ; xdata unsigned char tx_bufleft
xr:0006: 04             :  .dc.b 4
                        :  .export _allocate_tx_buf ; xdata unsigned char *allocate_tx_buf(void)
                        :  .segment _allocate_tx_buf_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _allocate_tx_buf_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _allocate_tx_buf_formal_near, _allocate_tx_buf_local_near, __allocate_tx_buf
                        : 
                        :  .segment __allocate_tx_buf
                        : _allocate_tx_buf: ; (leaf function) xdata unsigned char *allocate_tx_buf(void)
                        :>/*********************************************************************************
                        :>* NET.C
                        :>* 
                        :>* IP/ICMP/ARP/TCP/UDP packet handler 
                        :>*
                        :>* V3.01 (C) 2004-2005 WWW.WICKENHAEUSER.DE
                        :>*
                        :>* Please support us:
                        :>* ==================
                        :>* 
                        :>* We offer the uC/51-ANSI-C-Compiler at a very low price. So we do not have a
                        :>* large budget for advertisements. Every link to our Internet pages
                        :>* (WWW.WICKENHAEUSER.COM, WWW.WICKENHAEUSER.DE, WWW.FLEXGATE.COM, WWW.FLEXGATE.DE)
                        :>* is welcome! 
                        :>*
                        :>**********************************************************************************/
                        :>
                        :>#include <stdio.h>
                        :>#include <string.h> 
                        :>
                        :>#include <reg52.h>
                        :>
                        :>#include <irq52.h>
                        :>
                        :>#include "net.h"  // Basic network handling (public)
                        :>#include "phy.h"  // Physical Network access
                        :>#include "open_ether.h"
                        :>#include "netutil.h"  // Toolbox
                        :>
                        :>/**********************************************************************************
                        :>* Private structs
                        :>**********************************************************************************/
                        :>typedef struct{
                        :> uint vhl_service; // 0x45xx-0x4Fxx
                        :> uint len;  
                        :> uint ident;
                        :> uint frags;
                        :> uchar ttl;
                        :> uchar pcol;
                        :> uint checksum;
                        :> IP_ADR sip;
                        :> IP_ADR dip;
                        :>} IP_HDR;
                        :>
                        :>/**********************************************************************************
                        :>* Private Definitions (not in net.h)
                        :>**********************************************************************************/
                        :>
                        :>/************ TCP Soecket states *************************/
                        :>//#define TCP_CLOSED  0 // 0 for all: Socket closed (and listen)
                        :>
                        :>// ** Initial Server States
                        :>#define TCP_SYNCON  1   // Confirmed an incomming SYN
                        :>//#define TCP_EST  2    // Established, Connection OK
                        :>
                        :>// ** Closing
                        :>#define TCP_FINSENT  3    // A FIN was sent. Wait for Acknowledge+FIN
                        :>#define TCP_FINCON 4    // Confirmed a FIN with FIN+ACK, waiting for last ACK
                        :>
                        :>// ** Client States
                        :>#ifdef USE_TCP_CLIENT
                        :> #define TCP_SYNSENT  5   // Arp was Ok, send SYN now
                        :>#endif
                        :>
                        :>/************ UDP Socket states *************************/
                        :>
                        :>// #define UDP_EST ARPREC
                        :>
                        :>/* TCP-Option-Flags */
                        :>#define TFIN 0x01
                        :>#define TSYN 0x02
                        :>#define TRST 0x04
                        :>#define TPUSH 0x08
                        :>#define TACK 0x10
                        :>#define TURGE 0x20  // Flag ignored
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* OPTION DEFS: see net.h
                        :>**********************************************************************************/
                        :>
                        :>/**********************************************************************************
                        :>* MAC-Level data
                        :>*
                        :>* Set a (default) MAC for THIS node
                        :>**********************************************************************************/
                        :>#ifdef PHY_ETH
                        :>MAC my_mac={0x00,0x06,0x98,0x01,0x00,0x00}; // MAC for this machine: M0:M1:M2:M3:M4:M5
                        :>MAC remote_mac;  // used as temp.
                        :> #if defined(USE_TCP_CLIENT) || defined(USE_UDP_CLIENT)
                        :>  MAC gateway_mac; // optional Gateway for active oen of an "ouside" peer
                        :> #endif
                        :>#endif
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* IP-Header-Level data
                        :>*
                        :>* Set a IP for THIS node
                        :>**********************************************************************************/
                        :>IP_ADR  my_ip;    // IP for this machine (public)
                        :>IP_ADR remote_ip;   // Last read IP
                        :>
                        :>#if defined(USE_TCP_CLIENT) || defined(USE_UDP_CLIENT)
                        :>IP_ADR subnet_ip;   // These two IPs require Setup!
                        :>IP_ADR gateway_ip;
                        :>#endif
                        :>
                        :>IP_HDR hhdr;    // Temporary header for sending IP-data
                        :>
                        :>/**********************************************************************************
                        :>* ICMP/ARP-Level data
                        :>*
                        :>* ICMP is designed for Standard WIN-pings with 0-32 bytes. Enlarge structs if req.
                        :>**********************************************************************************/
                        :>
                        :>
                        :>typedef struct{ // Definition
                        :>  IP_ADR sip;
                        :>  IP_ADR dip;
                        :>  uint pcol; // 6 for TCP, 17 for UDP 
                        :>  uint len;
                        :>} PSEUDO_HDR;
                        :>
                        :>PSEUDO_HDR pseudo_hdr;  // Used for TCP/IP-Checksums
                        :>
                        :>#ifdef USE_MSS
                        :> #if MAX_TX < 576
                        :>  #error Maximum Segment Size (MSS, = MAX_TX) too small, must be >=576!
                        :> #endif
                        :>#endif
                        :>
                        :>
                        :>#ifdef PHY_ETH
                        :>// Same variables for initial examination of incomming frames
                        :>typedef struct{ // Size: 20 Bytes
                        :> MAC sender_mac;
                        :> IP_ADR sender_ip;
                        :> MAC target_mac; 
                        :> IP_ADR target_ip;
                        :>} ARP_INFO; // The informative Part of an ARP message...
                        :>#endif
                        :>
                        :>typedef struct{ // Size: 40 Bytes
                        :> uchar type;
                        :> uchar icmp_code;
                        :> uint checksum;
                        :> uint ident; // Commonly unused
                        :> uint sequ; // dto.
                        :>#ifdef SHORT_PING
                        :> uchar data[12]; // Save to clip PING DATA for preserve RAM, so PING fits in 20 Bytes...
                        :>#else
                        :> uchar data[32]; // large enough for a standard WINDOWS ping...
                        :>#endif
                        :>} PING_INFO;  // A frame for a standard PING
                        :>
                        :>typedef struct{ // Size: 20 Bytes
                        :> uint sport; // Source port
                        :> uint dport; // Destination port
                        :>
                        :> WORD2_LONG seq; // Sequence ('my pointer');
                        :> WORD2_LONG ack; // Acknowledge ('your pointer')
                        :>
                        :> uchar hlen; // TCP header len <<2 (==80 without Options)
                        :> uchar flags; // option Flags TFIN-TURGE
                        :>
                        :> uint window; // window size
                        :> uint checksum; // 
                        :> uint urgent; // urgend pointer (commonly unused)
                        :>#ifdef USE_MSS
                        :> unsigned long mss;     // 4 Bytes 2 4 MAX_RX.16
                        :>#endif
                        :>} TCP_HDR;
                        :>
                        :>#ifdef USE_UDP
                        :>typedef struct{ // Size: 8 Bytes (Struct. Currently not used)
                        :> uint sport; // Source port
                        :> uint dport; // Destination port
                        :>
                        :> uint mlen; // MessageLen
                        :> uint checksum; // 
                        :>} UDP_HDR;
                        :>#endif
                        :>
                        :>#ifdef SHORT_PING
                        :> #ifdef USE_MSS
                        :>        #define HFRAME_SIZE 24 // For short Pings... (extended by 4 Bytes MSS)
                        :> #else
                        :>        #define HFRAME_SIZE 20 // For short Pings...
                        :> #endif
                        :>#else
                        :> #define HFRAME_SIZE 40 // Large enough for the biggest header
                        :>#endif
                        :>
                        :>typedef union{
                        :>#ifdef PHY_ETH
                        :> ARP_INFO  arp_info; // 2.nd Level      // Size: 20 Bytes
                        :>#endif
                        :> PING_INFO ping_info; // 2.nd Level     // Default Size: 40 Bytes (save to clip to 8, if PING_DATA cli
                        :> TCP_HDR  tcp_hdr; // 3.rd Level, remote IP in remote_ip, rest of IP_HDR known. 20 Bytes Standard
                        :>#ifdef USE_UDP
                        :> UDP_HDR  udp_hdr; // 3.rd Level        // Size: 8 Bytes
                        :>#endif
                        :> uchar bytes[HFRAME_SIZE]; // Bytes of "generic" access
                        :>} HFRAME;
                        :>
                        :>// A Frame for temporary usage 2.nd and 3.rd level
                        :>HFRAME hframe;
                        :>
                        :>/**********************************************************************************
                        :>* The timer, counts down with about 2 Hz
                        :>**********************************************************************************/
                        :>uchar near net_timer; // Temporary value, counts down until by an IRQ
                        :>uchar near net_service_cnt; // Additional Timer, counts up. twice /sec.
                        :>
                        :>/**********************************************************************************
                        :>* The 'official' buffers in XRAM
                        :>**********************************************************************************/
                        :>
                        :>// RX-Buffer (1)
                        :>#ifdef PHY_ETH
                        :>        uchar rcv_buf[MAX_RX];   // Physical Buffer for receiving data (Mainly HTTP-Header...)
                        :>#else
                        :>        xdata uchar* rcv_buf;   // [MAX_RX]Pointer to Buffer for receiving data (Mainly HTTP-Header...
                        :>#endif
                        :>
                        :>uint rcv_len;    // Size of received data (int)
                        :>
                        :>// TX-Buffers (x)
                        :>uchar tx_buffers[TX_BUFFERS][MAX_TX+1];
                        :>uchar tx_bufleft=TX_BUFFERS; // Counts left buffers
                        :>
                        :>/**********************************************************************************
                        :>* This uC/51 is designed to support a maximum of >8 simultaneous open sockets
                        :>*
                        :>* ** Only implemented as a fragment until now!
                        :>* ** later there will be a bit-mask holding the 'active' sockets
                        :>* ** ** Later socket types: SOCKET_NONE(==0), UDP(port), TCP(port), HTTP, TELNET, ...
                        :>*
                        :>**********************************************************************************/
                        :>
                        :>UC_SOCKET match_socket;  // Temporary matching socket (Work-pad!)
                        :>
                        :>// *** THE SOCKETS ***
                        :>UC_SOCKET uc_socket[MAX_SOCK];  // My (User's) Sockets!
                        :>
                        :>
                        :>
                        :>#ifdef DEBUG_REC
                        :>/**********************************************************************************
                        :>* Debugging Stuff: Records sent and receiced frames
                        :>**********************************************************************************/
                        :>
                        :>uint rec_no;
                        :>typedef struct{
                        :>    uchar typ;  // 'R': Received, 'T' Transmitted, 't' Retransmitted, ...
                        :>    uint port;
                        :>    unsigned long seq;
                        :>    unsigned long ack;
                        :>    uchar flags;
                        :>    uint len;
                        :>} REC_FRAME;
                        :>
                        :>REC_FRAME rec_frame[MAX_REC_FRAME];
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* record_frame: Record 1 Frame
                        :>**********************************************************************************/
                        :>void record_frame(uchar typ, uint port, unsigned long seq, unsigned long ack, uchar flags, uint len){
                        :>    xdata REC_FRAME *pr;
                        :>    if(rec_no==MAX_REC_FRAME) return;   // FULL!
                        :>    pr=rec_frame+rec_no;
                        :>    pr->typ=typ;
                        :>    pr->port=port;
                        :>    pr->seq=seq;
                        :>    pr->ack=ack;
                        :>    pr->flags=flags;
                        :>    pr->len=len;
                        :>    rec_no++;   
                        :>}
                        :>/**********************************************************************************
                        :>* Show Frame, return 1  if data available
                        :>**********************************************************************************/
                        :>uchar show_frame(uint no){
                        :>    uchar flags;
                        :>    xdata REC_FRAME *pr;
                        :>    if(no>=rec_no) return 0;
                        :>    pr=rec_frame+no;
                        :>    printf("No:%u '%c' P:%u  S:%lu    A:%lu    ",no+1, pr->typ, pr->port,  pr->seq, pr->ack);
                        :>    flags=pr->flags;
                        :>    if(flags & TFIN) printf("FIN ");
                        :>    if(flags & TSYN) printf("SYN ");
                        :>    if(flags & TRST) printf("RST ");
                        :>    if(flags & TACK) printf("ACK ");
                        :>
                        :>    printf("   L:%u\n",pr->len);
                        :>    return 1;   // OK!
                        :>}
                        :>
                        :>
                        :>
                        :>#endif
                        :>
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* xdata uchar* allocate_tx_buf(void);
                        :>*
                        :>* Find a free buffer, if one found, allocate it and return startadress,
                        :>* return 0 if none available!
                        :>**********************************************************************************/
                        :>xdata uchar* allocate_tx_buf(void){
co:2c6f: 7c 00          :  mov R4,#((_tx_buffers)>>8)&255
co:2c71: 7d 3a          :  mov R5,#(_tx_buffers)&255
                        :  ; variable 'pbuf' assigned to register 'RW45'
                        :> uchar ui;
                        :> xdata uchar *pbuf=&tx_buffers[0][0];
                        :>
                        :> if(tx_bufleft) for(ui=0;ui<TX_BUFFERS;ui++,pbuf+=(MAX_TX+1)){
co:2c73: 90 00 06       :  mov DPTR,#_tx_bufleft
co:2c76: e0             :  movx A,@DPTR
co:2c77: ff             :  mov R7,A
co:2c78: 60 38          :  jz ?15
                        : 
co:2c7a: e4             :  clr A
co:2c7b: fb             :  mov R3,A
                        :  ; variable 'ui' assigned to register 'R3'
                        : ?17:
                        : 
co:2c7c: 85 04 83       :  mov DPH,AR4
co:2c7f: 85 05 82       :  mov DPL,AR5
co:2c82: e0             :  movx A,@DPTR
co:2c83: ff             :  mov R7,A
co:2c84: 70 1d          :  jnz ?21
                        :>  if(!(*pbuf)) {
co:2c86: 85 04 83       :  mov DPH,AR4
co:2c89: 85 05 82       :  mov DPL,AR5
co:2c8c: 74 01          :  mov A,#1
co:2c8e: f0             :  movx @DPTR,A
                        :>   *pbuf=1; // Mark Buffer as allocated
                        :>   tx_bufleft--;
co:2c8f: 90 00 06       :  mov DPTR,#_tx_bufleft
co:2c92: e0             :  movx A,@DPTR
co:2c93: ff             :  mov R7,A
co:2c94: 1f             :  dec R7
co:2c95: 90 00 06       :  mov DPTR,#_tx_bufleft
co:2c98: ef             :  mov A,R7
co:2c99: f0             :  movx @DPTR,A
                        :>   return pbuf+1; // Return Startadress of buffer
co:2c9a: 74 01          :  mov A,#1
co:2c9c: 2d             :  add A,R5
co:2c9d: ff             :  mov R7,A
co:2c9e: e4             :  clr A
co:2c9f: 3c             :  addc A,R4
co:2ca0: fe             :  mov R6,A
co:2ca1: 80 12          :  sjmp ?14
                        : ?21:
                        :>  }
                        :> }
co:2ca3: 0b             :  inc R3
co:2ca4: 74 65          :  mov A,#101
co:2ca6: 2d             :  add A,R5
co:2ca7: fd             :  mov R5,A
co:2ca8: e4             :  clr A
co:2ca9: 3c             :  addc A,R4
co:2caa: fc             :  mov R4,A
                        : 
co:2cab: 7f 04          :  mov R7,#4
co:2cad: c3             :  clr C
co:2cae: eb             :  mov A,R3
co:2caf: 9f             :  subb A,R7
co:2cb0: 40 ca          :  jc ?17
                        : ?15:
                        :> return 0; // Nothing found!
co:2cb2: e4             :  clr A
co:2cb3: fe             :  mov R6,A
co:2cb4: ff             :  mov R7,A
                        : ?14:
co:2cb5: 22             :  ret
                        : ; end of function allocate_tx_buf
                        : ; used: R---34567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _free_tx_buf ; void free_tx_buf(xdata unsigned char *)
                        :  .segment _free_tx_buf_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _free_tx_buf_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _free_tx_buf_formal_near, _free_tx_buf_local_near, __free_tx_buf
                        : 
                        :  .segment __free_tx_buf
                        : _free_tx_buf: ; (leaf function) void free_tx_buf(xdata unsigned char *)
                        :  ; parameter 'pbuf' in 'RW67'
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* void free_tx_buf(xdata uchar* pbuf)
                        :>*
                        :>* Free TX-Buffer if not more required
                        :>**********************************************************************************/
                        :>
                        :>void free_tx_buf(xdata uchar* pbuf){
co:2cd6: ef             :  mov A,R7
co:2cd7: 1f             :  dec R7
co:2cd8: 70 01          :  jnz ?__1
co:2cda: 1e             :  dec R6
                        : ?__1:
                        :  ; variable 'pbuf' assigned to register 'RW67'
                        :> pbuf--;   // Pointer to Pos 0(Flag)
                        :> if(*pbuf){
co:2cdb: 85 06 83       :  mov DPH,AR6
co:2cde: 85 07 82       :  mov DPL,AR7
co:2ce1: e0             :  movx A,@DPTR
co:2ce2: fd             :  mov R5,A
co:2ce3: 60 13          :  jz ?24
                        : 
co:2ce5: 85 06 83       :  mov DPH,AR6
co:2ce8: 85 07 82       :  mov DPL,AR7
co:2ceb: e4             :  clr A
co:2cec: f0             :  movx @DPTR,A
                        :>  *pbuf=0; // Buffer now free again... 
                        :>  tx_bufleft++; // One more Buffer free...
co:2ced: 90 00 06       :  mov DPTR,#_tx_bufleft
co:2cf0: e0             :  movx A,@DPTR
co:2cf1: fd             :  mov R5,A
co:2cf2: 0d             :  inc R5
co:2cf3: 90 00 06       :  mov DPTR,#_tx_bufleft
co:2cf6: ed             :  mov A,R5
co:2cf7: f0             :  movx @DPTR,A
                        :> }
                        : ?24:
co:2cf8: 22             :  ret
                        : ; end of function free_tx_buf
                        : ; used: R----4567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _free_match_socket ; void free_match_socket(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __free_match_socket
                        : _free_match_socket: ; void free_match_socket(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* void free_match_socket(void);
                        :>*
                        :>* Function for state transition to TCP_CLOSED for a socket, ensures freeing of the
                        :>* buffers!
                        :>**********************************************************************************/
                        :>void free_match_socket(void){
co:2c20: 90 00 32       :  mov DPTR,#_match_socket+42
co:2c23: 12 0a af       :  lcall __ld_dptr_r67
co:2c26: ee             :  mov A,R6
co:2c27: 4f             :  orl A,R7
co:2c28: 60 10          :  jz ?28
                        :> if(match_socket.buf_outsize1){
co:2c2a: 90 00 32       :  mov DPTR,#_match_socket+42
co:2c2d: e4             :  clr A
co:2c2e: f0             :  movx @DPTR,A
co:2c2f: a3             :  inc DPTR
co:2c30: f0             :  movx @DPTR,A
                        :>  match_socket.buf_outsize1=0;
                        :>  free_tx_buf(match_socket.p_outbuf1);   
co:2c31: 90 00 38       :  mov DPTR,#_match_socket+48
co:2c34: 12 0a af       :  lcall __ld_dptr_r67
co:2c37: 12 2c d6       :  lcall _free_tx_buf
                        :> }
                        : ?28:
                        :> if(match_socket.buf_outsize2){
co:2c3a: 90 00 2a       :  mov DPTR,#_match_socket+34
co:2c3d: 12 0a af       :  lcall __ld_dptr_r67
co:2c40: ee             :  mov A,R6
co:2c41: 4f             :  orl A,R7
co:2c42: 60 10          :  jz ?30
                        : 
co:2c44: 90 00 2a       :  mov DPTR,#_match_socket+34
co:2c47: e4             :  clr A
co:2c48: f0             :  movx @DPTR,A
co:2c49: a3             :  inc DPTR
co:2c4a: f0             :  movx @DPTR,A
                        :>  match_socket.buf_outsize2=0;
                        :>  free_tx_buf(match_socket.p_outbuf2);   
co:2c4b: 90 00 30       :  mov DPTR,#_match_socket+40
co:2c4e: 12 0a af       :  lcall __ld_dptr_r67
co:2c51: 12 2c d6       :  lcall _free_tx_buf
                        :> }
                        : ?30:
                        :> if(match_socket.buf_outsize3){
co:2c54: 90 00 22       :  mov DPTR,#_match_socket+26
co:2c57: 12 0a af       :  lcall __ld_dptr_r67
co:2c5a: ee             :  mov A,R6
co:2c5b: 4f             :  orl A,R7
co:2c5c: 60 10          :  jz ?32
                        : 
co:2c5e: 90 00 22       :  mov DPTR,#_match_socket+26
co:2c61: e4             :  clr A
co:2c62: f0             :  movx @DPTR,A
co:2c63: a3             :  inc DPTR
co:2c64: f0             :  movx @DPTR,A
                        :>  match_socket.buf_outsize3=0;
                        :>  free_tx_buf(match_socket.p_outbuf3);   
co:2c65: 90 00 28       :  mov DPTR,#_match_socket+32
co:2c68: 12 0a af       :  lcall __ld_dptr_r67
co:2c6b: 12 2c d6       :  lcall _free_tx_buf
                        :> }
                        : ?32:
co:2c6e: 22             :  ret
                        : ; end of function free_match_socket
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _send_request_ARP ; void send_request_ARP(unsigned long)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_request_ARP
                        : _send_request_ARP: ; void send_request_ARP(unsigned long)
                        :  ; parameter 'ipl' in 'RL4567' moved and assigned to local '?send_request_ARP_ipl'
co:276b: 74 23          :  mov A,#?send_request_ARP_ipl
co:276d: 12 22 73       :  lcall __st_a_r47
                        :>}
                        :>
                        :>#ifdef PHY_ETH
                        :>#if defined(USE_TCP_CLIENT) || defined(USE_UDP_CLIENT)
                        :>/**********************************************************************************
                        :>* void send_request_ARP for a specific Internet
                        :>* 
                        :>* Send an ARP Request for a specific MAC
                        :>**********************************************************************************/
                        :>void send_request_ARP(unsigned long ipl){
co:2770: 7e 00          :  mov R6,#0
co:2772: 7f 2a          :  mov R7,#42
co:2774: 12 25 3d       :  lcall _RequestSend_Phy
                        :> // puts("<ARP QUERRY>"); // Inform us...
                        :>
                        :> RequestSend_Phy(42);    // Send Reply
                        :>
                        :> Write_Frame_long_Phy(0xFFFFFFFF);  // To Broadcast
co:2777: 7c ff          :  mov R4,#255
co:2779: 7d ff          :  mov R5,#255
co:277b: 7e ff          :  mov R6,#255
co:277d: 7f ff          :  mov R7,#255
co:277f: 12 21 d4       :  lcall _Write_Frame_long_Phy
                        :> Write_Frame_word_Phy(0xFFFF);    // To Broadcast
co:2782: 7e ff          :  mov R6,#255
co:2784: 7f ff          :  mov R7,#255
co:2786: 12 21 eb       :  lcall _Write_Frame_word_Phy
                        :>
                        :> Write_Frame_xdata_Phy(my_mac,6);   // From US (MAC)
co:2789: 7c 00          :  mov R4,#0
co:278b: 7d 06          :  mov R5,#6
co:278d: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:278f: 7f 00          :  mov R7,#(_my_mac)&255
co:2791: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :>
                        :> Write_Frame_word_Phy(0x0806);   // ARP!
co:2794: 7e 08          :  mov R6,#8
co:2796: 7f 06          :  mov R7,#6
co:2798: 12 21 eb       :  lcall _Write_Frame_word_Phy
                        :>
                        :> Write_Frame_long_Phy(0x10800);   // Ethernet
co:279b: 7c 00          :  mov R4,#0
co:279d: 7d 01          :  mov R5,#1
co:279f: 7e 08          :  mov R6,#8
co:27a1: 7f 00          :  mov R7,#0
co:27a3: 12 21 d4       :  lcall _Write_Frame_long_Phy
                        :> Write_Frame_long_Phy(0x6040001);  // Request
co:27a6: 7c 06          :  mov R4,#6
co:27a8: 7d 04          :  mov R5,#4
co:27aa: 7e 00          :  mov R6,#0
co:27ac: 7f 01          :  mov R7,#1
co:27ae: 12 21 d4       :  lcall _Write_Frame_long_Phy
                        :>
                        :> Write_Frame_xdata_Phy(my_mac,6);   // From US (MAC)
co:27b1: 7c 00          :  mov R4,#0
co:27b3: 7d 06          :  mov R5,#6
co:27b5: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:27b7: 7f 00          :  mov R7,#(_my_mac)&255
co:27b9: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_long_Phy(my_ip.ipl);  // and IP!
co:27bc: 90 02 e4       :  mov DPTR,#_my_ip
co:27bf: 12 01 71       :  lcall __ld_dptr_r47
co:27c2: 12 21 d4       :  lcall _Write_Frame_long_Phy
                        :>
                        :> // Variable filled out by Host
                        :> Write_Frame_long_Phy(0xFFFFFFFF);  // To Broadcast
co:27c5: 7c ff          :  mov R4,#255
co:27c7: 7d ff          :  mov R5,#255
co:27c9: 7e ff          :  mov R6,#255
co:27cb: 7f ff          :  mov R7,#255
co:27cd: 12 21 d4       :  lcall _Write_Frame_long_Phy
                        :> Write_Frame_word_Phy(0xFFFF);    // To Broadcast
co:27d0: 7e ff          :  mov R6,#255
co:27d2: 7f ff          :  mov R7,#255
co:27d4: 12 21 eb       :  lcall _Write_Frame_word_Phy
                        :>
                        :> // If Our Mask and Destin. Mask differs in the significant netbits, querry MAC of Gateway
                        :> if((ipl^my_ip.ipl)&subnet_ip.ipl) {
co:27d7: 90 02 e4       :  mov DPTR,#_my_ip
co:27da: 12 01 65       :  lcall __ld_dptr_r03
co:27dd: 74 23          :  mov A,#?send_request_ARP_ipl
co:27df: 12 2c c8       :  lcall __ld_a_r47
co:27e2: 12 26 ae       :  lcall __bxor_i4
co:27e5: 90 02 dc       :  mov DPTR,#_subnet_ip
co:27e8: 12 01 65       :  lcall __ld_dptr_r03
co:27eb: 12 22 66       :  lcall __band_i4
co:27ee: ec             :  mov A,R4
co:27ef: 4d             :  orl A,R5
co:27f0: 4e             :  orl A,R6
co:27f1: 4f             :  orl A,R7
co:27f2: 60 0b          :  jz ?35
                        : 
co:27f4: 90 02 d8       :  mov DPTR,#_gateway_ip
co:27f7: 12 01 71       :  lcall __ld_dptr_r47
co:27fa: 12 21 d4       :  lcall _Write_Frame_long_Phy
                        :>  Write_Frame_long_Phy(gateway_ip.ipl); // and IP! (far connection over gatewy)
                        :> }else{
co:27fd: 80 08          :  sjmp ?36
                        : ?35:
                        : 
co:27ff: 74 23          :  mov A,#?send_request_ARP_ipl
co:2801: 12 2c c8       :  lcall __ld_a_r47
co:2804: 12 21 d4       :  lcall _Write_Frame_long_Phy
                        :>  Write_Frame_long_Phy(ipl);   // and IP! (local connection)
                        :> }
                        : ?36:
                        :> CommitSend_Phy();      // Start TX
co:2807: 12 22 02       :  lcall _CommitSend_Phy
co:280a: 22             :  ret
                        : ; end of function send_request_ARP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:4 bytes
                        : 
                        :  .export _process_ARP ; unsigned int process_ARP(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __process_ARP
                        : _process_ARP: ; unsigned int process_ARP(void)
                        :>}
                        :>#endif
                        :>
                        :>/**********************************************************************************
                        :>* void process_ARP(void){
                        :>* 
                        :>* 2.nd-Level-Multiplexer
                        :>* process an ARP request or (not implemented until now) an ARP reply
                        :>**********************************************************************************/
                        :>uint process_ARP(void){
co:2926: 7c 00          :  mov R4,#0
co:2928: 7d 01          :  mov R5,#1
co:292a: 7e 08          :  mov R6,#8
co:292c: 7f 00          :  mov R7,#0
co:292e: 12 0a ea       :  lcall _net_match_ulong
co:2931: ef             :  mov A,R7
co:2932: 60 07          :  jz ?38
                        :>#if defined(USE_TCP_CLIENT) || defined(USE_UDP_CLIENT)
                        :>     xdata UC_SOCKET *psock;
                        :>     uchar ui;
                        :>#endif
                        :>
                        :> uint type;
                        :> if(net_match_ulong(0x10800)) return EVENT_ARP_UNKNOWN; // No ARP!
co:2934: 7e a2          :  mov R6,#162
co:2936: 7f 00          :  mov R7,#0
co:2938: 02 2a f5       :  ljmp ?37
                        : ?38:
                        :> if(net_match_uint(0x604)) return EVENT_ARP_UNKNOWN; // No ARP!
co:293b: 7e 06          :  mov R6,#6
co:293d: 7f 04          :  mov R7,#4
co:293f: 12 0b 1f       :  lcall _net_match_uint
co:2942: ef             :  mov A,R7
co:2943: 60 07          :  jz ?40
                        : 
co:2945: 7e a2          :  mov R6,#162
co:2947: 7f 00          :  mov R7,#0
co:2949: 02 2a f5       :  ljmp ?37
                        : ?40:
                        :> type=Read_Frame_word_Phy();  
co:294c: 12 21 bd       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'type' allocated as 'auto'
co:294f: 8e 24          :  mov ?process_ARP_type,R6
co:2951: 8f 25          :  mov ?process_ARP_type+1,R7
                        :>//    sevseg_data1=type&0xff;
                        :>//    sevseg_data0=type>>8;
                        :> Read_Frame_xdata_Phy(hframe.bytes,20); // Read informative part of ARP message
co:2953: 7c 00          :  mov R4,#0
co:2955: 7d 14          :  mov R5,#20
co:2957: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:2959: 7f ce          :  mov R7,#(_hframe)&255
co:295b: 12 26 5c       :  lcall _Read_Frame_xdata_Phy
                        :> if(type>2) return EVENT_ARP_NOTYPE; // Unknown Reply
co:295e: 7c 00          :  mov R4,#0
co:2960: 7d 02          :  mov R5,#2
co:2962: ae 24          :  mov R6,?process_ARP_type
co:2964: af 25          :  mov R7,?process_ARP_type+1
co:2966: d3             :  setb C
co:2967: ef             :  mov A,R7
co:2968: 9d             :  subb A,R5
co:2969: ee             :  mov A,R6
co:296a: 9c             :  subb A,R4
co:296b: 40 07          :  jc ?42
                        : 
co:296d: 7e a3          :  mov R6,#163
co:296f: 7f 00          :  mov R7,#0
co:2971: 02 2a f5       :  ljmp ?37
                        : ?42:
                        :>
                        :> if(type==1){ // ARP Request!
co:2974: ae 24          :  mov R6,?process_ARP_type
co:2976: af 25          :  mov R7,?process_ARP_type+1
co:2978: ef             :  mov A,R7
co:2979: 64 01          :  xrl A,#1
co:297b: 4e             :  orl A,R6
co:297c: 60 03          :  jz ?_12
co:297e: 02 29 fd       :  ljmp ?44
                        : ?_12:
                        : 
co:2981: 90 02 e4       :  mov DPTR,#_my_ip
co:2984: 12 01 65       :  lcall __ld_dptr_r03
co:2987: 90 01 de       :  mov DPTR,#_hframe+16
co:298a: 12 01 71       :  lcall __ld_dptr_r47
co:298d: c3             :  clr C
co:298e: 12 25 f6       :  lcall __cmp_i4
co:2991: 60 07          :  jz ?46
                        :>  if(hframe.arp_info.target_ip.ipl!=my_ip.ipl) return EVENT_ARP_OTHER; // ARP, but not for us...
co:2993: 7e a4          :  mov R6,#164
co:2995: 7f 00          :  mov R7,#0
co:2997: 02 2a f5       :  ljmp ?37
                        : ?46:
                        :> 
                        :>  // puts("<ARP request>"); // Inform us...
                        :>  RequestSend_Phy(42);   // Send Reply
co:299a: 7e 00          :  mov R6,#0
co:299c: 7f 2a          :  mov R7,#42
co:299e: 12 25 3d       :  lcall _RequestSend_Phy
                        :>
                        :>  Write_Frame_xdata_Phy(remote_mac,6);  // Kick packet back...
co:29a1: 7c 00          :  mov R4,#0
co:29a3: 7d 06          :  mov R5,#6
co:29a5: 7e 02          :  mov R6,#((_remote_mac)>>8)&255
co:29a7: 7f 08          :  mov R7,#(_remote_mac)&255
co:29a9: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_xdata_Phy(my_mac,6);  // From US (MAC)
co:29ac: 7c 00          :  mov R4,#0
co:29ae: 7d 06          :  mov R5,#6
co:29b0: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:29b2: 7f 00          :  mov R7,#(_my_mac)&255
co:29b4: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_word_Phy(0x0806);  // ARP!
co:29b7: 7e 08          :  mov R6,#8
co:29b9: 7f 06          :  mov R7,#6
co:29bb: 12 21 eb       :  lcall _Write_Frame_word_Phy
                        :>
                        :>  Write_Frame_long_Phy(0x10800);
co:29be: 7c 00          :  mov R4,#0
co:29c0: 7d 01          :  mov R5,#1
co:29c2: 7e 08          :  mov R6,#8
co:29c4: 7f 00          :  mov R7,#0
co:29c6: 12 21 d4       :  lcall _Write_Frame_long_Phy
                        :>  Write_Frame_long_Phy(0x6040002); // Response
co:29c9: 7c 06          :  mov R4,#6
co:29cb: 7d 04          :  mov R5,#4
co:29cd: 7e 00          :  mov R6,#0
co:29cf: 7f 02          :  mov R7,#2
co:29d1: 12 21 d4       :  lcall _Write_Frame_long_Phy
                        :>
                        :>  Write_Frame_xdata_Phy(my_mac,6);  // From US (MAC)
co:29d4: 7c 00          :  mov R4,#0
co:29d6: 7d 06          :  mov R5,#6
co:29d8: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:29da: 7f 00          :  mov R7,#(_my_mac)&255
co:29dc: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_long_Phy(my_ip.ipl); // and IP!
co:29df: 90 02 e4       :  mov DPTR,#_my_ip
co:29e2: 12 01 71       :  lcall __ld_dptr_r47
co:29e5: 12 21 d4       :  lcall _Write_Frame_long_Phy
                        :>  Write_Frame_xdata_Phy(hframe.bytes,10);  // Kick half packet back...
co:29e8: 7c 00          :  mov R4,#0
co:29ea: 7d 0a          :  mov R5,#10
co:29ec: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:29ee: 7f ce          :  mov R7,#(_hframe)&255
co:29f0: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :>  CommitSend_Phy();     // Start TX
co:29f3: 12 22 02       :  lcall _CommitSend_Phy
                        :>
                        :>  return EVENT_ARP_REQUEST;    // No Event of interest, but an EVENT
co:29f6: 7e a0          :  mov R6,#160
co:29f8: 7f 00          :  mov R7,#0
co:29fa: 02 2a f5       :  ljmp ?37
                        : ?44:
                        :  ; variable 'psock' allocated as 'auto'
                        :>
                        :> }else{ // Arp response! For us?
co:29fd: 75 24 02       :  mov ?process_ARP_psock,#((_uc_socket)>>8)&255
co:2a00: 75 25 74       :  mov ?process_ARP_psock+1,#(_uc_socket)&255
                        :  ; variable 'ui' allocated as 'auto'
                        :>#if defined(USE_TCP_CLIENT) || defined(USE_UDP_CLIENT)
                        :> 
                        :> //puts("<ARP response>");   
                        :>  // Will work with all non-0 type sockets!
                        :>      psock=uc_socket;
                        :>      for(ui=0;ui<MAX_SOCK;ui++,psock++){
co:2a03: e4             :  clr A
co:2a04: f5 26          :  mov ?process_ARP_ui,A
                        : ?48:
                        : 
co:2a06: 85 24 83       :  mov DPH,?process_ARP_psock
co:2a09: 85 25 82       :  mov DPL,?process_ARP_psock+1
co:2a0c: e0             :  movx A,@DPTR
co:2a0d: ff             :  mov R7,A
co:2a0e: 70 03          :  jnz ?_14
co:2a10: 02 2a d8       :  ljmp ?52
                        : ?_14:
co:2a13: ae 24          :  mov R6,?process_ARP_psock
co:2a15: af 25          :  mov R7,?process_ARP_psock+1
co:2a17: 0f             :  inc R7
co:2a18: ef             :  mov A,R7
co:2a19: 70 01          :  jnz ?__2
co:2a1b: 0e             :  inc R6
                        : ?__2:
co:2a1c: 85 06 83       :  mov DPH,AR6
co:2a1f: 85 07 82       :  mov DPL,AR7
co:2a22: e0             :  movx A,@DPTR
co:2a23: ff             :  mov R7,A
co:2a24: bf 06 02       :  cjne R7,#6,?_15
co:2a27: 80 03          :  sjmp ?_16
                        : ?_15:
co:2a29: 02 2a d8       :  ljmp ?52
                        : ?_16:
                        :>          if(psock->socket_type && psock->state==ARPSENT){
co:2a2c: ae 24          :  mov R6,?process_ARP_psock
co:2a2e: af 25          :  mov R7,?process_ARP_psock+1
co:2a30: 74 08          :  mov A,#8
co:2a32: 2f             :  add A,R7
co:2a33: ff             :  mov R7,A
co:2a34: e4             :  clr A
co:2a35: 3e             :  addc A,R6
co:2a36: fe             :  mov R6,A
co:2a37: 8e 83          :  mov DPH,R6
co:2a39: 8f 82          :  mov DPL,R7
co:2a3b: 12 01 71       :  lcall __ld_dptr_r47
co:2a3e: 12 29 1d       :  lcall __movel_4_8
co:2a41: 90 01 d4       :  mov DPTR,#_hframe+6
co:2a44: 12 01 65       :  lcall __ld_dptr_r03
co:2a47: 12 2c f9       :  lcall __movel_8_4
co:2a4a: c3             :  clr C
co:2a4b: 12 25 f6       :  lcall __cmp_i4
co:2a4e: 60 33          :  jz ?56
co:2a50: 90 02 e4       :  mov DPTR,#_my_ip
co:2a53: 12 01 65       :  lcall __ld_dptr_r03
co:2a56: 12 2c f9       :  lcall __movel_8_4
co:2a59: 12 26 ae       :  lcall __bxor_i4
co:2a5c: 90 02 dc       :  mov DPTR,#_subnet_ip
co:2a5f: 12 01 65       :  lcall __ld_dptr_r03
co:2a62: 12 22 66       :  lcall __band_i4
co:2a65: ec             :  mov A,R4
co:2a66: 4d             :  orl A,R5
co:2a67: 4e             :  orl A,R6
co:2a68: 4f             :  orl A,R7
co:2a69: 70 03          :  jnz ?_18
co:2a6b: 02 2a d8       :  ljmp ?54
                        : ?_18:
co:2a6e: 90 02 d8       :  mov DPTR,#_gateway_ip
co:2a71: 12 01 65       :  lcall __ld_dptr_r03
co:2a74: 90 01 d4       :  mov DPTR,#_hframe+6
co:2a77: 12 01 71       :  lcall __ld_dptr_r47
co:2a7a: c3             :  clr C
co:2a7b: 12 25 f6       :  lcall __cmp_i4
co:2a7e: 60 03          :  jz ?_19
co:2a80: 02 2a d8       :  ljmp ?54
                        : ?_19:
                        : ?56:
                        :>    // Only ARP-Sockets are of interest if an offered ip is matched
                        :>    if((psock->sremote_ip==hframe.arp_info.sender_ip.ipl) || // Either direct IP match
                        :>     // Or Response is from Gateway, if subnets differ
                        :>       ((  (psock->sremote_ip ^ my_ip.ipl) & subnet_ip.ipl  )&&(hframe.arp_info.sender_ip.ipl==gateway
co:2a83: 7a 00          :  mov R2,#0
co:2a85: 7b 06          :  mov R3,#6
co:2a87: ae 24          :  mov R6,?process_ARP_psock
co:2a89: af 25          :  mov R7,?process_ARP_psock+1
co:2a8b: 74 02          :  mov A,#2
co:2a8d: 2f             :  add A,R7
co:2a8e: fd             :  mov R5,A
co:2a8f: e4             :  clr A
co:2a90: 3e             :  addc A,R6
co:2a91: fc             :  mov R4,A
co:2a92: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:2a94: 7f ce          :  mov R7,#(_hframe)&255
co:2a96: 12 0b 73       :  lcall _xram_fast_copy
                        :>
                        :>     // Copy MAC
                        :>     xram_fast_copy(hframe.arp_info.sender_mac,psock->sremote_mac,6);
                        :>     psock->state=ARPREC;       // After ARP was received, UDP connection is established, TCP may star
co:2a99: ae 24          :  mov R6,?process_ARP_psock
co:2a9b: af 25          :  mov R7,?process_ARP_psock+1
co:2a9d: 0f             :  inc R7
co:2a9e: ef             :  mov A,R7
co:2a9f: 70 01          :  jnz ?__3
co:2aa1: 0e             :  inc R6
                        : ?__3:
co:2aa2: 85 06 83       :  mov DPH,AR6
co:2aa5: 85 07 82       :  mov DPL,AR7
co:2aa8: 74 07          :  mov A,#7
co:2aaa: f0             :  movx @DPTR,A
                        :>     psock->retry_cnt=0;
co:2aab: ae 24          :  mov R6,?process_ARP_psock
co:2aad: af 25          :  mov R7,?process_ARP_psock+1
co:2aaf: 74 18          :  mov A,#24
co:2ab1: 2f             :  add A,R7
co:2ab2: ff             :  mov R7,A
co:2ab3: e4             :  clr A
co:2ab4: 3e             :  addc A,R6
co:2ab5: fe             :  mov R6,A
co:2ab6: 85 06 83       :  mov DPH,AR6
co:2ab9: 85 07 82       :  mov DPL,AR7
co:2abc: e4             :  clr A
co:2abd: f0             :  movx @DPTR,A
                        :>     psock->timer=1;  // Start NOW!
co:2abe: ae 24          :  mov R6,?process_ARP_psock
co:2ac0: af 25          :  mov R7,?process_ARP_psock+1
co:2ac2: 74 19          :  mov A,#25
co:2ac4: 2f             :  add A,R7
co:2ac5: ff             :  mov R7,A
co:2ac6: e4             :  clr A
co:2ac7: 3e             :  addc A,R6
co:2ac8: fe             :  mov R6,A
co:2ac9: 85 06 83       :  mov DPH,AR6
co:2acc: 85 07 82       :  mov DPL,AR7
co:2acf: 74 01          :  mov A,#1
co:2ad1: f0             :  movx @DPTR,A
                        :>
                        :>     return EVENT_ARP_OURREPLY;
co:2ad2: 7e a5          :  mov R6,#165
co:2ad4: 7f 00          :  mov R7,#0
co:2ad6: 80 1d          :  sjmp ?37
                        : ?54:
                        :>    
                        :>    }
                        :>   }  
                        : ?52:
                        :>  }
co:2ad8: 05 26          :  inc ?process_ARP_ui
co:2ada: 74 32          :  mov A,#50
co:2adc: 25 25          :  add A,?process_ARP_psock+1
co:2ade: f5 25          :  mov ?process_ARP_psock+1,A
co:2ae0: e4             :  clr A
co:2ae1: 35 24          :  addc A,?process_ARP_psock
co:2ae3: f5 24          :  mov ?process_ARP_psock,A
                        : 
co:2ae5: 7d 02          :  mov R5,#2
co:2ae7: af 26          :  mov R7,?process_ARP_ui
co:2ae9: c3             :  clr C
co:2aea: ef             :  mov A,R7
co:2aeb: 9d             :  subb A,R5
co:2aec: 50 03          :  jnc ?_20
co:2aee: 02 2a 06       :  ljmp ?48
                        : ?_20:
                        :>#endif
                        :>  return EVENT_ARP_OTHERREPLY;
co:2af1: 7e a1          :  mov R6,#161
co:2af3: 7f 00          :  mov R7,#0
                        : ?37:
co:2af5: 22             :  ret
                        : ; end of function process_ARP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:3 bytes
                        : 
                        :  .export _process_ICMP ; unsigned int process_ICMP(unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __process_ICMP
                        : _process_ICMP: ; unsigned int process_ICMP(unsigned int)
                        :  ; parameter 'dlen' in 'RW67' moved and assigned to local '?process_ICMP_dlen'
co:2b03: 8e 29          :  mov ?process_ICMP_dlen,R6
co:2b05: 8f 2a          :  mov ?process_ICMP_dlen+1,R7
                        :> }
                        :>}
                        :>#endif // PHY_ETH
                        :>
                        :>/**********************************************************************************
                        :>* void process_ICMP(uint dlen)
                        :>*
                        :>* 2.nd-Level-Multiplexer
                        :>* received an ICMp frame ('PING') 
                        :>**********************************************************************************/
                        :>uint process_ICMP(uint dlen){
co:2b07: 7c 00          :  mov R4,#0
co:2b09: 7d 14          :  mov R5,#20
co:2b0b: ae 29          :  mov R6,?process_ICMP_dlen
co:2b0d: af 2a          :  mov R7,?process_ICMP_dlen+1
co:2b0f: d3             :  setb C
co:2b10: ef             :  mov A,R7
co:2b11: 9d             :  subb A,R5
co:2b12: ee             :  mov A,R6
co:2b13: 9c             :  subb A,R4
co:2b14: 40 06          :  jc ?58
                        :> //  MICROCHIP SAYS IT IS SAVE TO TRUNCATE ICMPs, so truncate...
                        :> if(dlen>sizeof(HFRAME)) dlen=sizeof(HFRAME);  // Truncate too long Pings!
co:2b16: 75 29 00       :  mov ?process_ICMP_dlen,#0
co:2b19: 75 2a 14       :  mov ?process_ICMP_dlen+1,#20
                        : ?58:
                        :>
                        :> Read_Frame_xdata_Phy(hframe.bytes,dlen); // Read Sender's Data
co:2b1c: ac 29          :  mov R4,?process_ICMP_dlen
co:2b1e: ad 2a          :  mov R5,?process_ICMP_dlen+1
co:2b20: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:2b22: 7f ce          :  mov R7,#(_hframe)&255
co:2b24: 12 26 5c       :  lcall _Read_Frame_xdata_Phy
                        :> if(hframe.ping_info.type==0){
co:2b27: 90 01 ce       :  mov DPTR,#_hframe
co:2b2a: e0             :  movx A,@DPTR
co:2b2b: ff             :  mov R7,A
co:2b2c: 70 07          :  jnz ?60
                        : 
co:2b2e: 7e b0          :  mov R6,#176
co:2b30: 7f 00          :  mov R7,#0
co:2b32: 02 2c 1f       :  ljmp ?57
                        : ?60:
                        :>  // *** NOT REQUIRED FOR SERVER MODE! ***
                        :>  // puts("<ECHO REPLY ???>");
                        :>  return EVENT_ICMP_REPLY;
                        :>
                        :> }else if(hframe.ping_info.type==8){
co:2b35: 90 01 ce       :  mov DPTR,#_hframe
co:2b38: e0             :  movx A,@DPTR
co:2b39: ff             :  mov R7,A
co:2b3a: bf 08 02       :  cjne R7,#8,?_23
co:2b3d: 80 03          :  sjmp ?_24
                        : ?_23:
co:2b3f: 02 2c 1b       :  ljmp ?62
                        : ?_24:
                        : 
co:2b42: 90 01 ce       :  mov DPTR,#_hframe
co:2b45: e4             :  clr A
co:2b46: f0             :  movx @DPTR,A
                        :>
                        :>  //puts("<ICMP ECHO REQUEST>"); // For debugging...
                        :>
                        :>  // Reflect block as reply
                        :>  hframe.ping_info.type=0;
                        :>  hframe.ping_info.checksum=0; 
co:2b47: 90 01 d0       :  mov DPTR,#_hframe+2
co:2b4a: e4             :  clr A
co:2b4b: f0             :  movx @DPTR,A
co:2b4c: a3             :  inc DPTR
co:2b4d: f0             :  movx @DPTR,A
                        :>  hframe.ping_info.checksum=~ip_check(hframe.bytes,dlen);
co:2b4e: ac 29          :  mov R4,?process_ICMP_dlen
co:2b50: ad 2a          :  mov R5,?process_ICMP_dlen+1
co:2b52: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:2b54: 7f ce          :  mov R7,#(_hframe)&255
co:2b56: 12 0b 3d       :  lcall _ip_check
co:2b59: ef             :  mov A,R7
co:2b5a: f4             :  cpl A
co:2b5b: ff             :  mov R7,A
co:2b5c: ee             :  mov A,R6
co:2b5d: f4             :  cpl A
co:2b5e: fe             :  mov R6,A
co:2b5f: 90 01 d0       :  mov DPTR,#_hframe+2
co:2b62: 12 0a c1       :  lcall __st_dptr_r67
                        :>
                        :>  // Now, send out reply
                        :>  hhdr.vhl_service=0x4500;
co:2b65: 90 01 ee       :  mov DPTR,#_hhdr
co:2b68: 74 45          :  mov A,#69
co:2b6a: f0             :  movx @DPTR,A
co:2b6b: a3             :  inc DPTR
co:2b6c: e4             :  clr A
co:2b6d: f0             :  movx @DPTR,A
                        :>  hhdr.len=sizeof(IP_HDR)+dlen;
co:2b6e: ae 29          :  mov R6,?process_ICMP_dlen
co:2b70: af 2a          :  mov R7,?process_ICMP_dlen+1
co:2b72: 74 14          :  mov A,#20
co:2b74: 2f             :  add A,R7
co:2b75: ff             :  mov R7,A
co:2b76: e4             :  clr A
co:2b77: 3e             :  addc A,R6
co:2b78: fe             :  mov R6,A
co:2b79: 90 01 f0       :  mov DPTR,#_hhdr+2
co:2b7c: 12 0a c1       :  lcall __st_dptr_r67
                        :>  hhdr.ident=0;
co:2b7f: 90 01 f2       :  mov DPTR,#_hhdr+4
co:2b82: e4             :  clr A
co:2b83: f0             :  movx @DPTR,A
co:2b84: a3             :  inc DPTR
co:2b85: f0             :  movx @DPTR,A
                        :>  hhdr.frags=16384; // No Fragmentation
co:2b86: 90 01 f4       :  mov DPTR,#_hhdr+6
co:2b89: 74 40          :  mov A,#64
co:2b8b: f0             :  movx @DPTR,A
co:2b8c: a3             :  inc DPTR
co:2b8d: e4             :  clr A
co:2b8e: f0             :  movx @DPTR,A
                        :>  hhdr.ttl=100; // Industrial standard
co:2b8f: 90 01 f6       :  mov DPTR,#_hhdr+8
co:2b92: 74 64          :  mov A,#100
co:2b94: f0             :  movx @DPTR,A
                        :>  hhdr.pcol=1; // ICMP
co:2b95: 90 01 f7       :  mov DPTR,#_hhdr+9
co:2b98: 74 01          :  mov A,#1
co:2b9a: f0             :  movx @DPTR,A
                        :>  hhdr.checksum=0;
co:2b9b: 90 01 f8       :  mov DPTR,#_hhdr+10
co:2b9e: e4             :  clr A
co:2b9f: f0             :  movx @DPTR,A
co:2ba0: a3             :  inc DPTR
co:2ba1: f0             :  movx @DPTR,A
                        :>  hhdr.sip.ipl=my_ip.ipl;
co:2ba2: 90 02 e4       :  mov DPTR,#_my_ip
co:2ba5: 12 01 71       :  lcall __ld_dptr_r47
co:2ba8: 90 01 fa       :  mov DPTR,#_hhdr+12
co:2bab: 12 04 f1       :  lcall __st_dptr_r47
                        :>  hhdr.dip.ipl=remote_ip.ipl;
co:2bae: 90 02 e0       :  mov DPTR,#_remote_ip
co:2bb1: 12 01 71       :  lcall __ld_dptr_r47
co:2bb4: 90 01 fe       :  mov DPTR,#_hhdr+16
co:2bb7: 12 04 f1       :  lcall __st_dptr_r47
                        :>  hhdr.checksum=~ip_check((xdata uchar*)&hhdr,sizeof(IP_HDR));
co:2bba: 7c 00          :  mov R4,#0
co:2bbc: 7d 14          :  mov R5,#20
co:2bbe: 7e 01          :  mov R6,#((_hhdr)>>8)&255
co:2bc0: 7f ee          :  mov R7,#(_hhdr)&255
co:2bc2: 12 0b 3d       :  lcall _ip_check
co:2bc5: ef             :  mov A,R7
co:2bc6: f4             :  cpl A
co:2bc7: ff             :  mov R7,A
co:2bc8: ee             :  mov A,R6
co:2bc9: f4             :  cpl A
co:2bca: fe             :  mov R6,A
co:2bcb: 90 01 f8       :  mov DPTR,#_hhdr+10
co:2bce: 12 0a c1       :  lcall __st_dptr_r67
                        :>
                        :>#ifdef PHY_ETH
                        :>  RequestSend_Phy(dlen+sizeof(IP_HDR)+14); // Send Reply
co:2bd1: ae 29          :  mov R6,?process_ICMP_dlen
co:2bd3: af 2a          :  mov R7,?process_ICMP_dlen+1
co:2bd5: 74 22          :  mov A,#34
co:2bd7: 2f             :  add A,R7
co:2bd8: ff             :  mov R7,A
co:2bd9: e4             :  clr A
co:2bda: 3e             :  addc A,R6
co:2bdb: fe             :  mov R6,A
co:2bdc: 12 25 3d       :  lcall _RequestSend_Phy
                        :>  Write_Frame_xdata_Phy(remote_mac,6);  // Kick back...
co:2bdf: 7c 00          :  mov R4,#0
co:2be1: 7d 06          :  mov R5,#6
co:2be3: 7e 02          :  mov R6,#((_remote_mac)>>8)&255
co:2be5: 7f 08          :  mov R7,#(_remote_mac)&255
co:2be7: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_xdata_Phy(my_mac,6);  // From US (MAC)
co:2bea: 7c 00          :  mov R4,#0
co:2bec: 7d 06          :  mov R5,#6
co:2bee: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:2bf0: 7f 00          :  mov R7,#(_my_mac)&255
co:2bf2: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_word_Phy(0x800);  // type IP
co:2bf5: 7e 08          :  mov R6,#8
co:2bf7: 7f 00          :  mov R7,#0
co:2bf9: 12 21 eb       :  lcall _Write_Frame_word_Phy
                        :>#else
                        :>  RequestSend_Phy(dlen+sizeof(IP_HDR)); // Send Reply (PPP)
                        :>#endif
                        :>
                        :>  Write_Frame_xdata_Phy((xdata uchar*)&hhdr,sizeof(IP_HDR));  // Send Header
co:2bfc: 7c 00          :  mov R4,#0
co:2bfe: 7d 14          :  mov R5,#20
co:2c00: 7e 01          :  mov R6,#((_hhdr)>>8)&255
co:2c02: 7f ee          :  mov R7,#(_hhdr)&255
co:2c04: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_xdata_Phy(hframe.bytes,dlen);  // and echo
co:2c07: ac 29          :  mov R4,?process_ICMP_dlen
co:2c09: ad 2a          :  mov R5,?process_ICMP_dlen+1
co:2c0b: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:2c0d: 7f ce          :  mov R7,#(_hframe)&255
co:2c0f: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :>  // puts("<PING>\a"); // show it!
                        :>  CommitSend_Phy();     // Start TX
co:2c12: 12 22 02       :  lcall _CommitSend_Phy
                        :>
                        :>  return EVENT_ICMP_REQUEST; // Someone has PINGED us!
co:2c15: 7e b1          :  mov R6,#177
co:2c17: 7f 00          :  mov R7,#0
co:2c19: 80 04          :  sjmp ?57
                        : ?62:
                        :>
                        :> }else return EVENT_ICMP_UNKNOWN; // Ignore the Rest...
co:2c1b: 7e b2          :  mov R6,#178
co:2c1d: 7f 00          :  mov R7,#0
                        : ?57:
co:2c1f: 22             :  ret
                        : ; end of function process_ICMP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .export _process_UDP ; unsigned int process_UDP(unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __process_UDP
                        : _process_UDP: ; unsigned int process_UDP(unsigned int)
                        :  ; parameter 'dlen' in 'RW67' moved and assigned to local '?process_UDP_dlen'
co:2810: 8e 24          :  mov ?process_UDP_dlen,R6
co:2812: 8f 25          :  mov ?process_UDP_dlen+1,R7
                        :>}
                        :>
                        :>
                        :>#ifdef USE_UDP
                        :>/**********************************************************************************
                        :>* void process_UDP(void)
                        :>* 
                        :>* 3.rd-Level-Multiplexer
                        :>* Process the Header (and contents) of a UDP datagram.
                        :>*
                        :>* An UPD frame may arrive as broadcast, so treat is as non important first...
                        :>*
                        :>* Note: It is intended hframe my by used for synthesisinhg a response header...
                        :>* 
                        :>**********************************************************************************/
                        :>uint process_UDP(uint dlen){
co:2814: 12 21 bd       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'udp_sport' allocated as 'auto'
co:2817: 8e 26          :  mov ?process_UDP_udp_sport,R6
co:2819: 8f 27          :  mov ?process_UDP_udp_sport+1,R7
                        :> xdata UC_SOCKET *psock;
                        :> uint ui;
                        :>
                        :> uint udp_sport, udp_dport;
                        :> udp_sport=Read_Frame_word_Phy();
                        :> udp_dport=Read_Frame_word_Phy();
co:281b: 12 21 bd       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'udp_dport' allocated as 'auto'
co:281e: 8e 28          :  mov ?process_UDP_udp_dport,R6
co:2820: 8f 29          :  mov ?process_UDP_udp_dport+1,R7
                        :> if(net_match_uint(dlen)) {
co:2822: ae 24          :  mov R6,?process_UDP_dlen
co:2824: af 25          :  mov R7,?process_UDP_dlen+1
co:2826: 12 0b 1f       :  lcall _net_match_uint
co:2829: ef             :  mov A,R7
co:282a: 60 07          :  jz ?65
                        : 
co:282c: 7e e1          :  mov R6,#225
co:282e: 7f 00          :  mov R7,#0
co:2830: 02 29 1c       :  ljmp ?64
                        : ?65:
                        :>  return EVENT_UDP_ERROR; // a simple check for plausibility...
                        :> }
                        :> Read_Frame_word_Phy(); // Ignore CS...
co:2833: 12 21 bd       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'psock' allocated as 'auto'
                        :>
                        :>
                        :>     psock=uc_socket;
co:2836: 75 2a 02       :  mov ?process_UDP_psock,#((_uc_socket)>>8)&255
co:2839: 75 2b 74       :  mov ?process_UDP_psock+1,#(_uc_socket)&255
                        :  ; variable 'ui' allocated as 'auto'
                        :>     for(ui=0;ui<MAX_SOCK;ui++,psock++){
co:283c: e4             :  clr A
co:283d: f5 2c          :  mov ?process_UDP_ui,A
co:283f: f5 2d          :  mov ?process_UDP_ui+1,A
                        : ?67:
                        : 
co:2841: 85 2a 83       :  mov DPH,?process_UDP_psock
co:2844: 85 2b 82       :  mov DPL,?process_UDP_psock+1
co:2847: e0             :  movx A,@DPTR
co:2848: ff             :  mov R7,A
co:2849: bf 01 02       :  cjne R7,#1,?_26
co:284c: 80 03          :  sjmp ?_27
                        : ?_26:
co:284e: 02 28 f3       :  ljmp ?71
                        : ?_27:
                        :>         if(psock->socket_type==SOCKET_UDP){  // Only UDP-Sockets are of interest
co:2851: ae 2a          :  mov R6,?process_UDP_psock
co:2853: af 2b          :  mov R7,?process_UDP_psock+1
co:2855: 74 0e          :  mov A,#14
co:2857: 2f             :  add A,R7
co:2858: ff             :  mov R7,A
co:2859: e4             :  clr A
co:285a: 3e             :  addc A,R6
co:285b: fe             :  mov R6,A
co:285c: 8e 83          :  mov DPH,R6
co:285e: 8f 82          :  mov DPL,R7
co:2860: 12 06 c7       :  lcall __ld_dptr_r45
co:2863: ae 28          :  mov R6,?process_UDP_udp_dport
co:2865: af 29          :  mov R7,?process_UDP_udp_dport+1
co:2867: ed             :  mov A,R5
co:2868: 6f             :  xrl A,R7
co:2869: 70 04          :  jnz ?_28
co:286b: ec             :  mov A,R4
co:286c: 6e             :  xrl A,R6
co:286d: 60 03          :  jz ?_29
                        : ?_28:
co:286f: 02 28 f3       :  ljmp ?73
                        : ?_29:
                        :>              // Test local port match
                        :>                 if(psock->local_port==udp_dport){
co:2872: ae 2a          :  mov R6,?process_UDP_psock
co:2874: af 2b          :  mov R7,?process_UDP_psock+1
co:2876: 74 0c          :  mov A,#12
co:2878: 2f             :  add A,R7
co:2879: fd             :  mov R5,A
co:287a: e4             :  clr A
co:287b: 3e             :  addc A,R6
co:287c: fc             :  mov R4,A
co:287d: ae 26          :  mov R6,?process_UDP_udp_sport
co:287f: af 27          :  mov R7,?process_UDP_udp_sport+1
co:2881: 8c 83          :  mov DPH,R4
co:2883: 8d 82          :  mov DPL,R5
co:2885: 12 0a c1       :  lcall __st_dptr_r67
                        :>                        // Still missing: This should only be done for PASSIVE UDP-Ports...
                        :>                        psock->sremote_port=udp_sport;  // Copy Sender's Sourceport
                        :>                        psock->sremote_ip=remote_ip.ipl; // Copy Sender's IP
co:2888: ae 2a          :  mov R6,?process_UDP_psock
co:288a: af 2b          :  mov R7,?process_UDP_psock+1
co:288c: 74 08          :  mov A,#8
co:288e: 2f             :  add A,R7
co:288f: fb             :  mov R3,A
co:2890: e4             :  clr A
co:2891: 3e             :  addc A,R6
co:2892: fa             :  mov R2,A
co:2893: 90 02 e0       :  mov DPTR,#_remote_ip
co:2896: 12 01 71       :  lcall __ld_dptr_r47
co:2899: 8a 83          :  mov DPH,R2
co:289b: 8b 82          :  mov DPL,R3
co:289d: 12 04 f1       :  lcall __st_dptr_r47
                        :>#ifdef PHY_ETH
                        :>                        xram_fast_copy(&remote_mac[0],psock->sremote_mac,6); // Copy Sender's MAC to s
co:28a0: 7a 00          :  mov R2,#0
co:28a2: 7b 06          :  mov R3,#6
co:28a4: ae 2a          :  mov R6,?process_UDP_psock
co:28a6: af 2b          :  mov R7,?process_UDP_psock+1
co:28a8: 74 02          :  mov A,#2
co:28aa: 2f             :  add A,R7
co:28ab: fd             :  mov R5,A
co:28ac: e4             :  clr A
co:28ad: 3e             :  addc A,R6
co:28ae: fc             :  mov R4,A
co:28af: 7e 02          :  mov R6,#((_remote_mac)>>8)&255
co:28b1: 7f 08          :  mov R7,#(_remote_mac)&255
co:28b3: 12 0b 73       :  lcall _xram_fast_copy
                        :  ; variable 'dlen' allocated as 'auto'
                        :>#endif
                        :>                        dlen-=8; // Subtract header length
co:28b6: 74 f8          :  mov A,#248
co:28b8: 25 25          :  add A,?process_UDP_dlen+1
co:28ba: f5 2f          :  mov ?i77+1,A
co:28bc: 74 ff          :  mov A,#255
co:28be: 35 24          :  addc A,?process_UDP_dlen
co:28c0: f5 2e          :  mov ?i77,A
                        :>                        if(dlen>MAX_RX) break;   // Ignore too long frames...
co:28c2: 7c 00          :  mov R4,#0
co:28c4: 7d 64          :  mov R5,#100
co:28c6: ae 2e          :  mov R6,?i77
co:28c8: af 2f          :  mov R7,?i77+1
co:28ca: d3             :  setb C
co:28cb: ef             :  mov A,R7
co:28cc: 9d             :  subb A,R5
co:28cd: ee             :  mov A,R6
co:28ce: 9c             :  subb A,R4
                        : 
co:28cf: 50 47          :  jnc ?69
                        :>#ifdef PHY_ETH
                        :>                        Read_Frame_xdata_Phy(rcv_buf,dlen);  // Read Sender's Data, if any
co:28d1: ac 2e          :  mov R4,?i77
co:28d3: ad 2f          :  mov R5,?i77+1
co:28d5: 7e 02          :  mov R6,#((_rcv_buf)>>8)&255
co:28d7: 7f 10          :  mov R7,#(_rcv_buf)&255
co:28d9: 12 26 5c       :  lcall _Read_Frame_xdata_Phy
                        :>#else
                        :>                        rcv_buf=Get_Frame_xdata_pointer();  // Why copy, if it is already there...
                        :>#endif
                        :>
                        :>                        rcv_len=dlen;    // remember size of read data...
co:28dc: ae 2e          :  mov R6,?i77
co:28de: af 2f          :  mov R7,?i77+1
co:28e0: 90 02 0e       :  mov DPTR,#_rcv_len
co:28e3: 12 0a c1       :  lcall __st_dptr_r67
                        :>                        return EVENT_UDP_DATARECEIVED+ui;
co:28e6: ae 2c          :  mov R6,?process_UDP_ui
co:28e8: af 2d          :  mov R7,?process_UDP_ui+1
co:28ea: e4             :  clr A
co:28eb: 2f             :  add A,R7
co:28ec: ff             :  mov R7,A
co:28ed: 74 e2          :  mov A,#226
co:28ef: 3e             :  addc A,R6
co:28f0: fe             :  mov R6,A
co:28f1: 80 29          :  sjmp ?64
                        : ?73:
                        :>                  }
                        :>         }
                        : ?71:
                        :>     }
co:28f3: 05 2d          :  inc ?process_UDP_ui+1
co:28f5: e5 2d          :  mov A,?process_UDP_ui+1
co:28f7: 70 02          :  jnz ?_31
co:28f9: 05 2c          :  inc ?process_UDP_ui
                        : ?_31:
co:28fb: 74 32          :  mov A,#50
co:28fd: 25 2b          :  add A,?process_UDP_psock+1
co:28ff: f5 2b          :  mov ?process_UDP_psock+1,A
co:2901: e4             :  clr A
co:2902: 35 2a          :  addc A,?process_UDP_psock
co:2904: f5 2a          :  mov ?process_UDP_psock,A
                        : 
co:2906: 7c 00          :  mov R4,#0
co:2908: 7d 02          :  mov R5,#2
co:290a: ae 2c          :  mov R6,?process_UDP_ui
co:290c: af 2d          :  mov R7,?process_UDP_ui+1
co:290e: c3             :  clr C
co:290f: ef             :  mov A,R7
co:2910: 9d             :  subb A,R5
co:2911: ee             :  mov A,R6
co:2912: 9c             :  subb A,R4
co:2913: 50 03          :  jnc ?_32
co:2915: 02 28 41       :  ljmp ?67
                        : ?_32:
                        : ?69:
                        :>
                        :> // *********** Check local sockets for a match or return ...... ************
                        :> return EVENT_UDP_UNSOLICITED; // None of our Sockets: RETURN
co:2918: 7e e0          :  mov R6,#224
co:291a: 7f 00          :  mov R7,#0
                        : ?64:
co:291c: 22             :  ret
                        : ; end of function process_UDP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:12 bytes
                        : 
                        :  .export _send_upd ; void send_upd(xdata char *, unsigned int, xdata unsigned char (*)[6], unsigned lo
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_upd
                        : _send_upd: ; void send_upd(xdata char *, unsigned int, xdata unsigned char (*)[6], unsigned long, unsi
                        :  ; parameter 'len' in 'RW45' moved and assigned to local '?send_upd_len'
                        :  ; parameter 'rem_ipl' moved and assigned to 'RL0123'
                        :  ; parameter 'sport' assigned to local '?send_upd_0_sport'
                        :  ; parameter 'dport' assigned to local '?send_upd_0_dport'
                        :  ; parameter 'data' in 'RW67' moved and assigned to local '?send_upd_data'
                        :  ; parameter 'pmac' in 'RW23' moved and assigned to local '?send_upd_pmac'
                        :  mov ?send_upd_len,R4
                        :  mov ?send_upd_len+1,R5
                        :  mov ?send_upd_data,R6
                        :  mov ?send_upd_data+1,R7
                        :  mov ?send_upd_pmac,R2
                        :  mov ?send_upd_pmac+1,R3
                        :  mov R0,#?send_upd_0_rem_ipl
                        :  lcall __ld_r0_r03
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* void send_upd();
                        :>**********************************************************************************/
                        :>#ifdef PHY_ETH
                        :> void send_upd(xdata char* data, uint len,xdata MAC *pmac,unsigned long rem_ipl,uint sport, uint dport
                        :  mov DPTR,#_hhdr
                        :  mov A,#69
                        :  movx @DPTR,A
                        :  inc DPTR
                        :  clr A
                        :  movx @DPTR,A
                        :>#else
                        :> void send_upd(xdata char* data, uint len,unsigned long rem_ipl,uint sport, uint dport){
                        :>#endif
                        :> // Now fill out IP-Header
                        :> hhdr.vhl_service=0x4500;
                        :> hhdr.len=sizeof(IP_HDR)+8+len; // 8 Bytes UDP-Header
                        :  mov R6,?send_upd_len
                        :  mov R7,?send_upd_len+1
                        :  mov A,#28
                        :  add A,R7
                        :  mov R7,A
                        :  clr A
                        :  addc A,R6
                        :  mov R6,A
                        :  mov DPTR,#_hhdr+2
                        :  lcall __st_dptr_r67
                        :> hhdr.ident=0;
                        :  mov DPTR,#_hhdr+4
                        :  clr A
                        :  movx @DPTR,A
                        :  inc DPTR
                        :  movx @DPTR,A
                        :> hhdr.frags=16384; // No Fragmentation
                        :  mov DPTR,#_hhdr+6
                        :  mov A,#64
                        :  movx @DPTR,A
                        :  inc DPTR
                        :  clr A
                        :  movx @DPTR,A
                        :> hhdr.ttl=100; // Industrial standard
                        :  mov DPTR,#_hhdr+8
                        :  mov A,#100
                        :  movx @DPTR,A
                        :> hhdr.pcol=17; // UDP
                        :  mov DPTR,#_hhdr+9
                        :  mov A,#17
                        :  movx @DPTR,A
                        :> hhdr.checksum=0;
                        :  mov DPTR,#_hhdr+10
                        :  clr A
                        :  movx @DPTR,A
                        :  inc DPTR
                        :  movx @DPTR,A
                        :> hhdr.sip.ipl=my_ip.ipl;
                        :  mov DPTR,#_my_ip
                        :  lcall __ld_dptr_r47
                        :  mov DPTR,#_hhdr+12
                        :  lcall __st_dptr_r47
                        :> hhdr.dip.ipl=rem_ipl;
                        :  mov DPTR,#_hhdr+16
                        :  lcall __st_dptr_r03
                        :> hhdr.checksum=~(ip_check((xdata uchar*)&hhdr,sizeof(IP_HDR))); // IP-Header only
                        :  mov R4,#0
                        :  mov R5,#20
                        :  mov R6,#((_hhdr)>>8)&255
                        :  mov R7,#(_hhdr)&255
                        :  lcall _ip_check
                        :  mov A,R7
                        :  cpl A
                        :  mov R7,A
                        :  mov A,R6
                        :  cpl A
                        :  mov R6,A
                        :  mov DPTR,#_hhdr+10
                        :  lcall __st_dptr_r67
                        :>
                        :> // Now, send out reply
                        :>#ifdef PHY_ETH
                        :> RequestSend_Phy(sizeof(IP_HDR)+14+8+len); // Send Reply:  ETHERNET_HDR IP_HDR UDP_HDR +(data)
                        :  mov R6,?send_upd_len
                        :  mov R7,?send_upd_len+1
                        :  mov A,#42
                        :  add A,R7
                        :  mov R7,A
                        :  clr A
                        :  addc A,R6
                        :  mov R6,A
                        :  lcall _RequestSend_Phy
                        :> Write_Frame_xdata_Phy((xdata uchar*)pmac,6);  // Physical destination
                        :  mov R4,#0
                        :  mov R5,#6
                        :  mov R6,?send_upd_pmac
                        :  mov R7,?send_upd_pmac+1
                        :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_xdata_Phy(my_mac,6);  // From US (MAC)
                        :  mov R4,#0
                        :  mov R5,#6
                        :  mov R6,#((_my_mac)>>8)&255
                        :  mov R7,#(_my_mac)&255
                        :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_word_Phy(0x800);  // type IP
                        :  mov R6,#8
                        :  mov R7,#0
                        :  lcall _Write_Frame_word_Phy
                        :>#else
                        :> RequestSend_Phy(sizeof(IP_HDR)+8+len); // Send Reply:  (PPP_HDR) IP_HDR UDP_HDR +(data)
                        :>#endif
                        :>
                        :>
                        :> Write_Frame_xdata_Phy((xdata uchar*)&hhdr,sizeof(IP_HDR));  // Send IP Header
                        :  mov R4,#0
                        :  mov R5,#20
                        :  mov R6,#((_hhdr)>>8)&255
                        :  mov R7,#(_hhdr)&255
                        :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_word_Phy(sport);
                        :  mov R6,?send_upd_0_sport
                        :  mov R7,?send_upd_0_sport+1
                        :  lcall _Write_Frame_word_Phy
                        :> Write_Frame_word_Phy(dport);
                        :  mov R6,?send_upd_0_dport
                        :  mov R7,?send_upd_0_dport+1
                        :  lcall _Write_Frame_word_Phy
                        :> Write_Frame_word_Phy(len+8);  // Including UDP_HDR...
                        :  mov R6,?send_upd_len
                        :  mov R7,?send_upd_len+1
                        :  mov A,#8
                        :  add A,R7
                        :  mov R7,A
                        :  clr A
                        :  addc A,R6
                        :  mov R6,A
                        :  lcall _Write_Frame_word_Phy
                        :> Write_Frame_word_Phy(0);  // 0: Means: Checksum not computed
                        :  clr A
                        :  mov R6,A
                        :  mov R7,A
                        :  lcall _Write_Frame_word_Phy
                        :>
                        :> Write_Frame_xdata_Phy(data,len);   // Send data
                        :  mov R4,?send_upd_len
                        :  mov R5,?send_upd_len+1
                        :  mov R6,?send_upd_data
                        :  mov R7,?send_upd_data+1
                        :  lcall _Write_Frame_xdata_Phy
                        :> CommitSend_Phy();      // Start TX
                        :  lcall _CommitSend_Phy
                        :  ret
                        : ; end of function send_upd
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:6 bytes formals:8 bytes
                        : 
                        :  .export _send_TCP ; void send_TCP(xdata char *, unsigned int, xdata unsigned char (*)[6], unsigned lo
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_TCP
                        : _send_TCP: ; void send_TCP(xdata char *, unsigned int, xdata unsigned char (*)[6], unsigned long)
                        :  ; parameter 'len' in 'RW45' moved and assigned to local '?send_TCP_len'
                        :  ; parameter 'rem_ipl' assigned to local '?send_TCP_0_rem_ipl'
                        :  ; parameter 'data' in 'RW67' moved and assigned to local '?send_TCP_data'
                        :  ; parameter 'pmac' in 'RW23' moved and assigned to local '?send_TCP_pmac'
co:0587: 8c 34          :  mov ?send_TCP_len,R4
co:0589: 8d 35          :  mov ?send_TCP_len+1,R5
co:058b: 8e 36          :  mov ?send_TCP_data,R6
co:058d: 8f 37          :  mov ?send_TCP_data+1,R7
co:058f: 8a 38          :  mov ?send_TCP_pmac,R2
co:0591: 8b 39          :  mov ?send_TCP_pmac+1,R3
                        :>}
                        :>#endif
                        :>
                        :>/**********************************************************************************
                        :>* void send_TCP();
                        :>*
                        :>* Will send a given Segment as IP-TCP-(DATA). ACK,SEQU,WINDOW,FLAGS must be set
                        :>* by the caller! TCP-Checksum is computed. 
                        :>* MSS-option inserted for Flags with TSYN. Rem.: MSS must be >= 576 Bytes!
                        :>**********************************************************************************/
                        :>#ifdef PHY_ETH
                        :> void send_TCP(xdata char* data, uint len,xdata MAC *pmac,unsigned long rem_ipl){
co:0593: 90 01 da       :  mov DPTR,#_hframe+12
co:0596: 74 50          :  mov A,#80
co:0598: f0             :  movx @DPTR,A
                        :>#else
                        :> void send_TCP(xdata char* data, uint len,unsigned long rem_ipl){
                        :>#endif
                        :> uint data_cs;
                        :>
                        :>#ifdef USE_MSS
                        :> uint tcp_hdr_len;
                        :> if(hframe.tcp_hdr.flags & TSYN){
                        :>        tcp_hdr_len=24;
                        :>        hframe.tcp_hdr.mss=0x2040000+MAX_RX;
                        :>        hframe.tcp_hdr.hlen=96;   // Ext. Size: 24 Bytes
                        :> }else{
                        :>        tcp_hdr_len=20;
                        :>        hframe.tcp_hdr.hlen=80;   // Standard Size: 20 Bytes
                        :> }
                        :>#else
                        :> #define tcp_hdr_len 20
                        :> hframe.tcp_hdr.hlen=80;   // Standard Size: 20 Bytes
                        :>#endif
                        :>
                        :>
                        :> hframe.tcp_hdr.checksum=0;
co:0599: 90 01 de       :  mov DPTR,#_hframe+16
co:059c: e4             :  clr A
co:059d: f0             :  movx @DPTR,A
co:059e: a3             :  inc DPTR
co:059f: f0             :  movx @DPTR,A
                        :>
                        :> pseudo_hdr.sip.ipl=my_ip.ipl;  // Built Pseudo-Header for Checksum
co:05a0: 90 02 e4       :  mov DPTR,#_my_ip
co:05a3: 12 01 71       :  lcall __ld_dptr_r47
co:05a6: 90 01 e2       :  mov DPTR,#_pseudo_hdr
co:05a9: 12 04 f1       :  lcall __st_dptr_r47
                        :> pseudo_hdr.dip.ipl=rem_ipl;
co:05ac: 74 30          :  mov A,#?send_TCP_0_rem_ipl
co:05ae: 12 2c c8       :  lcall __ld_a_r47
co:05b1: 90 01 e6       :  mov DPTR,#_pseudo_hdr+4
co:05b4: 12 04 f1       :  lcall __st_dptr_r47
                        :> pseudo_hdr.pcol=6; // TCP
co:05b7: 90 01 ea       :  mov DPTR,#_pseudo_hdr+8
co:05ba: e4             :  clr A
co:05bb: f0             :  movx @DPTR,A
co:05bc: a3             :  inc DPTR
co:05bd: 74 06          :  mov A,#6
co:05bf: f0             :  movx @DPTR,A
                        :> pseudo_hdr.len=len+tcp_hdr_len;   // Data+TCP-Header, without Pseudo-header!
co:05c0: ae 34          :  mov R6,?send_TCP_len
co:05c2: af 35          :  mov R7,?send_TCP_len+1
co:05c4: 74 14          :  mov A,#20
co:05c6: 2f             :  add A,R7
co:05c7: ff             :  mov R7,A
co:05c8: e4             :  clr A
co:05c9: 3e             :  addc A,R6
co:05ca: fe             :  mov R6,A
co:05cb: 90 01 ec       :  mov DPTR,#_pseudo_hdr+10
co:05ce: 12 0a c1       :  lcall __st_dptr_r67
                        :> data_cs=ip_check(data,len); // Checksum of Data Block
co:05d1: ac 34          :  mov R4,?send_TCP_len
co:05d3: ad 35          :  mov R5,?send_TCP_len+1
co:05d5: ae 36          :  mov R6,?send_TCP_data
co:05d7: af 37          :  mov R7,?send_TCP_data+1
co:05d9: 12 0b 3d       :  lcall _ip_check
                        :  ; variable 'data_cs' assigned to register 'RW67'
                        :> hframe.tcp_hdr.checksum = ~( // Checksum of Header, Datablock and Pseudo_header
co:05dc: aa 06          :  mov R2,AR6
co:05de: ab 07          :  mov R3,AR7
co:05e0: 7c 00          :  mov R4,#0
co:05e2: 7d 0c          :  mov R5,#12
co:05e4: 7e 01          :  mov R6,#((_pseudo_hdr)>>8)&255
co:05e6: 7f e2          :  mov R7,#(_pseudo_hdr)&255
co:05e8: 12 0b 40       :  lcall _ip_check_more
co:05eb: aa 06          :  mov R2,AR6
co:05ed: ab 07          :  mov R3,AR7
co:05ef: 7c 00          :  mov R4,#0
co:05f1: 7d 14          :  mov R5,#20
co:05f3: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:05f5: 7f ce          :  mov R7,#(_hframe)&255
co:05f7: 12 0b 40       :  lcall _ip_check_more
co:05fa: ef             :  mov A,R7
co:05fb: f4             :  cpl A
co:05fc: ff             :  mov R7,A
co:05fd: ee             :  mov A,R6
co:05fe: f4             :  cpl A
co:05ff: fe             :  mov R6,A
co:0600: 90 01 de       :  mov DPTR,#_hframe+16
co:0603: 12 0a c1       :  lcall __st_dptr_r67
                        :>  ip_check_more(hframe.bytes,tcp_hdr_len, // TCP-Header
                        :>   ip_check_more((xdata uchar*)&pseudo_hdr,sizeof(PSEUDO_HDR), // Pseudo-header
                        :>    data_cs))); // Data
                        :>
                        :> // Now fill out IP-Header
                        :> hhdr.vhl_service=0x4500;
co:0606: 90 01 ee       :  mov DPTR,#_hhdr
co:0609: 74 45          :  mov A,#69
co:060b: f0             :  movx @DPTR,A
co:060c: a3             :  inc DPTR
co:060d: e4             :  clr A
co:060e: f0             :  movx @DPTR,A
                        :> hhdr.len=sizeof(IP_HDR)+tcp_hdr_len+len; // 20/24 Bytes TCP-Header (24 if MSS required)
co:060f: ae 34          :  mov R6,?send_TCP_len
co:0611: af 35          :  mov R7,?send_TCP_len+1
co:0613: 74 28          :  mov A,#40
co:0615: 2f             :  add A,R7
co:0616: ff             :  mov R7,A
co:0617: e4             :  clr A
co:0618: 3e             :  addc A,R6
co:0619: fe             :  mov R6,A
co:061a: 90 01 f0       :  mov DPTR,#_hhdr+2
co:061d: 12 0a c1       :  lcall __st_dptr_r67
                        :> hhdr.ident=0;
co:0620: 90 01 f2       :  mov DPTR,#_hhdr+4
co:0623: e4             :  clr A
co:0624: f0             :  movx @DPTR,A
co:0625: a3             :  inc DPTR
co:0626: f0             :  movx @DPTR,A
                        :> hhdr.frags=16384; // No Fragmentation
co:0627: 90 01 f4       :  mov DPTR,#_hhdr+6
co:062a: 74 40          :  mov A,#64
co:062c: f0             :  movx @DPTR,A
co:062d: a3             :  inc DPTR
co:062e: e4             :  clr A
co:062f: f0             :  movx @DPTR,A
                        :> hhdr.ttl=100; // Industrial standard
co:0630: 90 01 f6       :  mov DPTR,#_hhdr+8
co:0633: 74 64          :  mov A,#100
co:0635: f0             :  movx @DPTR,A
                        :> hhdr.pcol=6; // TCP
co:0636: 90 01 f7       :  mov DPTR,#_hhdr+9
co:0639: 74 06          :  mov A,#6
co:063b: f0             :  movx @DPTR,A
                        :> hhdr.checksum=0;
co:063c: 90 01 f8       :  mov DPTR,#_hhdr+10
co:063f: e4             :  clr A
co:0640: f0             :  movx @DPTR,A
co:0641: a3             :  inc DPTR
co:0642: f0             :  movx @DPTR,A
                        :> hhdr.sip.ipl=my_ip.ipl;
co:0643: 90 02 e4       :  mov DPTR,#_my_ip
co:0646: 12 01 71       :  lcall __ld_dptr_r47
co:0649: 90 01 fa       :  mov DPTR,#_hhdr+12
co:064c: 12 04 f1       :  lcall __st_dptr_r47
                        :> hhdr.dip.ipl=rem_ipl;
co:064f: 74 30          :  mov A,#?send_TCP_0_rem_ipl
co:0651: 12 2c c8       :  lcall __ld_a_r47
co:0654: 90 01 fe       :  mov DPTR,#_hhdr+16
co:0657: 12 04 f1       :  lcall __st_dptr_r47
                        :> hhdr.checksum=~(ip_check((xdata uchar*)&hhdr,sizeof(IP_HDR))); // IP-Header only
co:065a: 7c 00          :  mov R4,#0
co:065c: 7d 14          :  mov R5,#20
co:065e: 7e 01          :  mov R6,#((_hhdr)>>8)&255
co:0660: 7f ee          :  mov R7,#(_hhdr)&255
co:0662: 12 0b 3d       :  lcall _ip_check
co:0665: ef             :  mov A,R7
co:0666: f4             :  cpl A
co:0667: ff             :  mov R7,A
co:0668: ee             :  mov A,R6
co:0669: f4             :  cpl A
co:066a: fe             :  mov R6,A
co:066b: 90 01 f8       :  mov DPTR,#_hhdr+10
co:066e: 12 0a c1       :  lcall __st_dptr_r67
                        :>
                        :> // Now, send out reply
                        :>#ifdef PHY_ETH
                        :> RequestSend_Phy(sizeof(IP_HDR)+14+tcp_hdr_len+len); // Send Reply:  ETHERNET_HDR IP_HDR TCP_HDR +(dat
co:0671: ae 34          :  mov R6,?send_TCP_len
co:0673: af 35          :  mov R7,?send_TCP_len+1
co:0675: 74 36          :  mov A,#54
co:0677: 2f             :  add A,R7
co:0678: ff             :  mov R7,A
co:0679: e4             :  clr A
co:067a: 3e             :  addc A,R6
co:067b: fe             :  mov R6,A
co:067c: 12 25 3d       :  lcall _RequestSend_Phy
                        :> Write_Frame_xdata_Phy((xdata uchar*)pmac,6);  // Physical destination
co:067f: 7c 00          :  mov R4,#0
co:0681: 7d 06          :  mov R5,#6
co:0683: ae 38          :  mov R6,?send_TCP_pmac
co:0685: af 39          :  mov R7,?send_TCP_pmac+1
co:0687: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_xdata_Phy(my_mac,6);  // From US (MAC)
co:068a: 7c 00          :  mov R4,#0
co:068c: 7d 06          :  mov R5,#6
co:068e: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:0690: 7f 00          :  mov R7,#(_my_mac)&255
co:0692: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_word_Phy(0x800);  // type IP
co:0695: 7e 08          :  mov R6,#8
co:0697: 7f 00          :  mov R7,#0
co:0699: 12 21 eb       :  lcall _Write_Frame_word_Phy
                        :>#else
                        :> RequestSend_Phy(sizeof(IP_HDR)+tcp_hdr_len+len); // Send Reply:  (PPP+ ) IP_HDR TCP_HDR +(data)
                        :>#endif
                        :>
                        :> Write_Frame_xdata_Phy((xdata uchar*)&hhdr,sizeof(IP_HDR));  // Send IP Header
co:069c: 7c 00          :  mov R4,#0
co:069e: 7d 14          :  mov R5,#20
co:06a0: 7e 01          :  mov R6,#((_hhdr)>>8)&255
co:06a2: 7f ee          :  mov R7,#(_hhdr)&255
co:06a4: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_xdata_Phy(hframe.bytes,tcp_hdr_len);  // Send TCP Header
co:06a7: 7c 00          :  mov R4,#0
co:06a9: 7d 14          :  mov R5,#20
co:06ab: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:06ad: 7f ce          :  mov R7,#(_hframe)&255
co:06af: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_xdata_Phy(data,len);   // Send data
co:06b2: ac 34          :  mov R4,?send_TCP_len
co:06b4: ad 35          :  mov R5,?send_TCP_len+1
co:06b6: ae 36          :  mov R6,?send_TCP_data
co:06b8: af 37          :  mov R7,?send_TCP_data+1
co:06ba: 12 27 24       :  lcall _Write_Frame_xdata_Phy
                        :> CommitSend_Phy();      // Start TX
co:06bd: 12 22 02       :  lcall _CommitSend_Phy
co:06c0: 22             :  ret
                        : ; end of function send_TCP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:6 bytes formals:4 bytes
                        : 
                        :  .export _send_incomming_reset_TCP ; void send_incomming_reset_TCP(unsigned int, xdata unsigned char (
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_incomming_reset_TCP
                        : _send_incomming_reset_TCP: ; void send_incomming_reset_TCP(unsigned int, xdata unsigned char (*)[6], u
                        :  ; parameter 'ipl' in 'RL0123' assigned to 'B1_RL12131415'
                        :  ; parameter 'pmac' in 'RW45' moved and assigned to local '?send_incomming_reset_TCP_pmac'
                        :  ; parameter 'dlen' in 'RW67' assigned to 'RW23'
co:20a2: 8c 2e          :  mov ?send_incomming_reset_TCP_pmac,R4
co:20a4: 8d 2f          :  mov ?send_incomming_reset_TCP_pmac+1,R5
co:20a6: 12 26 a5       :  lcall __movel_0_12
co:20a9: aa 06          :  mov R2,AR6
co:20ab: ab 07          :  mov R3,AR7
                        :>
                        :>#ifdef DEBUG_REC
                        :>    // Record Data of Transmitted Frame
                        :>    record_frame('T',hframe.tcp_hdr.dport,hframe.tcp_hdr.seq.u,hframe.tcp_hdr.ack.u, hframe.tcp_hdr.fl
                        :>#endif
                        :>
                        :>}
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* void send_incomming_reset_TCP();
                        :>*
                        :>* Build reset-segment as reply without using match_socket, i.e. as denial for an
                        :>* incomming request... ACK included.
                        :>**********************************************************************************/
                        :>#ifdef PHY_ETH
                        :> void send_incomming_reset_TCP(uint dlen,xdata MAC *pmac,unsigned long ipl){
co:20ad: 90 01 d0       :  mov DPTR,#_hframe+2
co:20b0: 12 06 c7       :  lcall __ld_dptr_r45
                        :  ; variable 'sport' assigned to register 'RW45'
                        :>#else
                        :> void send_incomming_reset_TCP(uint dlen,unsigned long ipl){
                        :>#endif
                        :> unsigned long ack;
                        :> uint sport;
                        :> sport=hframe.tcp_hdr.dport;
                        :> hframe.tcp_hdr.dport=hframe.tcp_hdr.sport; // Bounce port
co:20b3: 90 01 ce       :  mov DPTR,#_hframe
co:20b6: 12 0a af       :  lcall __ld_dptr_r67
co:20b9: 90 01 d0       :  mov DPTR,#_hframe+2
co:20bc: 12 0a c1       :  lcall __st_dptr_r67
                        :> hframe.tcp_hdr.sport=sport;
co:20bf: 90 01 ce       :  mov DPTR,#_hframe
co:20c2: 12 04 eb       :  lcall __st_dptr_r45
                        :>
                        :> // Window, Flags and Set ACK and SEQU in the response, rest will be completed by send_tcp
                        :> hframe.tcp_hdr.window=0;  // No reply!
co:20c5: 90 01 dc       :  mov DPTR,#_hframe+14
co:20c8: e4             :  clr A
co:20c9: f0             :  movx @DPTR,A
co:20ca: a3             :  inc DPTR
co:20cb: f0             :  movx @DPTR,A
                        :> ack=hframe.tcp_hdr.seq.u+dlen;
co:20cc: e4             :  clr A
co:20cd: f9             :  mov R1,A
co:20ce: f8             :  mov R0,A
co:20cf: 90 01 d2       :  mov DPTR,#_hframe+4
co:20d2: 12 01 71       :  lcall __ld_dptr_r47
co:20d5: 12 2a f6       :  lcall __add_i4
                        :  ; variable 'ack' assigned to register 'B1_RL891011'
co:20d8: 12 29 1d       :  lcall __movel_4_8
                        :> if(hframe.tcp_hdr.flags & (TSYN | TFIN)) ack++;
co:20db: 90 01 db       :  mov DPTR,#_hframe+13
co:20de: e0             :  movx A,@DPTR
co:20df: ff             :  mov R7,A
co:20e0: 54 03          :  anl A,#3
co:20e2: ff             :  mov R7,A
co:20e3: 60 14          :  jz ?81
                        : 
co:20e5: 05 0b          :  inc AR11
co:20e7: e5 0b          :  mov A,AR11
co:20e9: 70 0e          :  jnz ?_34
co:20eb: 05 0a          :  inc AR10
co:20ed: e5 0a          :  mov A,AR10
co:20ef: 70 08          :  jnz ?_34
co:20f1: 05 09          :  inc AR9
co:20f3: e5 09          :  mov A,AR9
co:20f5: 70 02          :  jnz ?_34
co:20f7: 05 08          :  inc AR8
                        : ?_34:
                        : ?81:
                        :> hframe.tcp_hdr.seq.u=hframe.tcp_hdr.ack.u;
co:20f9: 90 01 d6       :  mov DPTR,#_hframe+8
co:20fc: 12 01 71       :  lcall __ld_dptr_r47
co:20ff: 90 01 d2       :  mov DPTR,#_hframe+4
co:2102: 12 04 f1       :  lcall __st_dptr_r47
                        :> hframe.tcp_hdr.ack.u=ack;
co:2105: 12 2c f9       :  lcall __movel_8_4
co:2108: 90 01 d6       :  mov DPTR,#_hframe+8
co:210b: 12 04 f1       :  lcall __st_dptr_r47
                        :> hframe.tcp_hdr.flags=TRST+TACK;
co:210e: 90 01 db       :  mov DPTR,#_hframe+13
co:2111: 74 14          :  mov A,#20
co:2113: f0             :  movx @DPTR,A
                        :>#ifdef PHY_ETH
                        :> send_TCP(0,0,pmac,ipl); // Replay (Ethernet)
co:2114: 85 0c 30       :  mov _send_TCP_formal_near,AR12
co:2117: 85 0d 31       :  mov _send_TCP_formal_near+1,AR13
co:211a: 85 0e 32       :  mov _send_TCP_formal_near+2,AR14
co:211d: 85 0f 33       :  mov _send_TCP_formal_near+3,AR15
co:2120: aa 2e          :  mov R2,?send_incomming_reset_TCP_pmac
co:2122: ab 2f          :  mov R3,?send_incomming_reset_TCP_pmac+1
co:2124: e4             :  clr A
co:2125: fc             :  mov R4,A
co:2126: fd             :  mov R5,A
co:2127: e4             :  clr A
co:2128: fe             :  mov R6,A
co:2129: ff             :  mov R7,A
co:212a: 12 05 87       :  lcall _send_TCP
co:212d: 22             :  ret
                        : ; end of function send_incomming_reset_TCP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .export _send_match_ok_TCP ; void send_match_ok_TCP(xdata unsigned char *, unsigned int, unsigned cha
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_match_ok_TCP
                        : _send_match_ok_TCP: ; void send_match_ok_TCP(xdata unsigned char *, unsigned int, unsigned char)
                        :  ; parameter 'flags' in 'R3'
                        :  ; parameter 'dlen' in 'RW45' assigned to 'RW01'
                        :  ; parameter 'pdata' in 'RW67' assigned to 'B1_RW1213'
co:04fd: a8 04          :  mov R0,AR4
co:04ff: a9 05          :  mov R1,AR5
co:0501: 8e 0c          :  mov AR12,R6
co:0503: 8f 0d          :  mov AR13,R7
                        :>#else
                        :> send_TCP(0,0,ipl); // Replay (PPP)
                        :>#endif
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* void send_match_ok_TCP();
                        :>*
                        :>* Build Segment header and send it as regular Header, Data are in *pdata, size alen
                        :>* match_socket must fit! hframe used as a temporary variable
                        :>**********************************************************************************/
                        :>void send_match_ok_TCP(xdata uchar *pdata, uint dlen, uchar flags){
co:0505: 90 00 16       :  mov DPTR,#_match_socket+14
co:0508: 12 0a af       :  lcall __ld_dptr_r67
co:050b: 90 01 ce       :  mov DPTR,#_hframe
co:050e: 12 0a c1       :  lcall __st_dptr_r67
                        :> unsigned long seq;
                        :>
                        :> hframe.tcp_hdr.sport=match_socket.local_port; // Our Port
                        :> hframe.tcp_hdr.dport=match_socket.sremote_port; // Remote
co:0511: 90 00 14       :  mov DPTR,#_match_socket+12
co:0514: 12 0a af       :  lcall __ld_dptr_r67
co:0517: 90 01 d0       :  mov DPTR,#_hframe+2
co:051a: 12 0a c1       :  lcall __st_dptr_r67
                        :>
                        :> // Window, Flags and Set ACK and SEQU in the response, rest will be completed by send_tcp
                        :> hframe.tcp_hdr.window=MAX_RX;  // Sender: Do not send more the MAX_RX
co:051d: 90 01 dc       :  mov DPTR,#_hframe+14
co:0520: e4             :  clr A
co:0521: f0             :  movx @DPTR,A
co:0522: a3             :  inc DPTR
co:0523: 74 64          :  mov A,#100
co:0525: f0             :  movx @DPTR,A
                        :  ; variable 'seq' assigned to register 'B1_RL891011'
                        :>
                        :> seq=match_socket.sseq.u;
co:0526: 90 00 1c       :  mov DPTR,#_match_socket+20
co:0529: e0             :  movx A,@DPTR
co:052a: f5 08          :  mov AR8,A
co:052c: a3             :  inc DPTR
co:052d: e0             :  movx A,@DPTR
co:052e: f5 09          :  mov AR9,A
co:0530: a3             :  inc DPTR
co:0531: e0             :  movx A,@DPTR
co:0532: f5 0a          :  mov AR10,A
co:0534: a3             :  inc DPTR
co:0535: e0             :  movx A,@DPTR
co:0536: f5 0b          :  mov AR11,A
                        :> if(flags & (TSYN)) seq--;  // If a SYN is sent, count this as 1
co:0538: eb             :  mov A,R3
co:0539: 54 02          :  anl A,#2
co:053b: ff             :  mov R7,A
co:053c: 60 14          :  jz ?84
                        : 
co:053e: e5 0b          :  mov A,AR11
co:0540: 15 0b          :  dec AR11
co:0542: 70 0e          :  jnz ?_36
co:0544: e5 0a          :  mov A,AR10
co:0546: 15 0a          :  dec AR10
co:0548: 70 08          :  jnz ?_36
co:054a: e5 09          :  mov A,AR9
co:054c: 15 09          :  dec AR9
co:054e: 70 02          :  jnz ?_36
co:0550: 15 08          :  dec AR8
                        : ?_36:
                        : ?84:
                        :> hframe.tcp_hdr.seq.u=seq;
co:0552: 12 2c f9       :  lcall __movel_8_4
co:0555: 90 01 d2       :  mov DPTR,#_hframe+4
co:0558: 12 04 f1       :  lcall __st_dptr_r47
                        :>
                        :> hframe.tcp_hdr.ack.u=match_socket.sack.u; // This was received from the Sender
co:055b: 90 00 18       :  mov DPTR,#_match_socket+16
co:055e: 12 01 71       :  lcall __ld_dptr_r47
co:0561: 90 01 d6       :  mov DPTR,#_hframe+8
co:0564: 12 04 f1       :  lcall __st_dptr_r47
                        :> hframe.tcp_hdr.flags=flags;
co:0567: 90 01 db       :  mov DPTR,#_hframe+13
co:056a: eb             :  mov A,R3
co:056b: f0             :  movx @DPTR,A
                        :>
                        :> // Send empty
                        :>#ifdef PHY_ETH
                        :> send_TCP(pdata,dlen,match_socket.sremote_mac, match_socket.sremote_ip );
co:056c: 90 00 10       :  mov DPTR,#_match_socket+8
co:056f: 12 01 71       :  lcall __ld_dptr_r47
co:0572: 74 30          :  mov A,#_send_TCP_formal_near
co:0574: 12 22 73       :  lcall __st_a_r47
co:0577: 7a 00          :  mov R2,#((_match_socket+2)>>8)&255
co:0579: 7b 0a          :  mov R3,#(_match_socket+2)&255
co:057b: ac 00          :  mov R4,AR0
co:057d: ad 01          :  mov R5,AR1
co:057f: ae 0c          :  mov R6,AR12
co:0581: af 0d          :  mov R7,AR13
co:0583: 12 05 87       :  lcall _send_TCP
co:0586: 22             :  ret
                        : ; end of function send_match_ok_TCP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _state_machine_TCP ; unsigned int state_machine_TCP(unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __state_machine_TCP
                        : _state_machine_TCP: ; unsigned int state_machine_TCP(unsigned int)
                        :  ; parameter 'dlen' in 'RW67' moved and assigned to local '?state_machine_TCP_dlen'
co:06cd: 8e 2e          :  mov ?state_machine_TCP_dlen,R6
co:06cf: 8f 2f          :  mov ?state_machine_TCP_dlen+1,R7
                        :>#else
                        :> send_TCP(pdata,dlen, match_socket.sremote_ip );
                        :>#endif
                        :>
                        :> // printf("<TX P:%u A:%x S:%x F:%u, T:%u> ", hframe.tcp_hdr.dport, hframe.tcp_hdr.ack.w.l_word,hframe
                        :>
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uint state_machine_TCP(uint dlen);
                        :>*
                        :>* 4.rd-Level-Multiplexer
                        :>*
                        :>* Process one step in the TCP-state-Machine. The 'match_socket' follows the 
                        :>* TCP-State-Machine if its type is SOCKET_HTTP or SOCKET_TCP.
                        :>* The low_word of the sequence-number is the offset for SOCKET_HTTP. May wrap 
                        :>* for SOCKET_TCP! So resending the sequence-number $zzzz0000 for SOCKET_HTTP implies
                        :>* resending the SYN!
                        :>* if this routine is called, destination/source port match already checked and
                        :>* 'match_socket' copied...
                        :>**********************************************************************************/
                        :>uint state_machine_TCP(uint dlen){
co:06d1: 90 01 db       :  mov DPTR,#_hframe+13
co:06d4: e0             :  movx A,@DPTR
co:06d5: ff             :  mov R7,A
co:06d6: 54 04          :  anl A,#4
co:06d8: ff             :  mov R7,A
co:06d9: 60 0f          :  jz ?87
                        :>
                        :> if(hframe.tcp_hdr.flags&TRST){
co:06db: 12 2c 20       :  lcall _free_match_socket
                        :>  free_match_socket();   // Free Buffers if allocated... 
                        :>  match_socket.state=TCP_CLOSED;  // Connection ends immediatelly
co:06de: 90 00 09       :  mov DPTR,#_match_socket+1
co:06e1: e4             :  clr A
co:06e2: f0             :  movx @DPTR,A
                        :>  return EVENT_TCP_RESETRECEIVED;
co:06e3: 7e f9          :  mov R6,#249
co:06e5: 7f 00          :  mov R7,#0
co:06e7: 02 0a 79       :  ljmp ?86
                        : ?87:
                        :> }
                        :>
                        :> // printf("<rx P:%u A:%x S:%x F:%u, T:%u> ", hframe.tcp_hdr.sport,hframe.tcp_hdr.ack.w.l_word,hframe.
                        :>
                        :> match_socket.timer=BASIC_RETRY_TIMER;
co:06ea: 90 00 21       :  mov DPTR,#_match_socket+25
co:06ed: 74 06          :  mov A,#6
co:06ef: f0             :  movx @DPTR,A
                        :>
                        :> switch(match_socket.state){
co:06f0: 90 00 09       :  mov DPTR,#_match_socket+1
co:06f3: e0             :  movx A,@DPTR
co:06f4: fd             :  mov R5,A
co:06f5: 7f 04          :  mov R7,#4
co:06f7: d3             :  setb C
co:06f8: ed             :  mov A,R5
co:06f9: 9f             :  subb A,R7
co:06fa: 40 03          :  jc ?_38
co:06fc: 02 0a 5c       :  ljmp ?89
                        : ?_38:
co:06ff: 90 0a 7a       :  mov DPTR,#?i129
co:0702: ed             :  mov A,R5
co:0703: 2d             :  add A,R5
co:0704: 50 02          :  jnc ?_39
co:0706: 05 83          :  inc DPH
                        : ?_39:
co:0708: 25 82          :  add A,DPL
co:070a: f5 82          :  mov DPL,A
co:070c: 50 02          :  jnc ?_40
co:070e: 05 83          :  inc DPH
                        : ?_40:
co:0710: 74 01          :  mov A,#1
co:0712: 93             :  movc A,@A+DPTR
co:0713: c0 e0          :  push ACC
co:0715: e4             :  clr A
co:0716: 93             :  movc A,@A+DPTR
co:0717: c0 e0          :  push ACC
co:0719: 22             :  ret
                        : 
                        : ?92:
                        :>
                        :> // Socket was listening. Only a SYN could change this
                        :> case TCP_CLOSED:  // Passive open!
                        :>  if(!(hframe.tcp_hdr.flags&TSYN)) break;
co:071a: 90 01 db       :  mov DPTR,#_hframe+13
co:071d: e0             :  movx A,@DPTR
co:071e: ff             :  mov R7,A
co:071f: 54 02          :  anl A,#2
co:0721: ff             :  mov R7,A
co:0722: 70 03          :  jnz ?93
                        : 
co:0724: 02 0a 5c       :  ljmp ?90
                        : ?93:
                        :>  // puts("<SYN RECEIVED>");
                        :>
                        :>#ifdef USE_TCP_CLIENT
                        :>  if(match_socket.tcp_client_flag!=FLAG_PASSIVE_OPEN) break; // Passove open not allowed.
                        :>#endif
                        :>
                        :>#ifdef PHY_ETH
                        :>  // Fast XDATA copy by two casts... (6 Bytes)
                        :>  *(xdata unsigned long*)match_socket.sremote_mac=*(xdata unsigned long*)remote_mac;
co:0727: 90 02 08       :  mov DPTR,#_remote_mac
co:072a: 12 01 71       :  lcall __ld_dptr_r47
co:072d: 90 00 0a       :  mov DPTR,#_match_socket+2
co:0730: 12 04 f1       :  lcall __st_dptr_r47
                        :>  *(xdata uint*)(match_socket.sremote_mac+4)=*(xdata uint*)(remote_mac+4);
co:0733: 90 02 0c       :  mov DPTR,#_remote_mac+4
co:0736: 12 0a af       :  lcall __ld_dptr_r67
co:0739: 90 00 0e       :  mov DPTR,#_match_socket+2+4
co:073c: 12 0a c1       :  lcall __st_dptr_r67
                        :>#endif
                        :>
                        :>  // Save remote's IP, set by process_IP() and other data
                        :>  match_socket.sremote_ip=remote_ip.ipl;
co:073f: 90 02 e0       :  mov DPTR,#_remote_ip
co:0742: 12 01 71       :  lcall __ld_dptr_r47
co:0745: 90 00 10       :  mov DPTR,#_match_socket+8
co:0748: 12 04 f1       :  lcall __st_dptr_r47
                        :>  match_socket.sremote_port=hframe.tcp_hdr.sport; // Remote Port match already matching!
co:074b: 90 01 ce       :  mov DPTR,#_hframe
co:074e: 12 0a af       :  lcall __ld_dptr_r67
co:0751: 90 00 14       :  mov DPTR,#_match_socket+12
co:0754: 12 0a c1       :  lcall __st_dptr_r67
                        :>  // Our Ack is sender's Sequence!
                        :>  match_socket.sack.u=hframe.tcp_hdr.seq.u+dlen+1; // +1: Bec. SYN rcvd.
co:0757: ae 2e          :  mov R6,?state_machine_TCP_dlen
co:0759: af 2f          :  mov R7,?state_machine_TCP_dlen+1
co:075b: ab 07          :  mov R3,AR7
co:075d: aa 06          :  mov R2,AR6
co:075f: e4             :  clr A
co:0760: f9             :  mov R1,A
co:0761: f8             :  mov R0,A
co:0762: 90 01 d2       :  mov DPTR,#_hframe+4
co:0765: 12 01 71       :  lcall __ld_dptr_r47
co:0768: 12 2a f6       :  lcall __add_i4
co:076b: e4             :  clr A
co:076c: f8             :  mov R0,A
co:076d: f9             :  mov R1,A
co:076e: fa             :  mov R2,A
co:076f: 7b 01          :  mov R3,#1
co:0771: 12 2a f6       :  lcall __add_i4
co:0774: 90 00 18       :  mov DPTR,#_match_socket+16
co:0777: 12 04 f1       :  lcall __st_dptr_r47
                        :>  match_socket.sseq.w.h_word=net_service_cnt;   // Time ascending...
co:077a: af 3d          :  mov R7,_net_service_cnt
co:077c: 7e 00          :  mov R6,#0
co:077e: 90 00 1c       :  mov DPTR,#_match_socket+20
co:0781: 12 0a c1       :  lcall __st_dptr_r67
                        :>  match_socket.sseq.w.l_word=0;    // Our relative Pointer (for HTTP)
co:0784: 90 00 1e       :  mov DPTR,#_match_socket+20+2
co:0787: e4             :  clr A
co:0788: f0             :  movx @DPTR,A
co:0789: a3             :  inc DPTR
co:078a: f0             :  movx @DPTR,A
                        :>
                        :>  send_match_ok_TCP(0,0,TSYN+TACK); // Reply with a single SYN+ACK
co:078b: 7b 12          :  mov R3,#18
co:078d: e4             :  clr A
co:078e: fc             :  mov R4,A
co:078f: fd             :  mov R5,A
co:0790: e4             :  clr A
co:0791: fe             :  mov R6,A
co:0792: ff             :  mov R7,A
co:0793: 12 04 fd       :  lcall _send_match_ok_TCP
                        :>  // puts("<SYN+ACK SENT>");
                        :>
                        :>  match_socket.state=TCP_SYNCON;  // SYN confirmed with SYN+ACK
co:0796: 90 00 09       :  mov DPTR,#_match_socket+1
co:0799: 74 01          :  mov A,#1
co:079b: f0             :  movx @DPTR,A
                        :>  match_socket.retry_cnt=0;
co:079c: 90 00 20       :  mov DPTR,#_match_socket+24
co:079f: e4             :  clr A
co:07a0: f0             :  movx @DPTR,A
                        :>  return EVENT_TCP_SYNRECEIVED; // Low-Byte added by caller!
co:07a1: 7e f2          :  mov R6,#242
co:07a3: 7f 00          :  mov R7,#0
co:07a5: 02 0a 79       :  ljmp ?86
                        : ?95:
                        :>
                        :>#ifdef USE_TCP_CLIENT
                        :> case TCP_SYNSENT:
                        :>  // puts("<ACTIVE OPEN SYN-RECEIVED>");
                        :>  if(!(hframe.tcp_hdr.flags&TSYN)) break;
                        :>  hframe.tcp_hdr.seq.u++;    // Count remote SYN
                        :>  match_socket.sack.u=hframe.tcp_hdr.seq.u; // +1: Bec. SYN rcvd.
                        :>#endif
                        :>
                        :> case TCP_SYNCON:
                        :> case TCP_EST:
                        :>  if(!(hframe.tcp_hdr.flags&TACK)) break;
co:07a8: 90 01 db       :  mov DPTR,#_hframe+13
co:07ab: e0             :  movx A,@DPTR
co:07ac: ff             :  mov R7,A
co:07ad: 54 10          :  anl A,#16
co:07af: ff             :  mov R7,A
co:07b0: 70 03          :  jnz ?96
                        : 
co:07b2: 02 0a 5c       :  ljmp ?90
                        : ?96:
                        :>  if(dlen>MAX_RX) dlen=MAX_RX;  // IDIOTA! Clip data in size (don't know if this is safe?)
co:07b5: 7c 00          :  mov R4,#0
co:07b7: 7d 64          :  mov R5,#100
co:07b9: ae 2e          :  mov R6,?state_machine_TCP_dlen
co:07bb: af 2f          :  mov R7,?state_machine_TCP_dlen+1
co:07bd: d3             :  setb C
co:07be: ef             :  mov A,R7
co:07bf: 9d             :  subb A,R5
co:07c0: ee             :  mov A,R6
co:07c1: 9c             :  subb A,R4
co:07c2: 40 06          :  jc ?98
                        : 
co:07c4: 75 2e 00       :  mov ?state_machine_TCP_dlen,#0
co:07c7: 75 2f 64       :  mov ?state_machine_TCP_dlen+1,#100
                        : ?98:
                        :>
                        :>  // Here a small problem is silently ignored: A not acknowled Segment which is restransmitted larger
                        :>  // could contain old data as a part (maybe for TELNET...)
                        :>  // Silently assume all Segments have valid ACK
                        :>
                        :>  if(match_socket.sack.u!=hframe.tcp_hdr.seq.u) return EVENT_TCP_OUTOFBOUNDS; // Ignore-out-of-bounds 
co:07ca: 90 01 d2       :  mov DPTR,#_hframe+4
co:07cd: 12 01 65       :  lcall __ld_dptr_r03
co:07d0: 90 00 18       :  mov DPTR,#_match_socket+16
co:07d3: 12 01 71       :  lcall __ld_dptr_r47
co:07d6: c3             :  clr C
co:07d7: 12 25 f6       :  lcall __cmp_i4
co:07da: 60 07          :  jz ?100
                        : 
co:07dc: 7e f3          :  mov R6,#243
co:07de: 7f 00          :  mov R7,#0
co:07e0: 02 0a 79       :  ljmp ?86
                        : ?100:
                        :>
                        :>  match_socket.state=TCP_EST;  // Connection now established
co:07e3: 90 00 09       :  mov DPTR,#_match_socket+1
co:07e6: 74 02          :  mov A,#2
co:07e8: f0             :  movx @DPTR,A
                        :>
                        :>  match_socket.sack.u+=dlen;
co:07e9: ae 2e          :  mov R6,?state_machine_TCP_dlen
co:07eb: af 2f          :  mov R7,?state_machine_TCP_dlen+1
co:07ed: ab 07          :  mov R3,AR7
co:07ef: aa 06          :  mov R2,AR6
co:07f1: e4             :  clr A
co:07f2: f9             :  mov R1,A
co:07f3: f8             :  mov R0,A
co:07f4: 90 00 18       :  mov DPTR,#_match_socket+16
co:07f7: 12 01 71       :  lcall __ld_dptr_r47
co:07fa: 12 2a f6       :  lcall __add_i4
co:07fd: 90 00 18       :  mov DPTR,#_match_socket+16
co:0800: 12 04 f1       :  lcall __st_dptr_r47
                        :>#ifdef PHY_ETH
                        :>  Read_Frame_xdata_Phy(rcv_buf,dlen);  // Read Sender's Data, if any as Physical copy
co:0803: ac 2e          :  mov R4,?state_machine_TCP_dlen
co:0805: ad 2f          :  mov R5,?state_machine_TCP_dlen+1
co:0807: 7e 02          :  mov R6,#((_rcv_buf)>>8)&255
co:0809: 7f 10          :  mov R7,#(_rcv_buf)&255
co:080b: 12 26 5c       :  lcall _Read_Frame_xdata_Phy
                        :>#else
                        :>  rcv_buf=Get_Frame_xdata_pointer();  // Why copy, if it is already there...
                        :>#endif
                        :>
                        :>
                        :>  rcv_len=dlen;    // remember size of read data...
co:080e: ae 2e          :  mov R6,?state_machine_TCP_dlen
co:0810: af 2f          :  mov R7,?state_machine_TCP_dlen+1
co:0812: 90 02 0e       :  mov DPTR,#_rcv_len
co:0815: 12 0a c1       :  lcall __st_dptr_r67
                        :>
                        :>  // Matching 3 Sockets? -> Clear ALL
                        :>  if(match_socket.buf_outsize3 && hframe.tcp_hdr.ack.u==match_socket.sseq_3){
co:0818: 90 00 22       :  mov DPTR,#_match_socket+26
co:081b: 12 0a af       :  lcall __ld_dptr_r67
co:081e: ee             :  mov A,R6
co:081f: 4f             :  orl A,R7
co:0820: 60 45          :  jz ?102
co:0822: 90 00 24       :  mov DPTR,#_match_socket+28
co:0825: 12 01 65       :  lcall __ld_dptr_r03
co:0828: 90 01 d6       :  mov DPTR,#_hframe+8
co:082b: 12 01 71       :  lcall __ld_dptr_r47
co:082e: c3             :  clr C
co:082f: 12 25 f6       :  lcall __cmp_i4
co:0832: 70 33          :  jnz ?102
                        : 
co:0834: 90 00 28       :  mov DPTR,#_match_socket+32
co:0837: 12 0a af       :  lcall __ld_dptr_r67
co:083a: 12 2c d6       :  lcall _free_tx_buf
                        :>   //putsl("<M123>");
                        :>   free_tx_buf(match_socket.p_outbuf3);   
                        :>   free_tx_buf(match_socket.p_outbuf2);   
co:083d: 90 00 30       :  mov DPTR,#_match_socket+40
co:0840: 12 0a af       :  lcall __ld_dptr_r67
co:0843: 12 2c d6       :  lcall _free_tx_buf
                        :>   free_tx_buf(match_socket.p_outbuf1);   
co:0846: 90 00 38       :  mov DPTR,#_match_socket+48
co:0849: 12 0a af       :  lcall __ld_dptr_r67
co:084c: 12 2c d6       :  lcall _free_tx_buf
                        :>   match_socket.buf_outsize3=0;
co:084f: 90 00 22       :  mov DPTR,#_match_socket+26
co:0852: e4             :  clr A
co:0853: f0             :  movx @DPTR,A
co:0854: a3             :  inc DPTR
co:0855: f0             :  movx @DPTR,A
                        :>   match_socket.buf_outsize2=0;
co:0856: 90 00 2a       :  mov DPTR,#_match_socket+34
co:0859: e4             :  clr A
co:085a: f0             :  movx @DPTR,A
co:085b: a3             :  inc DPTR
co:085c: f0             :  movx @DPTR,A
                        :>   match_socket.buf_outsize1=0;
co:085d: 90 00 32       :  mov DPTR,#_match_socket+42
co:0860: e4             :  clr A
co:0861: f0             :  movx @DPTR,A
co:0862: a3             :  inc DPTR
co:0863: f0             :  movx @DPTR,A
                        :>
                        :>  // Matching Sockets 2 and 1: Free 1,2, Shift 3 to 1
                        :>  }else if(match_socket.buf_outsize2 && hframe.tcp_hdr.ack.u==match_socket.sseq_2){
co:0864: 02 09 3e       :  ljmp ?103
                        : ?102:
                        : 
co:0867: 90 00 2a       :  mov DPTR,#_match_socket+34
co:086a: 12 0a af       :  lcall __ld_dptr_r67
co:086d: ee             :  mov A,R6
co:086e: 4f             :  orl A,R7
co:086f: 60 59          :  jz ?104
co:0871: 90 00 2c       :  mov DPTR,#_match_socket+36
co:0874: 12 01 65       :  lcall __ld_dptr_r03
co:0877: 90 01 d6       :  mov DPTR,#_hframe+8
co:087a: 12 01 71       :  lcall __ld_dptr_r47
co:087d: c3             :  clr C
co:087e: 12 25 f6       :  lcall __cmp_i4
co:0881: 70 47          :  jnz ?104
                        : 
co:0883: 90 00 30       :  mov DPTR,#_match_socket+40
co:0886: 12 0a af       :  lcall __ld_dptr_r67
co:0889: 12 2c d6       :  lcall _free_tx_buf
                        :>   //putsl("<M12>");
                        :>   free_tx_buf(match_socket.p_outbuf2);   
                        :>   free_tx_buf(match_socket.p_outbuf1);   
co:088c: 90 00 38       :  mov DPTR,#_match_socket+48
co:088f: 12 0a af       :  lcall __ld_dptr_r67
co:0892: 12 2c d6       :  lcall _free_tx_buf
                        :>
                        :>   match_socket.sseq_1=match_socket.sseq_3;
co:0895: 90 00 24       :  mov DPTR,#_match_socket+28
co:0898: 12 01 71       :  lcall __ld_dptr_r47
co:089b: 90 00 34       :  mov DPTR,#_match_socket+44
co:089e: 12 04 f1       :  lcall __st_dptr_r47
                        :>   match_socket.p_outbuf1=match_socket.p_outbuf3;
co:08a1: 90 00 28       :  mov DPTR,#_match_socket+32
co:08a4: 12 0a af       :  lcall __ld_dptr_r67
co:08a7: 90 00 38       :  mov DPTR,#_match_socket+48
co:08aa: 12 0a c1       :  lcall __st_dptr_r67
                        :>   match_socket.buf_outsize1=match_socket.buf_outsize3;
co:08ad: 90 00 22       :  mov DPTR,#_match_socket+26
co:08b0: 12 0a af       :  lcall __ld_dptr_r67
co:08b3: 90 00 32       :  mov DPTR,#_match_socket+42
co:08b6: 12 0a c1       :  lcall __st_dptr_r67
                        :>   
                        :>   match_socket.buf_outsize2=0;
co:08b9: 90 00 2a       :  mov DPTR,#_match_socket+34
co:08bc: e4             :  clr A
co:08bd: f0             :  movx @DPTR,A
co:08be: a3             :  inc DPTR
co:08bf: f0             :  movx @DPTR,A
                        :>   match_socket.buf_outsize3=0;
co:08c0: 90 00 22       :  mov DPTR,#_match_socket+26
co:08c3: e4             :  clr A
co:08c4: f0             :  movx @DPTR,A
co:08c5: a3             :  inc DPTR
co:08c6: f0             :  movx @DPTR,A
                        :>   
                        :>  // Matching Sockets 1 Free 1, Shift 2 to 1, 3 to 2
                        :>  }else if(match_socket.buf_outsize1 && hframe.tcp_hdr.ack.u==match_socket.sseq_1){
co:08c7: 02 09 3e       :  ljmp ?105
                        : ?104:
                        : 
co:08ca: 90 00 32       :  mov DPTR,#_match_socket+42
co:08cd: 12 0a af       :  lcall __ld_dptr_r67
co:08d0: ee             :  mov A,R6
co:08d1: 4f             :  orl A,R7
co:08d2: 60 6a          :  jz ?106
co:08d4: 90 00 34       :  mov DPTR,#_match_socket+44
co:08d7: 12 01 65       :  lcall __ld_dptr_r03
co:08da: 90 01 d6       :  mov DPTR,#_hframe+8
co:08dd: 12 01 71       :  lcall __ld_dptr_r47
co:08e0: c3             :  clr C
co:08e1: 12 25 f6       :  lcall __cmp_i4
co:08e4: 70 58          :  jnz ?106
                        : 
co:08e6: 90 00 38       :  mov DPTR,#_match_socket+48
co:08e9: 12 0a af       :  lcall __ld_dptr_r67
co:08ec: 12 2c d6       :  lcall _free_tx_buf
                        :>   //putsl("<M1>");
                        :>   free_tx_buf(match_socket.p_outbuf1);   
                        :>
                        :>   match_socket.sseq_1=match_socket.sseq_2;
co:08ef: 90 00 2c       :  mov DPTR,#_match_socket+36
co:08f2: 12 01 71       :  lcall __ld_dptr_r47
co:08f5: 90 00 34       :  mov DPTR,#_match_socket+44
co:08f8: 12 04 f1       :  lcall __st_dptr_r47
                        :>   match_socket.p_outbuf1=match_socket.p_outbuf2;
co:08fb: 90 00 30       :  mov DPTR,#_match_socket+40
co:08fe: 12 0a af       :  lcall __ld_dptr_r67
co:0901: 90 00 38       :  mov DPTR,#_match_socket+48
co:0904: 12 0a c1       :  lcall __st_dptr_r67
                        :>   match_socket.buf_outsize1=match_socket.buf_outsize2;
co:0907: 90 00 2a       :  mov DPTR,#_match_socket+34
co:090a: 12 0a af       :  lcall __ld_dptr_r67
co:090d: 90 00 32       :  mov DPTR,#_match_socket+42
co:0910: 12 0a c1       :  lcall __st_dptr_r67
                        :>
                        :>   match_socket.sseq_2=match_socket.sseq_3;
co:0913: 90 00 24       :  mov DPTR,#_match_socket+28
co:0916: 12 01 71       :  lcall __ld_dptr_r47
co:0919: 90 00 2c       :  mov DPTR,#_match_socket+36
co:091c: 12 04 f1       :  lcall __st_dptr_r47
                        :>   match_socket.p_outbuf2=match_socket.p_outbuf3;
co:091f: 90 00 28       :  mov DPTR,#_match_socket+32
co:0922: 12 0a af       :  lcall __ld_dptr_r67
co:0925: 90 00 30       :  mov DPTR,#_match_socket+40
co:0928: 12 0a c1       :  lcall __st_dptr_r67
                        :>   match_socket.buf_outsize2=match_socket.buf_outsize3;
co:092b: 90 00 22       :  mov DPTR,#_match_socket+26
co:092e: 12 0a af       :  lcall __ld_dptr_r67
co:0931: 90 00 2a       :  mov DPTR,#_match_socket+34
co:0934: 12 0a c1       :  lcall __st_dptr_r67
                        :>   
                        :>   match_socket.buf_outsize3=0;
co:0937: 90 00 22       :  mov DPTR,#_match_socket+26
co:093a: e4             :  clr A
co:093b: f0             :  movx @DPTR,A
co:093c: a3             :  inc DPTR
co:093d: f0             :  movx @DPTR,A
                        :>   
                        :>  }
                        : ?106:
                        : ?105:
                        : ?103:
                        :>
                        :>
                        :>  // Frame does not contain a TFIN so simply acknowledge it, if data od SYN received
                        :>  if(!(hframe.tcp_hdr.flags&TFIN)){
co:093e: 90 01 db       :  mov DPTR,#_hframe+13
co:0941: e0             :  movx A,@DPTR
co:0942: ff             :  mov R7,A
co:0943: 54 01          :  anl A,#1
co:0945: ff             :  mov R7,A
co:0946: 70 20          :  jnz ?108
                        : 
co:0948: e5 2e          :  mov A,?state_machine_TCP_dlen
co:094a: 45 2f          :  orl A,?state_machine_TCP_dlen+1
co:094c: 70 0d          :  jnz ?112
co:094e: 90 01 db       :  mov DPTR,#_hframe+13
co:0951: e0             :  movx A,@DPTR
co:0952: ff             :  mov R7,A
co:0953: 54 02          :  anl A,#2
co:0955: ff             :  mov R7,A
co:0956: 70 03          :  jnz ?_53
co:0958: 02 09 ad       :  ljmp ?109
                        : ?_53:
                        : ?112:
                        :>   if(dlen || (hframe.tcp_hdr.flags&TSYN)) send_match_ok_TCP(0,0,TACK); // Frame OK: Acknowledge immed
co:095b: 7b 10          :  mov R3,#16
co:095d: e4             :  clr A
co:095e: fc             :  mov R4,A
co:095f: fd             :  mov R5,A
co:0960: e4             :  clr A
co:0961: fe             :  mov R6,A
co:0962: ff             :  mov R7,A
co:0963: 12 04 fd       :  lcall _send_match_ok_TCP
                        :>  }else if(hframe.tcp_hdr.flags&TFIN){ // Come to here if RST and/or received
co:0966: 80 45          :  sjmp ?109
                        : ?108:
                        : 
co:0968: 90 01 db       :  mov DPTR,#_hframe+13
co:096b: e0             :  movx A,@DPTR
co:096c: ff             :  mov R7,A
co:096d: 54 01          :  anl A,#1
co:096f: ff             :  mov R7,A
co:0970: 60 3b          :  jz ?113
                        : 
co:0972: e4             :  clr A
co:0973: f8             :  mov R0,A
co:0974: f9             :  mov R1,A
co:0975: fa             :  mov R2,A
co:0976: 7b 01          :  mov R3,#1
co:0978: 90 00 18       :  mov DPTR,#_match_socket+16
co:097b: 12 01 71       :  lcall __ld_dptr_r47
co:097e: 12 2a f6       :  lcall __add_i4
co:0981: 90 00 18       :  mov DPTR,#_match_socket+16
co:0984: 12 04 f1       :  lcall __st_dptr_r47
                        :>   match_socket.sack.u++;  // Count remote FIN
                        :>   send_match_ok_TCP(0,0,TACK+TFIN+TPUSH); // Acknowledge + FIN
co:0987: 7b 19          :  mov R3,#25
co:0989: e4             :  clr A
co:098a: fc             :  mov R4,A
co:098b: fd             :  mov R5,A
co:098c: e4             :  clr A
co:098d: fe             :  mov R6,A
co:098e: ff             :  mov R7,A
co:098f: 12 04 fd       :  lcall _send_match_ok_TCP
                        :>   match_socket.sseq.u++;  // Count our FIN after sending!...
co:0992: e4             :  clr A
co:0993: f8             :  mov R0,A
co:0994: f9             :  mov R1,A
co:0995: fa             :  mov R2,A
co:0996: 7b 01          :  mov R3,#1
co:0998: 90 00 1c       :  mov DPTR,#_match_socket+20
co:099b: 12 01 71       :  lcall __ld_dptr_r47
co:099e: 12 2a f6       :  lcall __add_i4
co:09a1: 90 00 1c       :  mov DPTR,#_match_socket+20
co:09a4: 12 04 f1       :  lcall __st_dptr_r47
                        :>   match_socket.state=TCP_FINCON; // FIN Confirmed
co:09a7: 90 00 09       :  mov DPTR,#_match_socket+1
co:09aa: 74 04          :  mov A,#4
co:09ac: f0             :  movx @DPTR,A
                        :>  }  
                        : ?113:
                        : ?109:
                        :>
                        :>  // Only if nothing available reset retry_counter...
                        :>  if(!match_socket.buf_outsize1) match_socket.retry_cnt=0;
co:09ad: 90 00 32       :  mov DPTR,#_match_socket+42
co:09b0: 12 0a af       :  lcall __ld_dptr_r67
co:09b3: ee             :  mov A,R6
co:09b4: 4f             :  orl A,R7
co:09b5: 70 05          :  jnz ?115
                        : 
co:09b7: 90 00 20       :  mov DPTR,#_match_socket+24
co:09ba: e4             :  clr A
co:09bb: f0             :  movx @DPTR,A
                        : ?115:
                        :>  return EVENT_TCP_DATARECEIVED;
co:09bc: 7e f5          :  mov R6,#245
co:09be: 7f 00          :  mov R7,#0
co:09c0: 02 0a 79       :  ljmp ?86
                        : ?117:
                        :>
                        :> case TCP_FINSENT:
                        :>  //puts("<FINSENT>");
                        :>  if(!(hframe.tcp_hdr.flags&TACK)) break;
co:09c3: 90 01 db       :  mov DPTR,#_hframe+13
co:09c6: e0             :  movx A,@DPTR
co:09c7: ff             :  mov R7,A
co:09c8: 54 10          :  anl A,#16
co:09ca: ff             :  mov R7,A
co:09cb: 70 03          :  jnz ?118
                        : 
co:09cd: 02 0a 5c       :  ljmp ?90
                        : ?118:
                        :>  // printf("Flags: %u\n",hframe.tcp_hdr.flags);
                        :>  // printf("<<M:%ld H:%lx >>",match_socket.sack.u,hframe.tcp_hdr.seq.u);
                        :>  if(match_socket.sack.u!=hframe.tcp_hdr.seq.u) return EVENT_TCP_OUTOFBOUNDS; // Ignore-out-of-bounds 
co:09d0: 90 01 d2       :  mov DPTR,#_hframe+4
co:09d3: 12 01 65       :  lcall __ld_dptr_r03
co:09d6: 90 00 18       :  mov DPTR,#_match_socket+16
co:09d9: 12 01 71       :  lcall __ld_dptr_r47
co:09dc: c3             :  clr C
co:09dd: 12 25 f6       :  lcall __cmp_i4
co:09e0: 60 07          :  jz ?120
                        : 
co:09e2: 7e f3          :  mov R6,#243
co:09e4: 7f 00          :  mov R7,#0
co:09e6: 02 0a 79       :  ljmp ?86
                        : ?120:
                        :>  //puts("<Wait3LASTACK>");
                        :>  if(hframe.tcp_hdr.flags&TFIN){    // Fin accepted by Remote!
co:09e9: 90 01 db       :  mov DPTR,#_hframe+13
co:09ec: e0             :  movx A,@DPTR
co:09ed: ff             :  mov R7,A
co:09ee: 54 01          :  anl A,#1
co:09f0: ff             :  mov R7,A
co:09f1: 60 28          :  jz ?122
                        : 
co:09f3: e4             :  clr A
co:09f4: f8             :  mov R0,A
co:09f5: f9             :  mov R1,A
co:09f6: fa             :  mov R2,A
co:09f7: 7b 01          :  mov R3,#1
co:09f9: 90 00 18       :  mov DPTR,#_match_socket+16
co:09fc: 12 01 71       :  lcall __ld_dptr_r47
co:09ff: 12 2a f6       :  lcall __add_i4
co:0a02: 90 00 18       :  mov DPTR,#_match_socket+16
co:0a05: 12 04 f1       :  lcall __st_dptr_r47
                        :>   match_socket.sack.u++;    // Count remote FIN
                        :>   send_match_ok_TCP(0,0,TACK);   // Frame OK: Acknowledge immediatelly!
co:0a08: 7b 10          :  mov R3,#16
co:0a0a: e4             :  clr A
co:0a0b: fc             :  mov R4,A
co:0a0c: fd             :  mov R5,A
co:0a0d: e4             :  clr A
co:0a0e: fe             :  mov R6,A
co:0a0f: ff             :  mov R7,A
co:0a10: 12 04 fd       :  lcall _send_match_ok_TCP
                        :>   free_match_socket(); // Free Buffers if allocated... 
co:0a13: 12 2c 20       :  lcall _free_match_socket
                        :>   match_socket.state=TCP_CLOSED;  // Connection ends NOW
co:0a16: 90 00 09       :  mov DPTR,#_match_socket+1
co:0a19: e4             :  clr A
co:0a1a: f0             :  movx @DPTR,A
                        :>   //puts("<FINAL ACK SENT CLOSED>");
                        :>  }
                        : ?122:
                        :>  match_socket.retry_cnt=0;
co:0a1b: 90 00 20       :  mov DPTR,#_match_socket+24
co:0a1e: e4             :  clr A
co:0a1f: f0             :  movx @DPTR,A
                        :>  return EVENT_TCP_WAITLASTACK;
co:0a20: 7e fb          :  mov R6,#251
co:0a22: 7f 00          :  mov R7,#0
co:0a24: 02 0a 79       :  ljmp ?86
                        : ?124:
                        :>    
                        :> case TCP_FINCON: // Accept one last ACK
                        :>  if(!(hframe.tcp_hdr.flags&TACK)) break;
co:0a27: 90 01 db       :  mov DPTR,#_hframe+13
co:0a2a: e0             :  movx A,@DPTR
co:0a2b: ff             :  mov R7,A
co:0a2c: 54 10          :  anl A,#16
co:0a2e: ff             :  mov R7,A
                        : 
co:0a2f: 60 2b          :  jz ?90
                        :>  if(match_socket.sack.u!=hframe.tcp_hdr.seq.u) return EVENT_TCP_OUTOFBOUNDS; // Ignore-out-of-bounds 
co:0a31: 90 01 d2       :  mov DPTR,#_hframe+4
co:0a34: 12 01 65       :  lcall __ld_dptr_r03
co:0a37: 90 00 18       :  mov DPTR,#_match_socket+16
co:0a3a: 12 01 71       :  lcall __ld_dptr_r47
co:0a3d: c3             :  clr C
co:0a3e: 12 25 f6       :  lcall __cmp_i4
co:0a41: 60 06          :  jz ?127
                        : 
co:0a43: 7e f3          :  mov R6,#243
co:0a45: 7f 00          :  mov R7,#0
co:0a47: 80 30          :  sjmp ?86
                        : ?127:
                        :> 
                        :>  match_socket.state=TCP_CLOSED;  // Connection ends NOW
co:0a49: 90 00 09       :  mov DPTR,#_match_socket+1
co:0a4c: e4             :  clr A
co:0a4d: f0             :  movx @DPTR,A
                        :>  free_match_socket(); // Free Buffers if allocated... 
co:0a4e: 12 2c 20       :  lcall _free_match_socket
                        :>  // puts("<LAST FIN ACKNOWLEDGED>");
                        :>  match_socket.retry_cnt=0;
co:0a51: 90 00 20       :  mov DPTR,#_match_socket+24
co:0a54: e4             :  clr A
co:0a55: f0             :  movx @DPTR,A
                        :>  return EVENT_TCP_CLOSED;      
co:0a56: 7e fc          :  mov R6,#252
co:0a58: 7f 00          :  mov R7,#0
co:0a5a: 80 1d          :  sjmp ?86
                        : ?89:
                        : ?90:
                        :> }
                        :>
                        :> free_match_socket(); // Free Buffers if allocated... 
co:0a5c: 12 2c 20       :  lcall _free_match_socket
                        :> match_socket.state=TCP_CLOSED;
co:0a5f: 90 00 09       :  mov DPTR,#_match_socket+1
co:0a62: e4             :  clr A
co:0a63: f0             :  movx @DPTR,A
                        :>#ifdef PHY_ETH
                        :> send_incomming_reset_TCP(dlen,&remote_mac,remote_ip.ipl);  // Denie further request!
co:0a64: 90 02 e0       :  mov DPTR,#_remote_ip
co:0a67: 12 01 65       :  lcall __ld_dptr_r03
co:0a6a: 7c 02          :  mov R4,#((_remote_mac)>>8)&255
co:0a6c: 7d 08          :  mov R5,#(_remote_mac)&255
co:0a6e: ae 2e          :  mov R6,?state_machine_TCP_dlen
co:0a70: af 2f          :  mov R7,?state_machine_TCP_dlen+1
co:0a72: 12 20 a2       :  lcall _send_incomming_reset_TCP
                        :>#else
                        :> send_incomming_reset_TCP(dlen,remote_ip.ipl);  // Denie further request!
                        :>#endif
                        :>
                        :> return EVENT_TCP_ILLEGALFRAME; // Denie illegal frames;
co:0a75: 7e f8          :  mov R6,#248
co:0a77: 7f 00          :  mov R7,#0
                        : ?86:
co:0a79: 22             :  ret
                        : ?i129: ; void (*code [5])()
co:0a7a: 07 1a          :  .dc.w ?92
co:0a7c: 07 a8          :  .dc.w ?95
co:0a7e: 07 a8          :  .dc.w ?95
co:0a80: 09 c3          :  .dc.w ?117
co:0a82: 0a 27          :  .dc.w ?124
                        : ; end of function state_machine_TCP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .export _final_timeout_socket ; unsigned int final_timeout_socket(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __final_timeout_socket
                        : _final_timeout_socket: ; unsigned int final_timeout_socket(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uint final_timeout_socket();
                        :>*
                        :>* Socket has definitely timed out. Free it for other users...
                        :>**********************************************************************************/
                        :>uint final_timeout_socket(void){
co:0a84: 90 00 08       :  mov DPTR,#_match_socket
co:0a87: e0             :  movx A,@DPTR
co:0a88: ff             :  mov R7,A
co:0a89: bf 02 19       :  cjne R7,#2,?131
                        :>
                        :> //printf("TIMEOUT match_socket_type: %u\n",match_socket.socket_type);
                        :> if(match_socket.socket_type==SOCKET_TCP){
co:0a8c: 7b 04          :  mov R3,#4
co:0a8e: e4             :  clr A
co:0a8f: fc             :  mov R4,A
co:0a90: fd             :  mov R5,A
co:0a91: e4             :  clr A
co:0a92: fe             :  mov R6,A
co:0a93: ff             :  mov R7,A
co:0a94: 12 04 fd       :  lcall _send_match_ok_TCP
                        :>#ifdef USE_TCP_CLIENT
                        :>     if(match_socket.state<ARPSENT) 
                        :>#endif
                        :>  send_match_ok_TCP(0,0,TRST); // Reset this socket!
                        :>  free_match_socket(); // Free Buffers if allocated... 
co:0a97: 12 2c 20       :  lcall _free_match_socket
                        :>  //puts("<TIMEOUT RESET>");
                        :>  match_socket.state=TCP_CLOSED;  // ==0 (for UDP as well)
co:0a9a: 90 00 09       :  mov DPTR,#_match_socket+1
co:0a9d: e4             :  clr A
co:0a9e: f0             :  movx @DPTR,A
                        :>  return EVENT_TCP_TIMEOUT;
co:0a9f: 7e fa          :  mov R6,#250
co:0aa1: 7f 00          :  mov R7,#0
co:0aa3: 80 09          :  sjmp ?130
                        : ?131:
                        :> }
                        :> match_socket.state=0;  // ==0 (for UDP as well, but no action required)
co:0aa5: 90 00 09       :  mov DPTR,#_match_socket+1
co:0aa8: e4             :  clr A
co:0aa9: f0             :  movx @DPTR,A
                        :> return EVENT_SOCKET_TIMEOUT;
co:0aaa: 7e d0          :  mov R6,#208
co:0aac: 7f 00          :  mov R7,#0
                        : ?130:
co:0aae: 22             :  ret
                        : ; end of function final_timeout_socket
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _retransmit_socket ; unsigned int retransmit_socket(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __retransmit_socket
                        : _retransmit_socket: ; unsigned int retransmit_socket(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uint retransmit_socket();
                        :>*
                        :>* Socket requires a retransmition
                        :>**********************************************************************************/
                        :>uint retransmit_socket(void){
co:005d: 90 00 08       :  mov DPTR,#_match_socket
co:0060: e0             :  movx A,@DPTR
co:0061: ff             :  mov R7,A
co:0062: bf 02 02       :  cjne R7,#2,?_63
co:0065: 80 03          :  sjmp ?_64
                        : ?_63:
co:0067: 02 01 28       :  ljmp ?134
                        : ?_64:
                        :> unsigned long hseq;
                        :>
                        :> // printf(" >>--RE-TX:%u>>",match_socket.sremote_port);
                        :>
                        :> if(match_socket.socket_type==SOCKET_TCP){
co:006a: 90 00 09       :  mov DPTR,#_match_socket+1
co:006d: e0             :  movx A,@DPTR
co:006e: fd             :  mov R5,A
co:006f: 7f 01          :  mov R7,#1
co:0071: c3             :  clr C
co:0072: ed             :  mov A,R5
co:0073: 9f             :  subb A,R7
co:0074: 50 03          :  jnc ?_65
co:0076: 02 01 58       :  ljmp ?135
                        : ?_65:
co:0079: 7f 04          :  mov R7,#4
co:007b: d3             :  setb C
co:007c: ed             :  mov A,R5
co:007d: 9f             :  subb A,R7
co:007e: 40 03          :  jc ?_66
co:0080: 02 01 58       :  ljmp ?135
                        : ?_66:
co:0083: 90 01 5b       :  mov DPTR,#?i144-2
co:0086: ed             :  mov A,R5
co:0087: 2d             :  add A,R5
co:0088: 50 02          :  jnc ?_67
co:008a: 05 83          :  inc DPH
                        : ?_67:
co:008c: 25 82          :  add A,DPL
co:008e: f5 82          :  mov DPL,A
co:0090: 50 02          :  jnc ?_68
co:0092: 05 83          :  inc DPH
                        : ?_68:
co:0094: 74 01          :  mov A,#1
co:0096: 93             :  movc A,@A+DPTR
co:0097: c0 e0          :  push ACC
co:0099: e4             :  clr A
co:009a: 93             :  movc A,@A+DPTR
co:009b: c0 e0          :  push ACC
co:009d: 22             :  ret
                        :>  switch(match_socket.state){
                        : ?139:
                        :>  case TCP_SYNCON:    // Timeout after SYN-confirmed->Transmit Confirmation again
                        :>   send_match_ok_TCP(0,0,TSYN+TACK); // Transmit Again
co:009e: 7b 12          :  mov R3,#18
co:00a0: e4             :  clr A
co:00a1: fc             :  mov R4,A
co:00a2: fd             :  mov R5,A
co:00a3: e4             :  clr A
co:00a4: fe             :  mov R6,A
co:00a5: ff             :  mov R7,A
co:00a6: 12 04 fd       :  lcall _send_match_ok_TCP
                        :>   // puts("<TCP RETRANSMIT TSYN+TACK>");
                        :>   return EVENT_TCP_RETRANS;
co:00a9: 7e f1          :  mov R6,#241
co:00ab: 7f 00          :  mov R7,#0
co:00ad: 02 01 5c       :  ljmp ?133
                        : ?140:
                        :>
                        :>  case TCP_EST:     // Timeout in an established Connection
                        :>
                        :>   if(match_socket.buf_outsize1){  // Something un-acknowledged?
co:00b0: 90 00 32       :  mov DPTR,#_match_socket+42
co:00b3: 12 0a af       :  lcall __ld_dptr_r67
co:00b6: ee             :  mov A,R6
co:00b7: 4f             :  orl A,R7
co:00b8: 60 51          :  jz ?141
                        :  ; variable 'hseq' allocated as 'auto'
                        : 
co:00ba: 90 00 1c       :  mov DPTR,#_match_socket+20
co:00bd: e0             :  movx A,@DPTR
co:00be: f5 23          :  mov ?retransmit_socket_hseq,A
co:00c0: a3             :  inc DPTR
co:00c1: e0             :  movx A,@DPTR
co:00c2: f5 24          :  mov ?retransmit_socket_hseq+1,A
co:00c4: a3             :  inc DPTR
co:00c5: e0             :  movx A,@DPTR
co:00c6: f5 25          :  mov ?retransmit_socket_hseq+2,A
co:00c8: a3             :  inc DPTR
co:00c9: e0             :  movx A,@DPTR
co:00ca: f5 26          :  mov ?retransmit_socket_hseq+3,A
                        :>    //puts("<TCP RETRANSMIT EST>");
                        :>    // Seq. represents the sent data, so for resend subtract the block from seq, afterwards ad it...
                        :>    hseq=match_socket.sseq.u; // Save current Sequ (Pos.)
                        :>    // Rewind to Pos. before BUF1 was sent
                        :>
                        :>    match_socket.sseq.u=match_socket.sseq_1-match_socket.buf_outsize1; // 32 Bit operation - This must
co:00cc: 90 00 32       :  mov DPTR,#_match_socket+42
co:00cf: 12 0a af       :  lcall __ld_dptr_r67
co:00d2: ab 07          :  mov R3,AR7
co:00d4: aa 06          :  mov R2,AR6
co:00d6: e4             :  clr A
co:00d7: f9             :  mov R1,A
co:00d8: f8             :  mov R0,A
co:00d9: 90 00 34       :  mov DPTR,#_match_socket+44
co:00dc: 12 01 71       :  lcall __ld_dptr_r47
co:00df: 12 24 c9       :  lcall __sub_i4
co:00e2: 90 00 1c       :  mov DPTR,#_match_socket+20
co:00e5: 12 04 f1       :  lcall __st_dptr_r47
                        :>    send_match_ok_TCP(match_socket.p_outbuf1,match_socket.buf_outsize1,TACK+TPUSH);
co:00e8: 7b 18          :  mov R3,#24
co:00ea: 90 00 32       :  mov DPTR,#_match_socket+42
co:00ed: 12 06 c7       :  lcall __ld_dptr_r45
co:00f0: 90 00 38       :  mov DPTR,#_match_socket+48
co:00f3: 12 0a af       :  lcall __ld_dptr_r67
co:00f6: 12 04 fd       :  lcall _send_match_ok_TCP
                        :>    match_socket.sseq.u=hseq;  // Restore old Pointer
co:00f9: 74 23          :  mov A,#?retransmit_socket_hseq
co:00fb: 12 2c c8       :  lcall __ld_a_r47
co:00fe: 90 00 1c       :  mov DPTR,#_match_socket+20
co:0101: 12 04 f1       :  lcall __st_dptr_r47
                        :>    return EVENT_TCP_RETRANS;
co:0104: 7e f1          :  mov R6,#241
co:0106: 7f 00          :  mov R7,#0
co:0108: 02 01 5c       :  ljmp ?133
                        : ?141:
                        :>   }
                        :>
                        :>   // For an active socket, send *live signal'
                        :>#ifdef USE_TCP_CLIENT
                        :>   if(match_socket.tcp_client_flag){
                        :>        send_match_ok_TCP(0,0,TACK+TPUSH);
                        :>putsl("<IR>");
                        :>   }
                        :>#endif
                        :>
                        :>   // puts("<TCP RT IDLE IDLE>"); 
                        :>   // Stack is idle: All ok
                        :>   match_socket.timer=TCP_IDLE_RETRIES;  // Socket OK, LONG TIMEOUT!!!
co:010b: 90 00 21       :  mov DPTR,#_match_socket+25
co:010e: 74 28          :  mov A,#40
co:0110: f0             :  movx @DPTR,A
                        :>
                        :>   return 0;
co:0111: e4             :  clr A
co:0112: fe             :  mov R6,A
co:0113: ff             :  mov R7,A
co:0114: 02 01 5c       :  ljmp ?133
                        : ?143:
                        :>
                        :>  case TCP_FINCON:
                        :>  case TCP_FINSENT:
                        :>   send_match_ok_TCP(0,0,TFIN+TACK+TPUSH); // Transmit, without any data after FIN_CON...
co:0117: 7b 19          :  mov R3,#25
co:0119: e4             :  clr A
co:011a: fc             :  mov R4,A
co:011b: fd             :  mov R5,A
co:011c: e4             :  clr A
co:011d: fe             :  mov R6,A
co:011e: ff             :  mov R7,A
co:011f: 12 04 fd       :  lcall _send_match_ok_TCP
                        :>   // puts("<TCP FIN RETRANSMIT>");
                        :>   return EVENT_TCP_RETRANS;
co:0122: 7e f1          :  mov R6,#241
co:0124: 7f 00          :  mov R7,#0
co:0126: 80 34          :  sjmp ?133
                        :>   
                        :>#ifdef USE_TCP_CLIENT
                        :>#ifdef PHY_ETH
                        :>  case ARPSENT:
                        :>   send_request_ARP(match_socket.sremote_ip);
                        :>   // puts("<(TCP) ARP RETRANSMIT>");
                        :>   return EVENT_TCP_RETRANS;
                        :>
                        :>  case ARPREC:
                        :>   // puts("<(TCP) ARP-REQUEST RECEIVED!!!>");
                        :>
                        :>   // Ports already setup!
                        :>   match_socket.sseq.w.h_word=net_service_cnt;   // Time ascending...
                        :>   match_socket.sseq.w.l_word=0;    // Our relative Pointer (for HTTP, -1 due to SYNC)
                        :>   match_socket.state=TCP_SYNSENT;  // SYN confirmed with SYN+ACK
                        :>#endif // PHY_ETH
                        :>
                        :>  case TCP_SYNSENT:
                        :>   send_match_ok_TCP(0,0,TSYN); // Initiate Connection with a SYN
                        :>   // puts("<ACTIVE SYN SENT>");
                        :>   return 0; // Only 1 Try, No Retransmition!
                        :>#endif   
                        :>  }
                        :> }
                        : ?134:
                        :>
                        :>#ifdef USE_UDP_CLIENT
                        :>#ifdef PHY_ETH
                        :>     else if(match_socket.socket_type==SOCKET_UDP){
co:0128: 90 00 08       :  mov DPTR,#_match_socket
co:012b: e0             :  movx A,@DPTR
co:012c: ff             :  mov R7,A
co:012d: bf 01 28       :  cjne R7,#1,?145
                        : 
co:0130: 90 00 09       :  mov DPTR,#_match_socket+1
co:0133: e0             :  movx A,@DPTR
co:0134: ff             :  mov R7,A
co:0135: 64 06          :  xrl A,#6
                        :>         switch(match_socket.state){
co:0137: 70 0f          :  jnz ?147
                        :>        case ARPSENT:
                        :>            send_request_ARP(match_socket.sremote_ip);
co:0139: 90 00 10       :  mov DPTR,#_match_socket+8
co:013c: 12 01 71       :  lcall __ld_dptr_r47
co:013f: 12 27 6b       :  lcall _send_request_ARP
                        :>            // puts("<(UDP) ARP RETRANSMIT>");
                        :>            return EVENT_UDP_ARPRETRANS;
co:0142: 7e e3          :  mov R6,#227
co:0144: 7f 00          :  mov R7,#0
co:0146: 80 14          :  sjmp ?133
                        : ?147:
                        :>
                        :>        default:
                        :>            // puts("<(UDP) TIMEOUT with ARP-REQUEST RECEIVED!!!>");
                        :>
                        :>            match_socket.retry_cnt=0;                   // MUST be UDP_EST ( == ARPREC) Never close an
co:0148: 90 00 20       :  mov DPTR,#_match_socket+24
co:014b: e4             :  clr A
co:014c: f0             :  movx @DPTR,A
                        :>            match_socket.timer=UDP_IDLE_RETRIES;        // Socket OK, LONG TIMEOUT!!! No change in sta
co:014d: 90 00 21       :  mov DPTR,#_match_socket+25
co:0150: 74 28          :  mov A,#40
co:0152: f0             :  movx @DPTR,A
                        :>            return 0;
co:0153: e4             :  clr A
co:0154: fe             :  mov R6,A
co:0155: ff             :  mov R7,A
co:0156: 80 04          :  sjmp ?133
                        : ?145:
                        : ?135:
                        :>         }
                        :>    }
                        :>#endif
                        :>#endif
                        :>
                        :>
                        :> return EVENT_SOCKET_RETRANS;
co:0158: 7e d1          :  mov R6,#209
co:015a: 7f 00          :  mov R7,#0
                        : ?133:
co:015c: 22             :  ret
                        : ?i144: ; void (*code [4])()
co:015d: 00 9e          :  .dc.w ?139
co:015f: 00 b0          :  .dc.w ?140
co:0161: 01 17          :  .dc.w ?143
co:0163: 01 17          :  .dc.w ?143
                        : ; end of function retransmit_socket
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:4 bytes
                        : 
                        :  .export _periodical_socket ; unsigned int periodical_socket(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __periodical_socket
                        : _periodical_socket: ; unsigned int periodical_socket(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uint periodical_socket();
                        :>*
                        :>* Watch non-0-state sockets periodically every 0.5 secs...
                        :>**********************************************************************************/
                        :>uint periodical_socket(void){
co:0026: 90 00 21       :  mov DPTR,#_match_socket+25
co:0029: e0             :  movx A,@DPTR
co:002a: ff             :  mov R7,A
co:002b: 1f             :  dec R7
                        :  ; variable 'h' assigned to register 'R7'
                        :> uchar h;
                        :> // First decrement sub-timer. If no 0: No Action required
                        :>
                        :> h=match_socket.timer-1;
                        :> if(h){
co:002c: ef             :  mov A,R7
co:002d: 60 0a          :  jz ?152
                        : 
co:002f: 90 00 21       :  mov DPTR,#_match_socket+25
co:0032: ef             :  mov A,R7
co:0033: f0             :  movx @DPTR,A
                        :>  match_socket.timer=h;
                        :>  return 0;
co:0034: e4             :  clr A
co:0035: fe             :  mov R6,A
co:0036: ff             :  mov R7,A
co:0037: 80 23          :  sjmp ?151
                        : ?152:
                        :> }
                        :>
                        :>
                        :> match_socket.timer=BASIC_RETRY_TIMER;
co:0039: 90 00 21       :  mov DPTR,#_match_socket+25
co:003c: 74 06          :  mov A,#6
co:003e: f0             :  movx @DPTR,A
                        :> h=match_socket.retry_cnt+1;
co:003f: 90 00 20       :  mov DPTR,#_match_socket+24
co:0042: e0             :  movx A,@DPTR
co:0043: ff             :  mov R7,A
co:0044: 0f             :  inc R7
                        :  ; variable 'h' allocated as 'auto'
co:0045: 8f 23          :  mov ?i156,R7
                        :> if(h==MAX_RETRIES){
co:0047: 74 04          :  mov A,#4
co:0049: 65 23          :  xrl A,?i156
co:004b: 70 05          :  jnz ?154
                        : 
co:004d: 12 0a 84       :  lcall _final_timeout_socket
co:0050: 80 0a          :  sjmp ?151
                        : ?154:
                        :>  return final_timeout_socket();
                        :> }else{
co:0052: af 23          :  mov R7,?i156
co:0054: 90 00 20       :  mov DPTR,#_match_socket+24
co:0057: ef             :  mov A,R7
co:0058: f0             :  movx @DPTR,A
                        :>  match_socket.retry_cnt=h; // Retry again...
                        :>  return retransmit_socket();
co:0059: 12 00 5d       :  lcall _retransmit_socket
                        : ?151:
co:005c: 22             :  ret
                        : ; end of function periodical_socket
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:1 bytes
                        : 
                        :  .export _process_TCP ; unsigned int process_TCP(unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __process_TCP
                        : _process_TCP: ; unsigned int process_TCP(unsigned int)
                        :  ; parameter 'dlen' in 'RW67' moved and assigned to local '?process_TCP_dlen'
co:01a2: 8e 29          :  mov ?process_TCP_dlen,R6
co:01a4: 8f 2a          :  mov ?process_TCP_dlen+1,R7
                        :> }
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* void process_TCP(void)
                        :>* 
                        :>* 3.rd-Level-Multiplexer
                        :>* A note for reading UDP-Datagrams: if Size is odd, last byte is in the
                        :>* HBYTE of the last Read_Frame_word_Phy()...
                        :>* Usually a TCP-frame will never come as broadcast, so treat each as more
                        :>* important than other types...
                        :>**********************************************************************************/
                        :>uint process_TCP(uint dlen){
co:01a6: 7c 00          :  mov R4,#0
co:01a8: 7d 14          :  mov R5,#20
co:01aa: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:01ac: 7f ce          :  mov R7,#(_hframe)&255
co:01ae: 12 26 5c       :  lcall _Read_Frame_xdata_Phy
                        :  ; variable 'dlen' allocated as 'auto'
                        :>     xdata UC_SOCKET *psock;
                        :>     uchar ui;
                        :> uchar ohlen;
                        :>     uint res;
                        :>
                        :> Read_Frame_xdata_Phy(hframe.bytes,20); // Read informative part of TCP header to HFRAME
                        :>
                        :>
                        :> dlen-=20;    // 
co:01b1: 74 ec          :  mov A,#236
co:01b3: 25 2a          :  add A,?process_TCP_dlen+1
co:01b5: f5 2a          :  mov ?i185+1,A
co:01b7: 74 ff          :  mov A,#255
co:01b9: 35 29          :  addc A,?process_TCP_dlen
co:01bb: f5 29          :  mov ?i185,A
                        :>
                        :> ohlen=hframe.tcp_hdr.hlen-80;
co:01bd: 90 01 da       :  mov DPTR,#_hframe+12
co:01c0: e0             :  movx A,@DPTR
co:01c1: ff             :  mov R7,A
co:01c2: 74 b0          :  mov A,#176
co:01c4: 2f             :  add A,R7
co:01c5: ff             :  mov R7,A
                        :  ; variable 'ohlen' allocated as 'auto'
co:01c6: 8f 2b          :  mov ?process_TCP_ohlen,R7
co:01c8: 80 15          :  sjmp ?159
                        : ?158:
                        :> while(ohlen){  // Eat TCP-option, if MSS: ignore silently...
co:01ca: 74 f0          :  mov A,#-16
co:01cc: 25 2b          :  add A,?process_TCP_ohlen
co:01ce: f5 2b          :  mov ?process_TCP_ohlen,A
                        :>  ohlen-=16; // ohlen = size in 32-bit-word<<4
                        :>  dlen-=4;
co:01d0: 74 fc          :  mov A,#252
co:01d2: 25 2a          :  add A,?i185+1
co:01d4: f5 2a          :  mov ?i185+1,A
co:01d6: 74 ff          :  mov A,#255
co:01d8: 35 29          :  addc A,?i185
co:01da: f5 29          :  mov ?i185,A
                        :>  Read_Frame_long_Phy(); 
co:01dc: 12 21 42       :  lcall _Read_Frame_long_Phy
                        :> }
                        : ?159:
                        : 
co:01df: e5 2b          :  mov A,?process_TCP_ohlen
co:01e1: 70 e7          :  jnz ?158
                        :  ; variable 'psock' allocated as 'auto'
                        :>
                        :>#ifdef DEBUG_REC
                        :>    // Record Data of received Frame
                        :>    record_frame('R',hframe.tcp_hdr.sport,hframe.tcp_hdr.seq.u,hframe.tcp_hdr.ack.u, hframe.tcp_hdr.fl
                        :>#endif
                        :>
                        :> // First try: Find any MATCHING socket. If one found, copy and process it...
                        :>     // This will also find a closed socket for a ACK-FIN->ACK-retransmition...
                        :>     psock=uc_socket;
co:01e3: 75 2b 02       :  mov ?process_TCP_psock,#((_uc_socket)>>8)&255
co:01e6: 75 2c 74       :  mov ?process_TCP_psock+1,#(_uc_socket)&255
                        :  ; variable 'ui' allocated as 'auto'
                        :>     for(ui=0;ui<MAX_SOCK;ui++,psock++){
co:01e9: e4             :  clr A
co:01ea: f5 2d          :  mov ?process_TCP_ui,A
                        : ?161:
                        : 
co:01ec: 85 2b 83       :  mov DPH,?process_TCP_psock
co:01ef: 85 2c 82       :  mov DPL,?process_TCP_psock+1
co:01f2: e0             :  movx A,@DPTR
co:01f3: ff             :  mov R7,A
co:01f4: bf 02 02       :  cjne R7,#2,?_76
co:01f7: 80 03          :  sjmp ?_77
                        : ?_76:
co:01f9: 02 02 9e       :  ljmp ?165
                        : ?_77:
                        :>         if(psock->socket_type==SOCKET_TCP){  // Only TCP-Sockets are of interest
co:01fc: ae 2b          :  mov R6,?process_TCP_psock
co:01fe: af 2c          :  mov R7,?process_TCP_psock+1
co:0200: 74 08          :  mov A,#8
co:0202: 2f             :  add A,R7
co:0203: ff             :  mov R7,A
co:0204: e4             :  clr A
co:0205: 3e             :  addc A,R6
co:0206: fe             :  mov R6,A
co:0207: 8e 83          :  mov DPH,R6
co:0209: 8f 82          :  mov DPL,R7
co:020b: 12 01 71       :  lcall __ld_dptr_r47
co:020e: 90 02 e0       :  mov DPTR,#_remote_ip
co:0211: 12 01 65       :  lcall __ld_dptr_r03
co:0214: c3             :  clr C
co:0215: 12 25 f6       :  lcall __cmp_i4
co:0218: 60 03          :  jz ?_78
co:021a: 02 02 9e       :  ljmp ?167
                        : ?_78:
                        :>              // Test Remote IP-Match-Match,remote port and local port
                        :>              if(psock->sremote_ip==remote_ip.ipl){
co:021d: ae 2b          :  mov R6,?process_TCP_psock
co:021f: af 2c          :  mov R7,?process_TCP_psock+1
co:0221: 74 0c          :  mov A,#12
co:0223: 2f             :  add A,R7
co:0224: ff             :  mov R7,A
co:0225: e4             :  clr A
co:0226: 3e             :  addc A,R6
co:0227: fe             :  mov R6,A
co:0228: 8e 83          :  mov DPH,R6
co:022a: 8f 82          :  mov DPL,R7
co:022c: 12 06 c7       :  lcall __ld_dptr_r45
co:022f: 90 01 ce       :  mov DPTR,#_hframe
co:0232: 12 0a af       :  lcall __ld_dptr_r67
co:0235: ed             :  mov A,R5
co:0236: 6f             :  xrl A,R7
co:0237: 70 04          :  jnz ?_79
co:0239: ec             :  mov A,R4
co:023a: 6e             :  xrl A,R6
co:023b: 60 03          :  jz ?_80
                        : ?_79:
co:023d: 02 02 9e       :  ljmp ?169
                        : ?_80:
                        :>                  if(psock->sremote_port==hframe.tcp_hdr.sport){
co:0240: ae 2b          :  mov R6,?process_TCP_psock
co:0242: af 2c          :  mov R7,?process_TCP_psock+1
co:0244: 74 0e          :  mov A,#14
co:0246: 2f             :  add A,R7
co:0247: ff             :  mov R7,A
co:0248: e4             :  clr A
co:0249: 3e             :  addc A,R6
co:024a: fe             :  mov R6,A
co:024b: 8e 83          :  mov DPH,R6
co:024d: 8f 82          :  mov DPL,R7
co:024f: 12 06 c7       :  lcall __ld_dptr_r45
co:0252: 90 01 d0       :  mov DPTR,#_hframe+2
co:0255: 12 0a af       :  lcall __ld_dptr_r67
co:0258: ed             :  mov A,R5
co:0259: 6f             :  xrl A,R7
co:025a: 70 04          :  jnz ?_81
co:025c: ec             :  mov A,R4
co:025d: 6e             :  xrl A,R6
co:025e: 60 02          :  jz ?_82
                        : ?_81:
co:0260: 80 3c          :  sjmp ?171
                        : ?_82:
                        :>                       if(psock->local_port==hframe.tcp_hdr.dport){
co:0262: 7a 00          :  mov R2,#0
co:0264: 7b 32          :  mov R3,#50
co:0266: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:0268: 7d 08          :  mov R5,#(_match_socket)&255
co:026a: ae 2b          :  mov R6,?process_TCP_psock
co:026c: af 2c          :  mov R7,?process_TCP_psock+1
co:026e: 12 0b 73       :  lcall _xram_fast_copy
                        :>         // First copy to MATCH_SOCKET
                        :>      xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
                        :>                           res=state_machine_TCP(dlen);     // Now Header read, ready to read data
co:0271: ae 29          :  mov R6,?i185
co:0273: af 2a          :  mov R7,?i185+1
co:0275: 12 06 cd       :  lcall _state_machine_TCP
                        :  ; variable 'res' allocated as 'auto'
co:0278: 8e 2e          :  mov ?process_TCP_res,R6
co:027a: 8f 2f          :  mov ?process_TCP_res+1,R7
                        :>         // Copy back from MATCH_SOCKET and return
                        :>      xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:027c: 7a 00          :  mov R2,#0
co:027e: 7b 32          :  mov R3,#50
co:0280: ac 2b          :  mov R4,?process_TCP_psock
co:0282: ad 2c          :  mov R5,?process_TCP_psock+1
co:0284: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:0286: 7f 08          :  mov R7,#(_match_socket)&255
co:0288: 12 0b 73       :  lcall _xram_fast_copy
                        :>                           return res+ui;
co:028b: af 2d          :  mov R7,?process_TCP_ui
co:028d: ad 07          :  mov R5,AR7
co:028f: 7c 00          :  mov R4,#0
co:0291: ae 2e          :  mov R6,?process_TCP_res
co:0293: af 2f          :  mov R7,?process_TCP_res+1
co:0295: ed             :  mov A,R5
co:0296: 2f             :  add A,R7
co:0297: ff             :  mov R7,A
co:0298: ec             :  mov A,R4
co:0299: 3e             :  addc A,R6
co:029a: fe             :  mov R6,A
co:029b: 02 03 88       :  ljmp ?157
                        : ?171:
                        :>                          }
                        :>                  }
                        : ?169:
                        :>              }
                        : ?167:
                        :>         }
                        : ?165:
                        :>     }
co:029e: 05 2d          :  inc ?process_TCP_ui
co:02a0: 74 32          :  mov A,#50
co:02a2: 25 2c          :  add A,?process_TCP_psock+1
co:02a4: f5 2c          :  mov ?process_TCP_psock+1,A
co:02a6: e4             :  clr A
co:02a7: 35 2b          :  addc A,?process_TCP_psock
co:02a9: f5 2b          :  mov ?process_TCP_psock,A
                        : 
co:02ab: 7d 02          :  mov R5,#2
co:02ad: af 2d          :  mov R7,?process_TCP_ui
co:02af: c3             :  clr C
co:02b0: ef             :  mov A,R7
co:02b1: 9d             :  subb A,R5
co:02b2: 50 03          :  jnc ?_83
co:02b4: 02 01 ec       :  ljmp ?161
                        : ?_83:
                        :>
                        :>     // Now: No matching Socket found: Then only frames with SYN are allowed!
                        :>     if(!(hframe.tcp_hdr.flags&TSYN)) return EVENT_TCP_ILLEGALFRAME;
co:02b7: 90 01 db       :  mov DPTR,#_hframe+13
co:02ba: e0             :  movx A,@DPTR
co:02bb: ff             :  mov R7,A
co:02bc: 54 02          :  anl A,#2
co:02be: ff             :  mov R7,A
co:02bf: 70 07          :  jnz ?173
                        : 
co:02c1: 7e f8          :  mov R6,#248
co:02c3: 7f 00          :  mov R7,#0
co:02c5: 02 03 88       :  ljmp ?157
                        : ?173:
                        :  ; variable 'psock' allocated as 'auto'
                        :>        // No matching socket has been found, so find one with TCP_CLOSED and matching local port to o
                        :>     psock=uc_socket;
co:02c8: 75 2b 02       :  mov ?i186,#((_uc_socket)>>8)&255
co:02cb: 75 2c 74       :  mov ?i186+1,#(_uc_socket)&255
                        :  ; variable 'ui' allocated as 'auto'
                        :>     for(ui=0;ui<MAX_SOCK;ui++,psock++){
co:02ce: e4             :  clr A
co:02cf: f5 2d          :  mov ?i187,A
                        : ?175:
                        : 
co:02d1: 85 2b 83       :  mov DPH,?i186
co:02d4: 85 2c 82       :  mov DPL,?i186+1
co:02d7: e0             :  movx A,@DPTR
co:02d8: ff             :  mov R7,A
co:02d9: bf 02 02       :  cjne R7,#2,?_85
co:02dc: 80 03          :  sjmp ?_86
                        : ?_85:
co:02de: 02 03 5a       :  ljmp ?179
                        : ?_86:
                        :>         if(psock->socket_type==SOCKET_TCP){  // Only TCP-Sockets are of interest if an offered local 
co:02e1: ae 2b          :  mov R6,?i186
co:02e3: af 2c          :  mov R7,?i186+1
co:02e5: 0f             :  inc R7
co:02e6: ef             :  mov A,R7
co:02e7: 70 01          :  jnz ?__4
co:02e9: 0e             :  inc R6
                        : ?__4:
co:02ea: 85 06 83       :  mov DPH,AR6
co:02ed: 85 07 82       :  mov DPL,AR7
co:02f0: e0             :  movx A,@DPTR
co:02f1: ff             :  mov R7,A
co:02f2: 60 03          :  jz ?_87
co:02f4: 02 03 5a       :  ljmp ?181
                        : ?_87:
co:02f7: ae 2b          :  mov R6,?i186
co:02f9: af 2c          :  mov R7,?i186+1
co:02fb: 74 0e          :  mov A,#14
co:02fd: 2f             :  add A,R7
co:02fe: ff             :  mov R7,A
co:02ff: e4             :  clr A
co:0300: 3e             :  addc A,R6
co:0301: fe             :  mov R6,A
co:0302: 8e 83          :  mov DPH,R6
co:0304: 8f 82          :  mov DPL,R7
co:0306: 12 06 c7       :  lcall __ld_dptr_r45
co:0309: 90 01 d0       :  mov DPTR,#_hframe+2
co:030c: 12 0a af       :  lcall __ld_dptr_r67
co:030f: ed             :  mov A,R5
co:0310: 6f             :  xrl A,R7
co:0311: 70 04          :  jnz ?_88
co:0313: ec             :  mov A,R4
co:0314: 6e             :  xrl A,R6
co:0315: 60 02          :  jz ?_89
                        : ?_88:
co:0317: 80 41          :  sjmp ?181
                        : ?_89:
                        :>              if(psock->state==TCP_CLOSED && psock->local_port==hframe.tcp_hdr.dport){
co:0319: 7a 00          :  mov R2,#0
co:031b: 7b 32          :  mov R3,#50
co:031d: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:031f: 7d 08          :  mov R5,#(_match_socket)&255
co:0321: ae 2b          :  mov R6,?i186
co:0323: af 2c          :  mov R7,?i186+1
co:0325: 12 0b 73       :  lcall _xram_fast_copy
                        :>    // First copy to MATCH_SOCKET
                        :>    xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
                        :>                  res=state_machine_TCP(dlen);     // Now Header read, ready to read data
co:0328: ae 29          :  mov R6,?i185
co:032a: af 2a          :  mov R7,?i185+1
co:032c: 12 06 cd       :  lcall _state_machine_TCP
                        :  ; variable 'res' allocated as 'auto'
co:032f: 8e 2e          :  mov ?i188,R6
co:0331: 8f 2f          :  mov ?i188+1,R7
                        :>        // Copy back from MATCH_SOCKET and return
                        :>    xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:0333: 7a 00          :  mov R2,#0
co:0335: 7b 32          :  mov R3,#50
co:0337: ac 2b          :  mov R4,?i186
co:0339: ad 2c          :  mov R5,?i186+1
co:033b: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:033d: 7f 08          :  mov R7,#(_match_socket)&255
co:033f: 12 0b 73       :  lcall _xram_fast_copy
                        :>                  if (res) return res+ui;
co:0342: e5 2e          :  mov A,?i188
co:0344: 45 2f          :  orl A,?i188+1
co:0346: 60 12          :  jz ?183
                        : 
co:0348: af 2d          :  mov R7,?i187
co:034a: ad 07          :  mov R5,AR7
co:034c: 7c 00          :  mov R4,#0
co:034e: ae 2e          :  mov R6,?i188
co:0350: af 2f          :  mov R7,?i188+1
co:0352: ed             :  mov A,R5
co:0353: 2f             :  add A,R7
co:0354: ff             :  mov R7,A
co:0355: ec             :  mov A,R4
co:0356: 3e             :  addc A,R6
co:0357: fe             :  mov R6,A
co:0358: 80 2e          :  sjmp ?157
                        : ?183:
                        :>              }
                        : ?181:
                        :>         }
                        : ?179:
                        :>     }
co:035a: 05 2d          :  inc ?i187
co:035c: 74 32          :  mov A,#50
co:035e: 25 2c          :  add A,?i186+1
co:0360: f5 2c          :  mov ?i186+1,A
co:0362: e4             :  clr A
co:0363: 35 2b          :  addc A,?i186
co:0365: f5 2b          :  mov ?i186,A
                        : 
co:0367: 7d 02          :  mov R5,#2
co:0369: af 2d          :  mov R7,?i187
co:036b: c3             :  clr C
co:036c: ef             :  mov A,R7
co:036d: 9d             :  subb A,R5
co:036e: 50 03          :  jnc ?_91
co:0370: 02 02 d1       :  ljmp ?175
                        : ?_91:
                        :>
                        :>     // Nothing found and nothing free! Deny request by replying with a TCP-RESET (not replying may be
                        :>#ifdef PHY_ETH
                        :>     send_incomming_reset_TCP(dlen,&remote_mac,remote_ip.ipl);
co:0373: 90 02 e0       :  mov DPTR,#_remote_ip
co:0376: 12 01 65       :  lcall __ld_dptr_r03
co:0379: 7c 02          :  mov R4,#((_remote_mac)>>8)&255
co:037b: 7d 08          :  mov R5,#(_remote_mac)&255
co:037d: ae 29          :  mov R6,?i185
co:037f: af 2a          :  mov R7,?i185+1
co:0381: 12 20 a2       :  lcall _send_incomming_reset_TCP
                        :>#else
                        :>     send_incomming_reset_TCP(dlen,remote_ip.ipl);
                        :>#endif
                        :>     return EVENT_TCP_DENIED;
co:0384: 7e f0          :  mov R6,#240
co:0386: 7f 00          :  mov R7,#0
                        : ?157:
co:0388: 22             :  ret
                        : ; end of function process_TCP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:7 bytes
                        : 
                        :  .export _process_IP ; unsigned int process_IP(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __process_IP
                        : _process_IP: ; unsigned int process_IP(void)
                        :>
                        :>}
                        :>
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* void process_IP(void)
                        :>* 
                        :>*
                        :>* 2.nd-Level-Multiplexer
                        :>**********************************************************************************/
                        :>uint process_IP(void){
co:0389: 12 21 bd       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'hdr' allocated as 'auto'
                        :> uint hdr;
                        :> uint dlen;
                        :> uchar pcol;
                        :> 
                        :> hdr=Read_Frame_word_Phy();  // Read Header
                        :> if((hdr&0xF000)!=0x4000) return EVENT_IP_NOIP4; // Not IP4!
co:038c: 8e 24          :  mov ?process_IP_hdr,R6
co:038e: 8f 25          :  mov ?process_IP_hdr+1,R7
co:0390: 7f 00          :  mov R7,#0
co:0392: 53 06 f0       :  anl AR6,#240
co:0395: ef             :  mov A,R7
co:0396: 70 05          :  jnz ?_92
co:0398: ee             :  mov A,R6
co:0399: 64 40          :  xrl A,#64
co:039b: 60 07          :  jz ?190
                        : ?_92:
                        : 
co:039d: 7e c0          :  mov R6,#192
co:039f: 7f 00          :  mov R7,#0
co:03a1: 02 04 5f       :  ljmp ?189
                        : ?190:
                        :> dlen=Read_Frame_word_Phy();  // Read total length of datagram
co:03a4: 12 21 bd       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'dlen' allocated as 'auto'
co:03a7: 8e 26          :  mov ?process_IP_dlen,R6
co:03a9: 8f 27          :  mov ?process_IP_dlen+1,R7
                        :> Read_Frame_word_Phy();   // Ignore Ident
co:03ab: 12 21 bd       :  lcall _Read_Frame_word_Phy
                        :>
                        :> if(Read_Frame_word_Phy()&0x3FFF) return EVENT_IP_WONTFRAG; // Reject fragemnts!
co:03ae: 12 21 bd       :  lcall _Read_Frame_word_Phy
co:03b1: 53 06 3f       :  anl AR6,#63
co:03b4: ee             :  mov A,R6
co:03b5: 4f             :  orl A,R7
co:03b6: 60 07          :  jz ?192
                        : 
co:03b8: 7e c1          :  mov R6,#193
co:03ba: 7f 00          :  mov R7,#0
co:03bc: 02 04 5f       :  ljmp ?189
                        : ?192:
                        :>
                        :> pcol=(uchar)Read_Frame_word_Phy(); // Protocol (1: ICMP 6 TCP 17: UDP)
co:03bf: 12 21 bd       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'pcol' allocated as 'auto'
co:03c2: 8f 28          :  mov ?process_IP_pcol,R7
                        :> Read_Frame_word_Phy();   // Ignore IP Checksum (already secured by Ethernet)
co:03c4: 12 21 bd       :  lcall _Read_Frame_word_Phy
                        :>
                        :> remote_ip.ipl=Read_Frame_long_Phy(); // Destination IP (should be US)
co:03c7: 12 21 42       :  lcall _Read_Frame_long_Phy
co:03ca: 90 02 e0       :  mov DPTR,#_remote_ip
co:03cd: 12 04 f1       :  lcall __st_dptr_r47
                        :> Read_Frame_long_Phy();   // Destination IP (should be US)
co:03d0: 12 21 42       :  lcall _Read_Frame_long_Phy
                        :  ; variable 'dlen' allocated as 'auto'
                        :>
                        :> dlen-=20;    // Adjust header
co:03d3: 74 ec          :  mov A,#236
co:03d5: 25 27          :  add A,?process_IP_dlen+1
co:03d7: f5 27          :  mov ?i203+1,A
co:03d9: 74 ff          :  mov A,#255
co:03db: 35 26          :  addc A,?process_IP_dlen
co:03dd: f5 26          :  mov ?i203,A
                        :> hdr&=0xF00;
co:03df: ae 24          :  mov R6,?process_IP_hdr
co:03e1: af 25          :  mov R7,?process_IP_hdr+1
co:03e3: 7d 00          :  mov R5,#0
co:03e5: ee             :  mov A,R6
co:03e6: 54 0f          :  anl A,#15
co:03e8: fc             :  mov R4,A
                        :  ; variable 'hdr' assigned to register 'RW45'
                        :> hdr>>=8;
co:03e9: 7f 08          :  mov R7,#8
co:03eb: ae 04          :  mov R6,AR4
co:03ed: ed             :  mov A,R5
co:03ee: 8f f0          :  mov B,R7
co:03f0: 05 f0          :  inc B
co:03f2: 80 05          :  sjmp ?_95
                        : ?_96:
co:03f4: ce             :  xch A,R6
co:03f5: c3             :  clr C
co:03f6: 13             :  rrc A
co:03f7: ce             :  xch A,R6
co:03f8: 13             :  rrc A
                        : ?_95:
co:03f9: d5 f0 f8       :  djnz B,?_96
co:03fc: ff             :  mov R7,A
                        :  ; variable 'hdr' assigned to register 'RW67'
                        :> hdr-=5;
co:03fd: 74 fb          :  mov A,#251
co:03ff: 2f             :  add A,R7
co:0400: ff             :  mov R7,A
co:0401: 74 ff          :  mov A,#255
co:0403: 3e             :  addc A,R6
co:0404: fe             :  mov R6,A
                        :  ; variable 'hdr' allocated as 'auto'
co:0405: 8e 24          :  mov ?i206,R6
co:0407: 8f 25          :  mov ?i206+1,R7
co:0409: 80 0f          :  sjmp ?195
                        : ?194:
                        :> while(hdr--){    
co:040b: 12 21 42       :  lcall _Read_Frame_long_Phy
                        :>  Read_Frame_long_Phy();  // Ignore IP options
                        :>  dlen-=4;
co:040e: 74 fc          :  mov A,#252
co:0410: 25 27          :  add A,?i203+1
co:0412: f5 27          :  mov ?i203+1,A
co:0414: 74 ff          :  mov A,#255
co:0416: 35 26          :  addc A,?i203
co:0418: f5 26          :  mov ?i203,A
                        :> }
                        : ?195:
                        : 
co:041a: ac 24          :  mov R4,?i206
co:041c: ad 25          :  mov R5,?i206+1
co:041e: 74 ff          :  mov A,#255
co:0420: 2d             :  add A,R5
co:0421: ff             :  mov R7,A
co:0422: 74 ff          :  mov A,#255
co:0424: 3c             :  addc A,R4
co:0425: fe             :  mov R6,A
co:0426: 8e 24          :  mov ?i206,R6
co:0428: 8f 25          :  mov ?i206+1,R7
co:042a: ec             :  mov A,R4
co:042b: 4d             :  orl A,R5
co:042c: 70 dd          :  jnz ?194
                        :> if(pcol==1){
co:042e: 74 01          :  mov A,#1
co:0430: 65 28          :  xrl A,?process_IP_pcol
co:0432: 70 09          :  jnz ?197
                        : 
co:0434: ae 26          :  mov R6,?i203
co:0436: af 27          :  mov R7,?i203+1
co:0438: 12 2b 03       :  lcall _process_ICMP
co:043b: 80 22          :  sjmp ?189
                        : ?197:
                        :>  return process_ICMP(dlen);
                        :> }else if(pcol==6){ // TCP
co:043d: 74 06          :  mov A,#6
co:043f: 65 28          :  xrl A,?process_IP_pcol
co:0441: 70 09          :  jnz ?199
                        : 
co:0443: ae 26          :  mov R6,?i203
co:0445: af 27          :  mov R7,?i203+1
co:0447: 12 01 a2       :  lcall _process_TCP
co:044a: 80 13          :  sjmp ?189
                        : ?199:
                        :>  return process_TCP(dlen);
                        :>#ifdef USE_UDP
                        :> }else if(pcol==17){ // UDP
co:044c: 74 11          :  mov A,#17
co:044e: 65 28          :  xrl A,?process_IP_pcol
co:0450: 70 09          :  jnz ?201
                        : 
co:0452: ae 26          :  mov R6,?i203
co:0454: af 27          :  mov R7,?i203+1
co:0456: 12 28 10       :  lcall _process_UDP
co:0459: 80 04          :  sjmp ?189
                        : ?201:
                        :>  return process_UDP(dlen);
                        :>#endif
                        :> }
                        :> return EVENT_IP_UNKNOWN;  // Don't unterstand this
co:045b: 7e c2          :  mov R6,#194
co:045d: 7f 00          :  mov R7,#0
                        : ?189:
co:045f: 22             :  ret
                        : ; end of function process_IP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:5 bytes
                        : 
                        :  .export _send_socket_udp ; unsigned int send_socket_udp(unsigned char, xdata unsigned char *, unsigne
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_socket_udp
                        : _send_socket_udp: ; unsigned int send_socket_udp(unsigned char, xdata unsigned char *, unsigned int)
                        :  ; parameter 'pbuf' in 'RW45' assigned to 'RW01'
                        :  ; parameter 'datalen' in 'RW23' assigned to 'B1_RW89'
                        :  ; parameter 'sock' in 'R7'
                        :  mov R0,AR4
                        :  mov R1,AR5
                        :  mov AR8,R2
                        :  mov AR9,R3
                        :>}
                        :>
                        :>
                        :>#ifdef USE_UDP
                        :>/**********************************************************************************
                        :>* uint send_socket_udp(uchar sock, xdata uchar* pdata, uint datalen)
                        :>* 
                        :>* Send data without any buffering
                        :>**********************************************************************************/
                        :>uint send_socket_udp(uchar sock, xdata uchar* pbuf, uint datalen){
                        :  clr A
                        :  mov R6,A
                        :  mov R4,A
                        :  mov R5,#50
                        :  lcall __mul_i2
                        :  mov R4,#((_uc_socket)>>8)&255
                        :  mov R5,#(_uc_socket)&255
                        :  mov A,R5
                        :  add A,R7
                        :  mov R3,A
                        :  mov A,R4
                        :  addc A,R6
                        :  mov R2,A
                        :  ; variable 'psock' assigned to register 'RW23'
                        :>     xdata UC_SOCKET *psock;
                        :>     psock=&uc_socket[sock];
                        :> if(psock->socket_type!=SOCKET_UDP) return EVENT_UDP_ERROR;
                        :  mov DPH,AR2
                        :  mov DPL,AR3
                        :  movx A,@DPTR
                        :  mov R7,A
                        :  xrl A,#1
                        :  jz ?208
                        : 
                        :  mov R6,#225
                        :  mov R7,#0
                        :  sjmp ?207
                        : ?208:
                        :>#ifdef PHY_ETH
                        :> send_upd(pbuf,datalen,psock->sremote_mac,psock->sremote_ip,psock->local_port,psock->sremote_port);
                        :  mov A,#12
                        :  add A,R3
                        :  mov R7,A
                        :  clr A
                        :  addc A,R2
                        :  mov R6,A
                        :  mov DPH,R6
                        :  mov DPL,R7
                        :  lcall __ld_dptr_r67
                        :  mov _send_upd_formal_near+6,R6
                        :  mov _send_upd_formal_near+7,R7
                        :  mov A,#14
                        :  add A,R3
                        :  mov R7,A
                        :  clr A
                        :  addc A,R2
                        :  mov R6,A
                        :  mov DPH,R6
                        :  mov DPL,R7
                        :  lcall __ld_dptr_r67
                        :  mov _send_upd_formal_near+4,R6
                        :  mov _send_upd_formal_near+5,R7
                        :  mov A,#8
                        :  add A,R3
                        :  mov R7,A
                        :  clr A
                        :  addc A,R2
                        :  mov R6,A
                        :  mov DPH,R6
                        :  mov DPL,R7
                        :  lcall __ld_dptr_r47
                        :  mov A,#_send_upd_formal_near
                        :  lcall __st_a_r47
                        :  mov A,#2
                        :  add A,R3
                        :  mov R3,A
                        :  clr A
                        :  addc A,R2
                        :  mov R2,A
                        :  mov R4,AR8
                        :  mov R5,AR9
                        :  mov R6,AR0
                        :  mov R7,AR1
                        :  lcall _send_upd
                        :>#else
                        :> send_upd(pbuf,datalen,psock->sremote_ip,psock->local_port,psock->sremote_port);
                        :>#endif
                        :> return 0;
                        :  clr A
                        :  mov R6,A
                        :  mov R7,A
                        : ?207:
                        :  ret
                        : ; end of function send_socket_udp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _send_socket_tcp ; unsigned int send_socket_tcp(unsigned char, xdata unsigned char *, unsigne
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_socket_tcp
                        : _send_socket_tcp: ; unsigned int send_socket_tcp(unsigned char, xdata unsigned char *, unsigned int)
                        :  ; parameter 'datalen' in 'RW23' moved and assigned to local '?send_socket_tcp_datalen'
                        :  ; parameter 'pbuf' in 'RW45' moved and assigned to local '?send_socket_tcp_pbuf'
                        :  ; parameter 'sock' in 'R7'
co:1d46: 8a 26          :  mov ?send_socket_tcp_datalen,R2
co:1d48: 8b 27          :  mov ?send_socket_tcp_datalen+1,R3
co:1d4a: 8c 28          :  mov ?send_socket_tcp_pbuf,R4
co:1d4c: 8d 29          :  mov ?send_socket_tcp_pbuf+1,R5
                        :>}
                        :>#endif
                        :>
                        :>/**********************************************************************************
                        :>* uint send_socket_tcp(uchar sock, xdata uchar* pdata, uint datalen)
                        :>* 
                        :>* Bind an (allocated and filled xdata) buffer to a socket and send it. After Success,
                        :>* the buffer is freed by the stack (check with ready4tx_socket()
                        :>* The buffer must be allocated with allocate_tx_buf().
                        :>* For return values!=0 the buffer must be freed by the caller!
                        :>*
                        :>* Remark for least ressouces: 
                        :>* ---------------------------
                        :>* If Space is very low on the used System, this function might be  called directly, 
                        :>* see stringsend_socket().
                        :>* 
                        :>**********************************************************************************/
                        :>uint send_socket_tcp(uchar sock, xdata uchar* pbuf, uint datalen){
co:1d4e: e4             :  clr A
co:1d4f: fe             :  mov R6,A
co:1d50: fc             :  mov R4,A
co:1d51: 7d 32          :  mov R5,#50
co:1d53: 12 22 2a       :  lcall __mul_i2
co:1d56: 7c 02          :  mov R4,#((_uc_socket)>>8)&255
co:1d58: 7d 74          :  mov R5,#(_uc_socket)&255
co:1d5a: ed             :  mov A,R5
co:1d5b: 2f             :  add A,R7
co:1d5c: ff             :  mov R7,A
co:1d5d: ec             :  mov A,R4
co:1d5e: 3e             :  addc A,R6
co:1d5f: fe             :  mov R6,A
                        :  ; variable 'psock' allocated as 'auto'
co:1d60: 8e 2a          :  mov ?send_socket_tcp_psock,R6
co:1d62: 8f 2b          :  mov ?send_socket_tcp_psock+1,R7
                        :>     xdata UC_SOCKET *psock;
                        :>     psock=&uc_socket[sock];
                        :> // Copy Socket to Working Socket
                        :> xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
co:1d64: 7a 00          :  mov R2,#0
co:1d66: 7b 32          :  mov R3,#50
co:1d68: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:1d6a: 7d 08          :  mov R5,#(_match_socket)&255
co:1d6c: ae 2a          :  mov R6,?send_socket_tcp_psock
co:1d6e: af 2b          :  mov R7,?send_socket_tcp_psock+1
co:1d70: 12 0b 73       :  lcall _xram_fast_copy
                        :> if(match_socket.socket_type!=SOCKET_TCP || match_socket.state!=TCP_EST) return EVENT_TCP_DENIED;
co:1d73: 90 00 08       :  mov DPTR,#_match_socket
co:1d76: e0             :  movx A,@DPTR
co:1d77: ff             :  mov R7,A
co:1d78: bf 02 09       :  cjne R7,#2,?213
co:1d7b: 90 00 09       :  mov DPTR,#_match_socket+1
co:1d7e: e0             :  movx A,@DPTR
co:1d7f: ff             :  mov R7,A
co:1d80: 64 02          :  xrl A,#2
co:1d82: 60 07          :  jz ?211
                        : ?213:
                        : 
co:1d84: 7e f0          :  mov R6,#240
co:1d86: 7f 00          :  mov R7,#0
co:1d88: 02 1e 97       :  ljmp ?210
                        : ?211:
                        :> if(!datalen) {
co:1d8b: e5 26          :  mov A,?send_socket_tcp_datalen
co:1d8d: 45 27          :  orl A,?send_socket_tcp_datalen+1
co:1d8f: 70 0d          :  jnz ?214
                        : 
co:1d91: ae 28          :  mov R6,?send_socket_tcp_pbuf
co:1d93: af 29          :  mov R7,?send_socket_tcp_pbuf+1
co:1d95: 12 2c d6       :  lcall _free_tx_buf
                        :>  free_tx_buf(pbuf); // Free Buffer
                        :>  return 0;  // IDIOTA!
co:1d98: e4             :  clr A
co:1d99: fe             :  mov R6,A
co:1d9a: ff             :  mov R7,A
co:1d9b: 02 1e 97       :  ljmp ?210
                        : ?214:
                        :> }
                        :>
                        :> // Bind Buffer try to allocate B1 first, then B2m then B3 else error
                        :> if(!match_socket.buf_outsize1){
co:1d9e: 90 00 32       :  mov DPTR,#_match_socket+42
co:1da1: 12 0a af       :  lcall __ld_dptr_r67
co:1da4: ee             :  mov A,R6
co:1da5: 4f             :  orl A,R7
co:1da6: 70 31          :  jnz ?216
                        : 
co:1da8: ae 28          :  mov R6,?send_socket_tcp_pbuf
co:1daa: af 29          :  mov R7,?send_socket_tcp_pbuf+1
co:1dac: 90 00 38       :  mov DPTR,#_match_socket+48
co:1daf: 12 0a c1       :  lcall __st_dptr_r67
                        :>  match_socket.p_outbuf1=pbuf;
                        :>  match_socket.buf_outsize1=datalen;
co:1db2: ae 26          :  mov R6,?send_socket_tcp_datalen
co:1db4: af 27          :  mov R7,?send_socket_tcp_datalen+1
co:1db6: 90 00 32       :  mov DPTR,#_match_socket+42
co:1db9: 12 0a c1       :  lcall __st_dptr_r67
                        :>  match_socket.sseq_1=match_socket.sseq.u+datalen;
co:1dbc: ae 26          :  mov R6,?send_socket_tcp_datalen
co:1dbe: af 27          :  mov R7,?send_socket_tcp_datalen+1
co:1dc0: ab 07          :  mov R3,AR7
co:1dc2: aa 06          :  mov R2,AR6
co:1dc4: e4             :  clr A
co:1dc5: f9             :  mov R1,A
co:1dc6: f8             :  mov R0,A
co:1dc7: 90 00 1c       :  mov DPTR,#_match_socket+20
co:1dca: 12 01 71       :  lcall __ld_dptr_r47
co:1dcd: 12 2a f6       :  lcall __add_i4
co:1dd0: 90 00 34       :  mov DPTR,#_match_socket+44
co:1dd3: 12 04 f1       :  lcall __st_dptr_r47
                        :>  // puts("<SB1>");
                        :> }else if(!match_socket.buf_outsize2){
co:1dd6: 02 1e 53       :  ljmp ?217
                        : ?216:
                        : 
co:1dd9: 90 00 2a       :  mov DPTR,#_match_socket+34
co:1ddc: 12 0a af       :  lcall __ld_dptr_r67
co:1ddf: ee             :  mov A,R6
co:1de0: 4f             :  orl A,R7
co:1de1: 70 30          :  jnz ?218
                        : 
co:1de3: ae 28          :  mov R6,?send_socket_tcp_pbuf
co:1de5: af 29          :  mov R7,?send_socket_tcp_pbuf+1
co:1de7: 90 00 30       :  mov DPTR,#_match_socket+40
co:1dea: 12 0a c1       :  lcall __st_dptr_r67
                        :>  match_socket.p_outbuf2=pbuf;
                        :>  match_socket.buf_outsize2=datalen;
co:1ded: ae 26          :  mov R6,?send_socket_tcp_datalen
co:1def: af 27          :  mov R7,?send_socket_tcp_datalen+1
co:1df1: 90 00 2a       :  mov DPTR,#_match_socket+34
co:1df4: 12 0a c1       :  lcall __st_dptr_r67
                        :>  match_socket.sseq_2=match_socket.sseq.u+datalen;
co:1df7: ae 26          :  mov R6,?send_socket_tcp_datalen
co:1df9: af 27          :  mov R7,?send_socket_tcp_datalen+1
co:1dfb: ab 07          :  mov R3,AR7
co:1dfd: aa 06          :  mov R2,AR6
co:1dff: e4             :  clr A
co:1e00: f9             :  mov R1,A
co:1e01: f8             :  mov R0,A
co:1e02: 90 00 1c       :  mov DPTR,#_match_socket+20
co:1e05: 12 01 71       :  lcall __ld_dptr_r47
co:1e08: 12 2a f6       :  lcall __add_i4
co:1e0b: 90 00 2c       :  mov DPTR,#_match_socket+36
co:1e0e: 12 04 f1       :  lcall __st_dptr_r47
                        :>  // puts("<SB2>");
                        :> }else if(!match_socket.buf_outsize3){
co:1e11: 80 40          :  sjmp ?219
                        : ?218:
                        : 
co:1e13: 90 00 22       :  mov DPTR,#_match_socket+26
co:1e16: 12 0a af       :  lcall __ld_dptr_r67
co:1e19: ee             :  mov A,R6
co:1e1a: 4f             :  orl A,R7
co:1e1b: 70 30          :  jnz ?220
                        : 
co:1e1d: ae 28          :  mov R6,?send_socket_tcp_pbuf
co:1e1f: af 29          :  mov R7,?send_socket_tcp_pbuf+1
co:1e21: 90 00 28       :  mov DPTR,#_match_socket+32
co:1e24: 12 0a c1       :  lcall __st_dptr_r67
                        :>  match_socket.p_outbuf3=pbuf;
                        :>  match_socket.buf_outsize3=datalen;
co:1e27: ae 26          :  mov R6,?send_socket_tcp_datalen
co:1e29: af 27          :  mov R7,?send_socket_tcp_datalen+1
co:1e2b: 90 00 22       :  mov DPTR,#_match_socket+26
co:1e2e: 12 0a c1       :  lcall __st_dptr_r67
                        :>  match_socket.sseq_3=match_socket.sseq.u+datalen;
co:1e31: ae 26          :  mov R6,?send_socket_tcp_datalen
co:1e33: af 27          :  mov R7,?send_socket_tcp_datalen+1
co:1e35: ab 07          :  mov R3,AR7
co:1e37: aa 06          :  mov R2,AR6
co:1e39: e4             :  clr A
co:1e3a: f9             :  mov R1,A
co:1e3b: f8             :  mov R0,A
co:1e3c: 90 00 1c       :  mov DPTR,#_match_socket+20
co:1e3f: 12 01 71       :  lcall __ld_dptr_r47
co:1e42: 12 2a f6       :  lcall __add_i4
co:1e45: 90 00 24       :  mov DPTR,#_match_socket+28
co:1e48: 12 04 f1       :  lcall __st_dptr_r47
                        :>  // puts("<SB3>");
                        :> }else{
co:1e4b: 80 06          :  sjmp ?221
                        : ?220:
                        : 
co:1e4d: 7e f4          :  mov R6,#244
co:1e4f: 7f 00          :  mov R7,#0
co:1e51: 80 44          :  sjmp ?210
                        : ?221:
                        : ?219:
                        : ?217:
                        :>  // If data still pending: Error, Important: BUFFER NOT FREED!
                        :>  return EVENT_TCP_TXPENDING; // Can't send, old data still waiting...
                        :> }
                        :> send_match_ok_TCP(pbuf,datalen,TACK+TPUSH);
co:1e53: 7b 18          :  mov R3,#24
co:1e55: ac 26          :  mov R4,?send_socket_tcp_datalen
co:1e57: ad 27          :  mov R5,?send_socket_tcp_datalen+1
co:1e59: ae 28          :  mov R6,?send_socket_tcp_pbuf
co:1e5b: af 29          :  mov R7,?send_socket_tcp_pbuf+1
co:1e5d: 12 04 fd       :  lcall _send_match_ok_TCP
                        :> match_socket.sseq.u+=datalen; // 32 Bit operation - This must be acknowledged to free the buffer.
co:1e60: ae 26          :  mov R6,?send_socket_tcp_datalen
co:1e62: af 27          :  mov R7,?send_socket_tcp_datalen+1
co:1e64: ab 07          :  mov R3,AR7
co:1e66: aa 06          :  mov R2,AR6
co:1e68: e4             :  clr A
co:1e69: f9             :  mov R1,A
co:1e6a: f8             :  mov R0,A
co:1e6b: 90 00 1c       :  mov DPTR,#_match_socket+20
co:1e6e: 12 01 71       :  lcall __ld_dptr_r47
co:1e71: 12 2a f6       :  lcall __add_i4
co:1e74: 90 00 1c       :  mov DPTR,#_match_socket+20
co:1e77: 12 04 f1       :  lcall __st_dptr_r47
                        :>
                        :> // New TIMEOUT
                        :> match_socket.retry_cnt=0;
co:1e7a: 90 00 20       :  mov DPTR,#_match_socket+24
co:1e7d: e4             :  clr A
co:1e7e: f0             :  movx @DPTR,A
                        :> match_socket.timer=BASIC_RETRY_TIMER;
co:1e7f: 90 00 21       :  mov DPTR,#_match_socket+25
co:1e82: 74 06          :  mov A,#6
co:1e84: f0             :  movx @DPTR,A
                        :>
                        :>  // Copy back from MATCH_SOCKET and return
                        :> xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:1e85: 7a 00          :  mov R2,#0
co:1e87: 7b 32          :  mov R3,#50
co:1e89: ac 2a          :  mov R4,?send_socket_tcp_psock
co:1e8b: ad 2b          :  mov R5,?send_socket_tcp_psock+1
co:1e8d: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:1e8f: 7f 08          :  mov R7,#(_match_socket)&255
co:1e91: 12 0b 73       :  lcall _xram_fast_copy
                        :> return 0; // All OK
co:1e94: e4             :  clr A
co:1e95: fe             :  mov R6,A
co:1e96: ff             :  mov R7,A
                        : ?210:
co:1e97: 22             :  ret
                        : ; end of function send_socket_tcp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:6 bytes
                        : 
                        :  .export _notready_socket_tcp ; unsigned int notready_socket_tcp(unsigned char, unsigned char)
                        :  .segment _notready_socket_tcp_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _notready_socket_tcp_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _notready_socket_tcp_formal_near, _notready_socket_tcp_local_near, __notready_socket_tcp
                        : 
                        :  .segment __notready_socket_tcp
                        : _notready_socket_tcp: ; (leaf function) unsigned int notready_socket_tcp(unsigned char, unsigned char)
                        :  ; parameter 'sock' in 'R7'
                        :  ; parameter 'flag' in 'R5' assigned to 'R1'
co:17f0: a9 05          :  mov R1,AR5
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uint notready4tx_socket_tcp(uchar sock)
                        :>* 
                        :>* Querries if a TCP socket is ready for Transmition, ok if 0.
                        :>* Checks if a Buffer is available for transmition to!)
                        :>* 
                        :>* Flag: RDY_4_TX (>0) or RDY_4_CLOSE (0)
                        :>**********************************************************************************/
                        :>uint notready_socket_tcp(uchar sock, uchar flag){
co:17f2: ad 07          :  mov R5,AR7
co:17f4: e4             :  clr A
co:17f5: fc             :  mov R4,A
co:17f6: fe             :  mov R6,A
co:17f7: 7f 32          :  mov R7,#50
co:17f9: 12 22 2a       :  lcall __mul_i2
co:17fc: 7a 02          :  mov R2,#((_uc_socket)>>8)&255
co:17fe: 7b 74          :  mov R3,#(_uc_socket)&255
co:1800: eb             :  mov A,R3
co:1801: 2f             :  add A,R7
co:1802: fd             :  mov R5,A
co:1803: ea             :  mov A,R2
co:1804: 3e             :  addc A,R6
co:1805: fc             :  mov R4,A
                        :  ; variable 'psock' assigned to register 'RW45'
                        :>     xdata UC_SOCKET *psock;
                        :>     psock=&uc_socket[sock];
                        :> if(psock->socket_type!=SOCKET_TCP || psock->state!=TCP_EST) return EVENT_TCP_DENIED;
co:1806: 85 04 83       :  mov DPH,AR4
co:1809: 85 05 82       :  mov DPL,AR5
co:180c: e0             :  movx A,@DPTR
co:180d: ff             :  mov R7,A
co:180e: bf 02 13       :  cjne R7,#2,?225
co:1811: 74 01          :  mov A,#1
co:1813: 2d             :  add A,R5
co:1814: ff             :  mov R7,A
co:1815: e4             :  clr A
co:1816: 3c             :  addc A,R4
co:1817: fe             :  mov R6,A
co:1818: 85 06 83       :  mov DPH,AR6
co:181b: 85 07 82       :  mov DPL,AR7
co:181e: e0             :  movx A,@DPTR
co:181f: ff             :  mov R7,A
co:1820: 64 02          :  xrl A,#2
co:1822: 60 07          :  jz ?223
                        : ?225:
                        : 
co:1824: 7e f0          :  mov R6,#240
co:1826: 7f 00          :  mov R7,#0
co:1828: 02 18 6e       :  ljmp ?222
                        : ?223:
                        :> if(!tx_bufleft) return EVENT_SOCKET_NOBUFFER;  // Stack may be ready, but no buffer available...
co:182b: 90 00 06       :  mov DPTR,#_tx_bufleft
co:182e: e0             :  movx A,@DPTR
co:182f: ff             :  mov R7,A
co:1830: 70 06          :  jnz ?226
                        : 
co:1832: 7e d2          :  mov R6,#210
co:1834: 7f 00          :  mov R7,#0
co:1836: 80 36          :  sjmp ?222
                        : ?226:
                        :>#ifndef PHY_ETH
                        :> if(!Phy_rdy4tx()) return EVENT_PHY_TXPEND;     // Still TX pending (PHY!)
                        :>#endif
                        :> if(flag){ // Check Ready for TX: BUF3 must be empty
co:1838: e9             :  mov A,R1
co:1839: 60 18          :  jz ?228
                        : 
co:183b: 74 1a          :  mov A,#26
co:183d: 2d             :  add A,R5
co:183e: ff             :  mov R7,A
co:183f: e4             :  clr A
co:1840: 3c             :  addc A,R4
co:1841: fe             :  mov R6,A
co:1842: 8e 83          :  mov DPH,R6
co:1844: 8f 82          :  mov DPL,R7
co:1846: 12 0a af       :  lcall __ld_dptr_r67
co:1849: ee             :  mov A,R6
co:184a: 4f             :  orl A,R7
co:184b: 60 1e          :  jz ?229
                        :>  // If data still pending (Output Buffer full): Error
                        :>  if(psock->buf_outsize3) return EVENT_TCP_TXPENDING; // Can't send, old data still pending
co:184d: 7e f4          :  mov R6,#244
co:184f: 7f 00          :  mov R7,#0
co:1851: 80 1b          :  sjmp ?222
                        :> }else{  // Check Read for Close: BUF1 must be empty
                        : ?228:
                        : 
co:1853: 74 2a          :  mov A,#42
co:1855: 2d             :  add A,R5
co:1856: ff             :  mov R7,A
co:1857: e4             :  clr A
co:1858: 3c             :  addc A,R4
co:1859: fe             :  mov R6,A
co:185a: 8e 83          :  mov DPH,R6
co:185c: 8f 82          :  mov DPL,R7
co:185e: 12 0a af       :  lcall __ld_dptr_r67
co:1861: ee             :  mov A,R6
co:1862: 4f             :  orl A,R7
co:1863: 60 06          :  jz ?232
                        :>  if(psock->buf_outsize1) return EVENT_TCP_TXPENDING; // Can't send, old data still pending
co:1865: 7e f4          :  mov R6,#244
co:1867: 7f 00          :  mov R7,#0
co:1869: 80 03          :  sjmp ?222
                        : ?232:
                        :>
                        :> }
                        : ?229:
                        :> return 0; // SOCKEt IS READY!
co:186b: e4             :  clr A
co:186c: fe             :  mov R6,A
co:186d: ff             :  mov R7,A
                        : ?222:
co:186e: 22             :  ret
                        : ; end of function notready_socket_tcp
                        : ; used: R-1234567 BR-------- DPTR ACC PSW B
                        : 
                        :  .export _stringsend_socket_tcp ; unsigned int stringsend_socket_tcp(unsigned char, far char *)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __stringsend_socket_tcp
                        : _stringsend_socket_tcp: ; unsigned int stringsend_socket_tcp(unsigned char, far char *)
                        :  ; parameter 'pdata' in 'RL0123' moved and assigned to local '?stringsend_socket_tcp_pdata'
                        :  ; parameter 'sock' in 'R7' moved and assigned to local '?stringsend_socket_tcp_sock'
                        :  mov A,#?stringsend_socket_tcp_pdata
                        :  lcall __st_a_r03
                        :  mov ?stringsend_socket_tcp_sock,R7
                        :>}
                        :>
                        :>
                        :>/*********************************************************************************
                        :>* uint stringsend_socket_tcp(uchar sock, far char* pdata);
                        :>*
                        :>* Allocate a TCP-TX-Buffer and copy a string (far!) into it. 
                        :>* Returns 0 on success. Calls send_socket_tcp().
                        :>*********************************************************************************/
                        :>uint stringsend_socket_tcp(uchar sock, far char* pdata){
                        :  mov R5,#1
                        :  mov R7,?stringsend_socket_tcp_sock
                        :  lcall _notready_socket_tcp
                        :  mov A,R6
                        :  orl A,R7
                        :  jz ?235
                        :> xdata uchar* pbuf;
                        :> uint datalen;
                        :>
                        :> // Check if allowed
                        :> if(notready_socket_tcp(sock,RDY_4_TX)) return EVENT_TCP_DENIED;
                        :  mov R6,#240
                        :  mov R7,#0
                        :  ljmp ?234
                        : ?235:
                        :> datalen=strlen(pdata);
                        :  mov A,#?stringsend_socket_tcp_pdata
                        :  lcall __ld_a_r47
                        :  lcall _strlen
                        :  ; variable 'datalen' allocated as 'auto'
                        :  mov ?stringsend_socket_tcp_datalen,R6
                        :  mov ?stringsend_socket_tcp_datalen+1,R7
                        :> if(datalen>MAX_TX) return EVENT_SOCKET_BUF2SMALL; // Can't send as much...
                        :  mov R4,#0
                        :  mov R5,#100
                        :  mov R6,?stringsend_socket_tcp_datalen
                        :  mov R7,?stringsend_socket_tcp_datalen+1
                        :  setb C
                        :  mov A,R7
                        :  subb A,R5
                        :  mov A,R6
                        :  subb A,R4
                        :  jc ?237
                        : 
                        :  mov R6,#211
                        :  mov R7,#0
                        :  sjmp ?234
                        : ?237:
                        :> // Allocate a buffer
                        :> pbuf=allocate_tx_buf();
                        :  lcall _allocate_tx_buf
                        :  ; variable 'pbuf' allocated as 'auto'
                        :  mov ?stringsend_socket_tcp_pbuf,R6
                        :  mov ?stringsend_socket_tcp_pbuf+1,R7
                        :> if(!pbuf) return EVENT_SOCKET_NOBUFFER;   // No Buffer free?? -> Memory corrupt!
                        :  mov A,?stringsend_socket_tcp_pbuf
                        :  orl A,?stringsend_socket_tcp_pbuf+1
                        :  jnz ?239
                        : 
                        :  mov R6,#210
                        :  mov R7,#0
                        :  sjmp ?234
                        : ?239:
                        :> bmove(pdata,pbuf,datalen);
                        :  mov _bmove_formal_near,?stringsend_socket_tcp_datalen
                        :  mov _bmove_formal_near+1,?stringsend_socket_tcp_datalen+1
                        :  mov R6,?stringsend_socket_tcp_pbuf
                        :  mov R7,?stringsend_socket_tcp_pbuf+1
                        :  mov R3,AR7
                        :  mov R2,AR6
                        :  mov R0,#XDS
                        :  mov A,#?stringsend_socket_tcp_pdata
                        :  lcall __ld_a_r47
                        :  lcall _bmove
                        :> return send_socket_tcp(sock,pbuf,datalen);
                        :  mov R2,?stringsend_socket_tcp_datalen
                        :  mov R3,?stringsend_socket_tcp_datalen+1
                        :  mov R4,?stringsend_socket_tcp_pbuf
                        :  mov R5,?stringsend_socket_tcp_pbuf+1
                        :  mov R7,?stringsend_socket_tcp_sock
                        :  lcall _send_socket_tcp
                        : ?234:
                        :  ret
                        : ; end of function stringsend_socket_tcp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:9 bytes
                        : 
                        :  .export _close_socket_tcp ; unsigned int close_socket_tcp(unsigned char)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __close_socket_tcp
                        : _close_socket_tcp: ; unsigned int close_socket_tcp(unsigned char)
                        :  ; parameter 'sock' in 'R7'
                        :>}
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* uint close_socket_tcp(sock)
                        :>* 
                        :>* Close an open socket (regular mode)
                        :>* 
                        :>**********************************************************************************/
                        :>uint close_socket_tcp(uchar sock){
co:1e98: e4             :  clr A
co:1e99: fe             :  mov R6,A
co:1e9a: fc             :  mov R4,A
co:1e9b: 7d 32          :  mov R5,#50
co:1e9d: 12 22 2a       :  lcall __mul_i2
co:1ea0: 7c 02          :  mov R4,#((_uc_socket)>>8)&255
co:1ea2: 7d 74          :  mov R5,#(_uc_socket)&255
co:1ea4: ed             :  mov A,R5
co:1ea5: 2f             :  add A,R7
co:1ea6: ff             :  mov R7,A
co:1ea7: ec             :  mov A,R4
co:1ea8: 3e             :  addc A,R6
co:1ea9: fe             :  mov R6,A
                        :  ; variable 'psock' allocated as 'auto'
co:1eaa: 8e 26          :  mov ?close_socket_tcp_psock,R6
co:1eac: 8f 27          :  mov ?close_socket_tcp_psock+1,R7
                        :>     xdata UC_SOCKET *psock;
                        :>     psock=&uc_socket[sock];
                        :> // Copy Socket to Working Socket
                        :> xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
co:1eae: 7a 00          :  mov R2,#0
co:1eb0: 7b 32          :  mov R3,#50
co:1eb2: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:1eb4: 7d 08          :  mov R5,#(_match_socket)&255
co:1eb6: ae 26          :  mov R6,?close_socket_tcp_psock
co:1eb8: af 27          :  mov R7,?close_socket_tcp_psock+1
co:1eba: 12 0b 73       :  lcall _xram_fast_copy
                        :> if(match_socket.socket_type!=SOCKET_TCP || !match_socket.state) return EVENT_TCP_DENIED; // Closing a
co:1ebd: 90 00 08       :  mov DPTR,#_match_socket
co:1ec0: e0             :  movx A,@DPTR
co:1ec1: ff             :  mov R7,A
co:1ec2: bf 02 07       :  cjne R7,#2,?244
co:1ec5: 90 00 09       :  mov DPTR,#_match_socket+1
co:1ec8: e0             :  movx A,@DPTR
co:1ec9: ff             :  mov R7,A
co:1eca: 70 07          :  jnz ?242
                        : ?244:
                        : 
co:1ecc: 7e f0          :  mov R6,#240
co:1ece: 7f 00          :  mov R7,#0
co:1ed0: 02 1f 26       :  ljmp ?241
                        : ?242:
                        :>
                        :> // If data still pending: Error
                        :> if(match_socket.buf_outsize1) return EVENT_TCP_TXPENDING; // Can't send, old data still waiting...
co:1ed3: 90 00 32       :  mov DPTR,#_match_socket+42
co:1ed6: 12 0a af       :  lcall __ld_dptr_r67
co:1ed9: ee             :  mov A,R6
co:1eda: 4f             :  orl A,R7
co:1edb: 60 06          :  jz ?245
                        : 
co:1edd: 7e f4          :  mov R6,#244
co:1edf: 7f 00          :  mov R7,#0
co:1ee1: 80 43          :  sjmp ?241
                        : ?245:
                        :>
                        :> send_match_ok_TCP(0,0,TACK+TFIN+TPUSH);
co:1ee3: 7b 19          :  mov R3,#25
co:1ee5: e4             :  clr A
co:1ee6: fc             :  mov R4,A
co:1ee7: fd             :  mov R5,A
co:1ee8: e4             :  clr A
co:1ee9: fe             :  mov R6,A
co:1eea: ff             :  mov R7,A
co:1eeb: 12 04 fd       :  lcall _send_match_ok_TCP
                        :> match_socket.sseq.u++; // 32 Bit operation - This must be acknowledged
co:1eee: e4             :  clr A
co:1eef: f8             :  mov R0,A
co:1ef0: f9             :  mov R1,A
co:1ef1: fa             :  mov R2,A
co:1ef2: 7b 01          :  mov R3,#1
co:1ef4: 90 00 1c       :  mov DPTR,#_match_socket+20
co:1ef7: 12 01 71       :  lcall __ld_dptr_r47
co:1efa: 12 2a f6       :  lcall __add_i4
co:1efd: 90 00 1c       :  mov DPTR,#_match_socket+20
co:1f00: 12 04 f1       :  lcall __st_dptr_r47
                        :> match_socket.state=TCP_FINSENT;
co:1f03: 90 00 09       :  mov DPTR,#_match_socket+1
co:1f06: 74 03          :  mov A,#3
co:1f08: f0             :  movx @DPTR,A
                        :>
                        :> // New TIMEOUT
                        :> match_socket.retry_cnt=0;
co:1f09: 90 00 20       :  mov DPTR,#_match_socket+24
co:1f0c: e4             :  clr A
co:1f0d: f0             :  movx @DPTR,A
                        :> match_socket.timer=BASIC_RETRY_TIMER;
co:1f0e: 90 00 21       :  mov DPTR,#_match_socket+25
co:1f11: 74 06          :  mov A,#6
co:1f13: f0             :  movx @DPTR,A
                        :>
                        :>  // Copy back from MATCH_SOCKET and return
                        :> xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:1f14: 7a 00          :  mov R2,#0
co:1f16: 7b 32          :  mov R3,#50
co:1f18: ac 26          :  mov R4,?close_socket_tcp_psock
co:1f1a: ad 27          :  mov R5,?close_socket_tcp_psock+1
co:1f1c: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:1f1e: 7f 08          :  mov R7,#(_match_socket)&255
co:1f20: 12 0b 73       :  lcall _xram_fast_copy
                        :>
                        :> // printf("<--CLOSE %u-->",match_socket.sremote_port);
                        :>
                        :> return 0; // All OK
co:1f23: e4             :  clr A
co:1f24: fe             :  mov R6,A
co:1f25: ff             :  mov R7,A
                        : ?241:
co:1f26: 22             :  ret
                        : ; end of function close_socket_tcp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .export _open_socket_udp ; unsigned int open_socket_udp(unsigned char, unsigned long, unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __open_socket_udp
                        : _open_socket_udp: ; unsigned int open_socket_udp(unsigned char, unsigned long, unsigned int)
                        :  ; parameter 'remote_ipl' in 'RL0123' moved and assigned to local '?open_socket_udp_remote_ipl'
                        :  ; parameter 'sock' in 'R7'
                        :  ; parameter 'remote_port' assigned to local '?open_socket_udp_0_remote_port'
                        :  mov A,#?open_socket_udp_remote_ipl
                        :  lcall __st_a_r03
                        :>}
                        :>
                        :>#ifdef USE_TCP_CLIENT
                        :>/**********************************************************************************
                        :>* uint open_socket_tcp(sock,ipl,port);
                        :>* 
                        :>* Initiate an active Open for a  given Socket
                        :>**********************************************************************************/
                        :>uint open_socket_tcp(uchar sock,unsigned long remote_ipl,unsigned int remote_port){
                        :>     xdata UC_SOCKET *psock;
                        :>     psock=&uc_socket[sock];
                        :> // Copy Socket to Working Socket
                        :> xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
                        :> if(match_socket.socket_type!=SOCKET_TCP || match_socket.state) return EVENT_TCP_DENIED; // No Access 
                        :>
                        :> match_socket.sremote_ip=remote_ipl;
                        :> match_socket.sremote_port=remote_port;
                        :>  
                        :>#ifdef PHY_ETH
                        :>   send_request_ARP(remote_ipl);
                        :>   match_socket.state=ARPSENT;
                        :>
                        :>#else
                        :>   // Ports already setup!
                        :>   match_socket.sseq.w.h_word=net_service_cnt;   // Time ascending...
                        :>   match_socket.sseq.w.l_word=0;    // Our relative Pointer (for HTTP, -1 due to SYNC)
                        :>   match_socket.state=TCP_SYNSENT;  // SYN confirmed with SYN+ACK
                        :>   send_match_ok_TCP(0,0,TSYN); // Initiate Connection with a SYN
                        :>#endif
                        :>   // New TIMEOUT
                        :>   match_socket.retry_cnt=0;
                        :>   match_socket.timer=BASIC_RETRY_TIMER;
                        :>
                        :>  // Copy back from MATCH_SOCKET and return
                        :> xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
                        :> return 0; // All OK
                        :>}
                        :>#endif
                        :>
                        :>#ifdef USE_UDP_CLIENT
                        :>/**********************************************************************************
                        :>* uint open_socket_udp(sock,ipl,port);
                        :>* 
                        :>* Initiate an active Open for a  given Socket in UDP-Mode
                        :>* 
                        :>**********************************************************************************/
                        :>uint open_socket_udp(uchar sock,unsigned long remote_ipl,unsigned int remote_port){
                        :  clr A
                        :  mov R6,A
                        :  mov R4,A
                        :  mov R5,#50
                        :  lcall __mul_i2
                        :  mov R4,#((_uc_socket)>>8)&255
                        :  mov R5,#(_uc_socket)&255
                        :  mov A,R5
                        :  add A,R7
                        :  mov R7,A
                        :  mov A,R4
                        :  addc A,R6
                        :  mov R6,A
                        :  ; variable 'psock' allocated as 'auto'
                        :  mov ?open_socket_udp_psock,R6
                        :  mov ?open_socket_udp_psock+1,R7
                        :>    xdata UC_SOCKET *psock;
                        :>    psock=&uc_socket[sock];
                        :>    
                        :>    // Copy Socket to Working Socket
                        :>    xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
                        :  mov R2,#0
                        :  mov R3,#50
                        :  mov R4,#((_match_socket)>>8)&255
                        :  mov R5,#(_match_socket)&255
                        :  mov R6,?open_socket_udp_psock
                        :  mov R7,?open_socket_udp_psock+1
                        :  lcall _xram_fast_copy
                        :>    if(match_socket.socket_type!=SOCKET_UDP || match_socket.state) return EVENT_UDP_DENIED; // No Acce
                        :  mov DPTR,#_match_socket
                        :  movx A,@DPTR
                        :  mov R7,A
                        :  cjne R7,#1,?250
                        :  mov DPTR,#_match_socket+1
                        :  movx A,@DPTR
                        :  mov R7,A
                        :  jz ?248
                        : ?250:
                        : 
                        :  mov R6,#228
                        :  mov R7,#0
                        :  ljmp ?247
                        : ?248:
                        :>
                        :>    match_socket.sremote_ip=remote_ipl;
                        :  mov A,#?open_socket_udp_remote_ipl
                        :  lcall __ld_a_r47
                        :  mov DPTR,#_match_socket+8
                        :  lcall __st_dptr_r47
                        :>    match_socket.sremote_port=remote_port;
                        :  mov R6,?open_socket_udp_0_remote_port
                        :  mov R7,?open_socket_udp_0_remote_port+1
                        :  mov DPTR,#_match_socket+12
                        :  lcall __st_dptr_r67
                        :>
                        :>    if(remote_ipl!=0xffffffff){        
                        :  mov R0,#255
                        :  mov R1,#255
                        :  mov R2,#255
                        :  mov R3,#255
                        :  mov A,#?open_socket_udp_remote_ipl
                        :  lcall __ld_a_r47
                        :  clr C
                        :  lcall __cmp_i4
                        :  jz ?251
                        : 
                        :  mov A,#?open_socket_udp_remote_ipl
                        :  lcall __ld_a_r47
                        :  lcall _send_request_ARP
                        :>#ifdef PHY_ETH
                        :>      send_request_ARP(remote_ipl);
                        :>      match_socket.state=ARPSENT;
                        :  mov DPTR,#_match_socket+1
                        :  mov A,#6
                        :  movx @DPTR,A
                        :>#else
                        :>      match_socket.state=UDP_EST;
                        :>#endif
                        :>
                        :>      // New TIMEOUT
                        :>      match_socket.retry_cnt=0;
                        :  mov DPTR,#_match_socket+24
                        :  clr A
                        :  movx @DPTR,A
                        :>      match_socket.timer=BASIC_RETRY_TIMER;
                        :  mov DPTR,#_match_socket+25
                        :  mov A,#6
                        :  movx @DPTR,A
                        :>    }else{
                        :  sjmp ?252
                        : ?251:
                        : 
                        :  mov R7,#6
                        :  mov DPTR,#_match_socket+2
                        : ?253:
                        :>      unsigned char i;
                        :>//      memset(match_socket.sremote_mac,0xff,6);
                        :>      for(i=0;i<6;i++) match_socket.sremote_mac[i]=0xff;
                        :  mov A,#255
                        :  movx @DPTR,A
                        : 
                        :  inc DPTR
                        : 
                        :  djnz R7,?253
                        :>                  match_socket.state=ARPREC;
                        :  mov DPTR,#_match_socket+1
                        :  mov A,#7
                        :  movx @DPTR,A
                        :>                  match_socket.retry_cnt=0;
                        :  mov DPTR,#_match_socket+24
                        :  clr A
                        :  movx @DPTR,A
                        :>        match_socket.timer=1;
                        :  mov DPTR,#_match_socket+25
                        :  mov A,#1
                        :  movx @DPTR,A
                        :>    }
                        : ?252:
                        :>
                        :>    // Copy back from MATCH_SOCKET and return
                        :>    xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
                        :  mov R2,#0
                        :  mov R3,#50
                        :  mov R4,?open_socket_udp_psock
                        :  mov R5,?open_socket_udp_psock+1
                        :  mov R6,#((_match_socket)>>8)&255
                        :  mov R7,#(_match_socket)&255
                        :  lcall _xram_fast_copy
                        :>    return 0; // All OK
                        :  clr A
                        :  mov R6,A
                        :  mov R7,A
                        : ?247:
                        :  ret
                        : ; end of function open_socket_udp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:6 bytes formals:2 bytes
                        : 
                        :  .export _close_socket_udp ; unsigned int close_socket_udp(unsigned char)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __close_socket_udp
                        : _close_socket_udp: ; unsigned int close_socket_udp(unsigned char)
                        :  ; parameter 'sock' in 'R7'
                        :>}
                        :>#endif
                        :>
                        :>#ifdef USE_UDP
                        :>/**********************************************************************************
                        :>* uint close_socket_udp(sock)
                        :>* 
                        :>* Close an open socket (regular mode)
                        :>* 
                        :>**********************************************************************************/
                        :>uint close_socket_udp(uchar sock){
                        :  clr A
                        :  mov R6,A
                        :  mov R4,A
                        :  mov R5,#50
                        :  lcall __mul_i2
                        :  mov R4,#((_uc_socket)>>8)&255
                        :  mov R5,#(_uc_socket)&255
                        :  mov A,R5
                        :  add A,R7
                        :  mov R7,A
                        :  mov A,R4
                        :  addc A,R6
                        :  mov R6,A
                        :  ; variable 'psock' allocated as 'auto'
                        :  mov ?close_socket_udp_psock,R6
                        :  mov ?close_socket_udp_psock+1,R7
                        :>        xdata UC_SOCKET *psock;
                        :>        psock=&uc_socket[sock];
                        :>    // Copy Socket to Working Socket
                        :>    xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
                        :  mov R2,#0
                        :  mov R3,#50
                        :  mov R4,#((_match_socket)>>8)&255
                        :  mov R5,#(_match_socket)&255
                        :  mov R6,?close_socket_udp_psock
                        :  mov R7,?close_socket_udp_psock+1
                        :  lcall _xram_fast_copy
                        :>    if(match_socket.socket_type!=SOCKET_UDP || !match_socket.state) return EVENT_UDP_DENIED; // Closin
                        :  mov DPTR,#_match_socket
                        :  movx A,@DPTR
                        :  mov R7,A
                        :  cjne R7,#1,?262
                        :  mov DPTR,#_match_socket+1
                        :  movx A,@DPTR
                        :  mov R7,A
                        :  jnz ?260
                        : ?262:
                        : 
                        :  mov R6,#228
                        :  mov R7,#0
                        :  sjmp ?259
                        : ?260:
                        :>    match_socket.state=0;   // That's all to close...
                        :  mov DPTR,#_match_socket+1
                        :  clr A
                        :  movx @DPTR,A
                        :>    // Copy back from MATCH_SOCKET and return
                        :>    xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
                        :  mov R2,#0
                        :  mov R3,#50
                        :  mov R4,?close_socket_udp_psock
                        :  mov R5,?close_socket_udp_psock+1
                        :  mov R6,#((_match_socket)>>8)&255
                        :  mov R7,#(_match_socket)&255
                        :  lcall _xram_fast_copy
                        :>    return 0; // All OK
                        :  clr A
                        :  mov R6,A
                        :  mov R7,A
                        : ?259:
                        :  ret
                        : ; end of function close_socket_udp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .segment neardata, sclass dram
                        :  .export _rx_bd ; xdata oeth_bd *near rx_bd
                        : _rx_bd: ; xdata oeth_bd *near rx_bd
dr:0042: 00 00          :  .dc.w 0
                        :  .export _poll_net ; unsigned int poll_net(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __poll_net
                        : _poll_net: ; unsigned int poll_net(void)
                        :>}
                        :>#endif
                        :>
                        :>
                        :>extern xdata uchar* near pRxPtr;
                        :>xdata oeth_bd* near rx_bd=0;
                        :>
                        :>/**********************************************************************************
                        :>* uint poll_net(void)
                        :>* 
                        :>* Top-Level-Multiplexer, should be happy with SNAP frames too...
                        :>* Will return !=0 if Event was encountered
                        :>**********************************************************************************/
                        :>uint poll_net(void){
co:138f: 90 d0 07       :  mov DPTR,#53255
co:1392: e0             :  movx A,@DPTR
co:1393: ff             :  mov R7,A
co:1394: 54 10          :  anl A,#16
co:1396: ff             :  mov R7,A
co:1397: 60 09          :  jz ?264
                        :>uint type;
                        :>
                        :>  if(*INT_SOURCE & OETH_INT_BUSY) {
co:1399: 12 22 81       :  lcall _Init_Mac
                        :>     Init_Mac();
                        :>     rx_bd=0;
co:139c: 75 42 00       :  mov _rx_bd,#0
co:139f: 75 43 00       :  mov _rx_bd+1,#0
                        :>  } 
                        : ?264:
                        :>  if(*INT_SOURCE & (OETH_INT_TXB|OETH_INT_TXE))  {
co:13a2: 90 d0 07       :  mov DPTR,#53255
co:13a5: e0             :  movx A,@DPTR
co:13a6: ff             :  mov R7,A
co:13a7: 54 03          :  anl A,#3
co:13a9: ff             :  mov R7,A
co:13aa: 60 0d          :  jz ?266
                        : 
co:13ac: 90 d4 00       :  mov DPTR,#54272
co:13af: e4             :  clr A
co:13b0: f0             :  movx @DPTR,A
co:13b1: a3             :  inc DPTR
co:13b2: f0             :  movx @DPTR,A
                        :>    xdata oeth_bd* tx_bd= OETH_BD_BASE;
                        :>    tx_bd->u.ls.len    = 0;
                        :>    *INT_SOURCE=(OETH_INT_TXB|OETH_INT_TXE); // Clear Interrupt Flag      
co:13b3: 90 d0 07       :  mov DPTR,#53255
co:13b6: 74 03          :  mov A,#3
co:13b8: f0             :  movx @DPTR,A
                        :>  }
                        : ?266:
                        :>  if(*INT_SOURCE & (OETH_INT_RXF | OETH_INT_RXE)) 
co:13b9: 90 d0 07       :  mov DPTR,#53255
co:13bc: e0             :  movx A,@DPTR
co:13bd: ff             :  mov R7,A
co:13be: 54 0c          :  anl A,#12
co:13c0: ff             :  mov R7,A
co:13c1: 70 03          :  jnz ?_134
co:13c3: 02 15 83       :  ljmp ?268
                        : ?_134:
                        :>  {
co:13c6: e5 42          :  mov A,_rx_bd
co:13c8: 45 43          :  orl A,_rx_bd+1
co:13ca: 70 16          :  jnz ?270
                        :> 
                        :>    if(!rx_bd) {
co:13cc: 12 26 1c       :  lcall _find_RX_Buffer
co:13cf: 8e 42          :  mov _rx_bd,R6
co:13d1: 8f 43          :  mov _rx_bd+1,R7
                        :>      rx_bd=find_RX_Buffer();
                        :>      if(!rx_bd) return 0;
co:13d3: e5 42          :  mov A,_rx_bd
co:13d5: 45 43          :  orl A,_rx_bd+1
co:13d7: 60 03          :  jz ?_136
co:13d9: 02 14 5f       :  ljmp ?271
                        : ?_136:
                        : 
co:13dc: e4             :  clr A
co:13dd: fe             :  mov R6,A
co:13de: ff             :  mov R7,A
co:13df: 02 16 0a       :  ljmp ?263
                        :>    }else  {
                        : ?270:
                        : 
co:13e2: e4             :  clr A
co:13e3: fb             :  mov R3,A
                        :  ; variable 'i' assigned to register 'R3'
co:13e4: 80 2c          :  sjmp ?275
                        : ?274:
                        :>      unsigned char i=0;
                        :>      while(i++<OETH_RXBD_NUM && (rx_bd->u.ls.status & OETH_RX_BD_EMPTY)) {
co:13e6: ae 42          :  mov R6,_rx_bd
co:13e8: af 43          :  mov R7,_rx_bd+1
co:13ea: 74 08          :  mov A,#8
co:13ec: 2f             :  add A,R7
co:13ed: fd             :  mov R5,A
co:13ee: e4             :  clr A
co:13ef: 3e             :  addc A,R6
co:13f0: fc             :  mov R4,A
co:13f1: 8c 42          :  mov _rx_bd,R4
co:13f3: 8d 43          :  mov _rx_bd+1,R5
co:13f5: 7e d4          :  mov R6,#212
co:13f7: 7f a0          :  mov R7,#160
co:13f9: ed             :  mov A,R5
co:13fa: 6f             :  xrl A,R7
co:13fb: 70 04          :  jnz ?_137
co:13fd: ec             :  mov A,R4
co:13fe: 6e             :  xrl A,R6
co:13ff: 60 02          :  jz ?_138
                        : ?_137:
co:1401: 80 0f          :  sjmp ?277
                        : ?_138:
                        :>        if(++rx_bd==(xdata oeth_bd*)(OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd)+OETH_RXBD_NUM*sizeof(o
co:1403: 7e d4          :  mov R6,#212
co:1405: 7f 00          :  mov R7,#0
co:1407: 74 08          :  mov A,#8
co:1409: 2f             :  add A,R7
co:140a: ff             :  mov R7,A
co:140b: e4             :  clr A
co:140c: 3e             :  addc A,R6
co:140d: fe             :  mov R6,A
co:140e: 8e 42          :  mov _rx_bd,R6
co:1410: 8f 43          :  mov _rx_bd+1,R7
                        :>          rx_bd=(xdata oeth_bd*)((uint)OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd));
                        :>        }
                        : ?277:
                        :>      }
                        : ?275:
                        : 
co:1412: ad 03          :  mov R5,AR3
co:1414: ab 05          :  mov R3,AR5
co:1416: 0b             :  inc R3
co:1417: 7f 04          :  mov R7,#4
co:1419: c3             :  clr C
co:141a: e5 05          :  mov A,AR5
co:141c: 95 07          :  subb A,AR7
co:141e: 50 1e          :  jnc ?279
co:1420: ae 42          :  mov R6,_rx_bd
co:1422: af 43          :  mov R7,_rx_bd+1
co:1424: 74 02          :  mov A,#2
co:1426: 2f             :  add A,R7
co:1427: ff             :  mov R7,A
co:1428: e4             :  clr A
co:1429: 3e             :  addc A,R6
co:142a: fe             :  mov R6,A
co:142b: 8e 83          :  mov DPH,R6
co:142d: 8f 82          :  mov DPL,R7
co:142f: 12 0a af       :  lcall __ld_dptr_r67
co:1432: 7f 00          :  mov R7,#0
co:1434: 53 06 80       :  anl AR6,#128
co:1437: ee             :  mov A,R6
co:1438: 4f             :  orl A,R7
co:1439: 60 03          :  jz ?_140
co:143b: 02 13 e6       :  ljmp ?274
                        : ?_140:
                        : ?279:
                        :>      if(rx_bd->u.ls.status & OETH_RX_BD_EMPTY) return 0;
co:143e: ae 42          :  mov R6,_rx_bd
co:1440: af 43          :  mov R7,_rx_bd+1
co:1442: 74 02          :  mov A,#2
co:1444: 2f             :  add A,R7
co:1445: ff             :  mov R7,A
co:1446: e4             :  clr A
co:1447: 3e             :  addc A,R6
co:1448: fe             :  mov R6,A
co:1449: 8e 83          :  mov DPH,R6
co:144b: 8f 82          :  mov DPL,R7
co:144d: 12 0a af       :  lcall __ld_dptr_r67
co:1450: 7f 00          :  mov R7,#0
co:1452: 53 06 80       :  anl AR6,#128
co:1455: ee             :  mov A,R6
co:1456: 4f             :  orl A,R7
co:1457: 60 06          :  jz ?280
                        : 
co:1459: e4             :  clr A
co:145a: fe             :  mov R6,A
co:145b: ff             :  mov R7,A
co:145c: 02 16 0a       :  ljmp ?263
                        : ?280:
                        :>    }
                        : ?271:
                        :>//    sevseg_data1=(uint)rx_bd&0xff;
                        :>//    sevseg_data0=(uint)rx_bd>>8;
                        :>    init_rx();
co:145f: 12 24 af       :  lcall _init_rx
                        :>//    pRxPtr=(*((uint xdata*)(&rx_bd->addr)+1))|((uint)ETH_BUFFER_BASE);
                        :>
                        :>    Read_Frame_word_Phy(); // Skip OUR MAC... (6 Bytes)
co:1462: 12 21 bd       :  lcall _Read_Frame_word_Phy
                        :>    Read_Frame_long_Phy();
co:1465: 12 21 42       :  lcall _Read_Frame_long_Phy
                        :>    Read_Frame_xdata_Phy(&remote_mac[0],6); // Read Sender's MAC
co:1468: 7c 00          :  mov R4,#0
co:146a: 7d 06          :  mov R5,#6
co:146c: 7e 02          :  mov R6,#((_remote_mac)>>8)&255
co:146e: 7f 08          :  mov R7,#(_remote_mac)&255
co:1470: 12 26 5c       :  lcall _Read_Frame_xdata_Phy
                        :>    type=Read_Frame_word_Phy();
co:1473: 12 21 bd       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'type' allocated as 'auto'
co:1476: 8e 20          :  mov ?poll_net_type,R6
co:1478: 8f 21          :  mov ?poll_net_type+1,R7
                        :>//    sevseg_data1=type&0xff;
                        :>//    sevseg_data0=type>>8;
                        :>    
                        :>    if(type<=0x5DC){ // SNAP Frame! Eat LSAP-Ctrl-OUI and retry...
co:147a: 7c 05          :  mov R4,#5
co:147c: 7d dc          :  mov R5,#220
co:147e: ae 20          :  mov R6,?poll_net_type
co:1480: af 21          :  mov R7,?poll_net_type+1
co:1482: d3             :  setb C
co:1483: ef             :  mov A,R7
co:1484: 9d             :  subb A,R5
co:1485: ee             :  mov A,R6
co:1486: 9c             :  subb A,R4
co:1487: 50 29          :  jnc ?282
                        : 
co:1489: 7e aa          :  mov R6,#170
co:148b: 7f aa          :  mov R7,#170
co:148d: 12 0b 1f       :  lcall _net_match_uint
co:1490: ef             :  mov A,R7
co:1491: 60 06          :  jz ?284
                        :>     if(net_match_uint(0xAAAA)) return 0;
co:1493: e4             :  clr A
co:1494: fe             :  mov R6,A
co:1495: ff             :  mov R7,A
co:1496: 02 16 0a       :  ljmp ?263
                        : ?284:
                        :>     if(net_match_ulong(0x3000000)) return 0;
co:1499: 7c 03          :  mov R4,#3
co:149b: e4             :  clr A
co:149c: fd             :  mov R5,A
co:149d: fe             :  mov R6,A
co:149e: ff             :  mov R7,A
co:149f: 12 0a ea       :  lcall _net_match_ulong
co:14a2: ef             :  mov A,R7
co:14a3: 60 06          :  jz ?286
                        : 
co:14a5: e4             :  clr A
co:14a6: fe             :  mov R6,A
co:14a7: ff             :  mov R7,A
co:14a8: 02 16 0a       :  ljmp ?263
                        : ?286:
                        :>     type=Read_Frame_word_Phy(); // Read NEW type...
co:14ab: 12 21 bd       :  lcall _Read_Frame_word_Phy
co:14ae: 8e 20          :  mov ?poll_net_type,R6
co:14b0: 8f 21          :  mov ?poll_net_type+1,R7
                        :>    }
                        : ?282:
                        :  ; variable 'event' allocated as 'auto'
                        :>    {
co:14b2: e4             :  clr A
co:14b3: f5 22          :  mov ?poll_net_2_event,A
co:14b5: f5 23          :  mov ?poll_net_2_event+1,A
                        :>      uint event=0;  // no event
                        :>      // *** First stage input filter/multiplexer for received frames ***
                        :>      if(type==0x0806){ // This is an ARP-Frame!
co:14b7: ae 20          :  mov R6,?poll_net_type
co:14b9: af 21          :  mov R7,?poll_net_type+1
co:14bb: bf 06 0c       :  cjne R7,#6,?288
co:14be: be 08 09       :  cjne R6,#8,?288
                        : 
co:14c1: 12 29 26       :  lcall _process_ARP
co:14c4: 8e 22          :  mov ?poll_net_2_event,R6
co:14c6: 8f 23          :  mov ?poll_net_2_event+1,R7
                        :>        event= process_ARP();
                        :>      }else if(type==0x800){ // IP Header!
co:14c8: 80 11          :  sjmp ?289
                        : ?288:
                        : 
co:14ca: ae 20          :  mov R6,?poll_net_type
co:14cc: af 21          :  mov R7,?poll_net_type+1
co:14ce: bf 00 0a       :  cjne R7,#0,?290
co:14d1: be 08 07       :  cjne R6,#8,?290
                        : 
co:14d4: 12 03 89       :  lcall _process_IP
co:14d7: 8e 22          :  mov ?poll_net_2_event,R6
co:14d9: 8f 23          :  mov ?poll_net_2_event+1,R7
                        :>        event= process_IP();   
                        :>      } // ignore unknown frames
                        : ?290:
                        : ?289:
                        :>      rx_bd->u.ls.len =0;
co:14db: e4             :  clr A
co:14dc: fc             :  mov R4,A
co:14dd: fd             :  mov R5,A
co:14de: ae 42          :  mov R6,_rx_bd
co:14e0: af 43          :  mov R7,_rx_bd+1
co:14e2: 8e 83          :  mov DPH,R6
co:14e4: 8f 82          :  mov DPL,R7
co:14e6: 12 04 eb       :  lcall __st_dptr_r45
                        :>      rx_bd->u.ls.status = (rx_bd->u.ls.status & OETH_RX_BD_WRAP) | OETH_RX_BD_EMPTY | OETH_RX_BD_IRQ;
co:14e9: 74 02          :  mov A,#2
co:14eb: 25 43          :  add A,_rx_bd+1
co:14ed: f5 09          :  mov AR9,A
co:14ef: e4             :  clr A
co:14f0: 35 42          :  addc A,_rx_bd
co:14f2: f5 08          :  mov AR8,A
co:14f4: ae 08          :  mov R6,AR8
co:14f6: af 09          :  mov R7,AR9
co:14f8: 8e 83          :  mov DPH,R6
co:14fa: 8f 82          :  mov DPL,R7
co:14fc: 12 0a af       :  lcall __ld_dptr_r67
co:14ff: 7f 00          :  mov R7,#0
co:1501: 53 06 20       :  anl AR6,#32
co:1504: 43 06 80       :  orl AR6,#128
co:1507: ef             :  mov A,R7
co:1508: fd             :  mov R5,A
co:1509: ee             :  mov A,R6
co:150a: 44 40          :  orl A,#64
co:150c: fc             :  mov R4,A
co:150d: ae 08          :  mov R6,AR8
co:150f: af 09          :  mov R7,AR9
co:1511: 8e 83          :  mov DPH,R6
co:1513: 8f 82          :  mov DPL,R7
co:1515: 12 04 eb       :  lcall __st_dptr_r45
                        :>      // search for other filled rx buffers (circular buffer)
                        :>      type=(uint)rx_bd;
co:1518: aa 42          :  mov R2,_rx_bd
co:151a: ab 43          :  mov R3,_rx_bd+1
                        :  ; variable 'type' assigned to register 'RW23'
                        :>      if(++rx_bd==(xdata oeth_bd*)((uint)OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd)+OETH_RXBD_NUM*size
co:151c: ae 42          :  mov R6,_rx_bd
co:151e: af 43          :  mov R7,_rx_bd+1
co:1520: 74 08          :  mov A,#8
co:1522: 2f             :  add A,R7
co:1523: fd             :  mov R5,A
co:1524: e4             :  clr A
co:1525: 3e             :  addc A,R6
co:1526: fc             :  mov R4,A
co:1527: 8c 42          :  mov _rx_bd,R4
co:1529: 8d 43          :  mov _rx_bd+1,R5
co:152b: 7e d4          :  mov R6,#212
co:152d: 7f 00          :  mov R7,#0
co:152f: 74 28          :  mov A,#40
co:1531: 2f             :  add A,R7
co:1532: ff             :  mov R7,A
co:1533: e4             :  clr A
co:1534: 3e             :  addc A,R6
co:1535: fe             :  mov R6,A
co:1536: ed             :  mov A,R5
co:1537: 6f             :  xrl A,R7
co:1538: 70 04          :  jnz ?_149
co:153a: ec             :  mov A,R4
co:153b: 6e             :  xrl A,R6
co:153c: 60 02          :  jz ?_150
                        : ?_149:
co:153e: 80 0f          :  sjmp ?292
                        : ?_150:
                        : 
co:1540: 7e d4          :  mov R6,#212
co:1542: 7f 00          :  mov R7,#0
co:1544: 74 08          :  mov A,#8
co:1546: 2f             :  add A,R7
co:1547: ff             :  mov R7,A
co:1548: e4             :  clr A
co:1549: 3e             :  addc A,R6
co:154a: fe             :  mov R6,A
co:154b: 8e 42          :  mov _rx_bd,R6
co:154d: 8f 43          :  mov _rx_bd+1,R7
                        :>           rx_bd=(xdata oeth_bd*)((uint)OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd));
                        :>      }
                        : ?292:
                        :>      // Search for next filled RX-Buffer
                        :>      if (type==(uint)rx_bd || (rx_bd->u.ls.status & OETH_RX_BD_EMPTY)){
co:154f: ae 42          :  mov R6,_rx_bd
co:1551: af 43          :  mov R7,_rx_bd+1
co:1553: eb             :  mov A,R3
co:1554: 6f             :  xrl A,R7
co:1555: 70 04          :  jnz ?_151
co:1557: ea             :  mov A,R2
co:1558: 6e             :  xrl A,R6
co:1559: 60 1b          :  jz ?296
                        : ?_151:
co:155b: ae 42          :  mov R6,_rx_bd
co:155d: af 43          :  mov R7,_rx_bd+1
co:155f: 74 02          :  mov A,#2
co:1561: 2f             :  add A,R7
co:1562: ff             :  mov R7,A
co:1563: e4             :  clr A
co:1564: 3e             :  addc A,R6
co:1565: fe             :  mov R6,A
co:1566: 8e 83          :  mov DPH,R6
co:1568: 8f 82          :  mov DPL,R7
co:156a: 12 0a af       :  lcall __ld_dptr_r67
co:156d: 7f 00          :  mov R7,#0
co:156f: 53 06 80       :  anl AR6,#128
co:1572: ee             :  mov A,R6
co:1573: 4f             :  orl A,R7
co:1574: 60 06          :  jz ?294
                        : ?296:
                        : 
co:1576: 90 d0 07       :  mov DPTR,#53255
co:1579: 74 0c          :  mov A,#12
co:157b: f0             :  movx @DPTR,A
                        :>        // no more filled buffers. Clear interrupt flag
                        :>        *INT_SOURCE=(OETH_INT_RXF | OETH_INT_RXE); // Clear Interrupt Flag
                        :>      }
                        : ?294:
                        :>      return event;
co:157c: ae 22          :  mov R6,?poll_net_2_event
co:157e: af 23          :  mov R7,?poll_net_2_event+1
co:1580: 02 16 0a       :  ljmp ?263
                        : ?268:
                        :>    }
                        :> }else{
co:1583: e5 3e          :  mov A,_net_timer
co:1585: 60 03          :  jz ?_153
co:1587: 02 16 07       :  ljmp ?297
                        : ?_153:
                        :>  // Do soemthing periodically net_timer decremented 2 times per Sec!... 
                        :>  if(!net_timer){
co:158a: 05 3d          :  inc _net_service_cnt
                        :>        xdata UC_SOCKET *psock;
                        :>        uchar ui;
                        :>        uint res;
                        :>        net_service_cnt++;  // Sequence-Timer Highbyte
                        :>        net_timer=TIMER_FRQ/2; // about 0.5 Hz ONLY after one complete IDLE-pass...
co:158c: 75 3e 0f       :  mov _net_timer,#15
                        :  ; variable 'psock' allocated as 'auto'
                        :>        psock=uc_socket;
co:158f: 75 20 02       :  mov ?poll_net_2_psock,#((_uc_socket)>>8)&255
co:1592: 75 21 74       :  mov ?poll_net_2_psock+1,#(_uc_socket)&255
                        :  ; variable 'ui' allocated as 'auto'
                        :>        for(ui=0;ui<MAX_SOCK;ui++,psock++){
co:1595: e4             :  clr A
co:1596: f5 22          :  mov ?poll_net_2_ui,A
                        : ?299:
                        : 
co:1598: ae 20          :  mov R6,?poll_net_2_psock
co:159a: af 21          :  mov R7,?poll_net_2_psock+1
co:159c: 0f             :  inc R7
co:159d: ef             :  mov A,R7
co:159e: 70 01          :  jnz ?__5
co:15a0: 0e             :  inc R6
                        : ?__5:
co:15a1: 85 06 83       :  mov DPH,AR6
co:15a4: 85 07 82       :  mov DPL,AR7
co:15a7: e0             :  movx A,@DPTR
co:15a8: ff             :  mov R7,A
co:15a9: 60 3d          :  jz ?303
                        :>           if(psock->state){  // Examine only non-0-state-Sockets
co:15ab: 7a 00          :  mov R2,#0
co:15ad: 7b 32          :  mov R3,#50
co:15af: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:15b1: 7d 08          :  mov R5,#(_match_socket)&255
co:15b3: ae 20          :  mov R6,?poll_net_2_psock
co:15b5: af 21          :  mov R7,?poll_net_2_psock+1
co:15b7: 12 0b 73       :  lcall _xram_fast_copy
                        :>                // First copy to MATCH_SOCKET
                        :>                  xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
                        :>                res=periodical_socket();     // Retry transmition... (Could be UDP for ARP as well...)
co:15ba: 12 00 26       :  lcall _periodical_socket
                        :  ; variable 'res' allocated as 'auto'
co:15bd: 8e 23          :  mov ?poll_net_2_res,R6
co:15bf: 8f 24          :  mov ?poll_net_2_res+1,R7
                        :>                // Copy back from MATCH_SOCKET and return
                        :>                  xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:15c1: 7a 00          :  mov R2,#0
co:15c3: 7b 32          :  mov R3,#50
co:15c5: ac 20          :  mov R4,?poll_net_2_psock
co:15c7: ad 21          :  mov R5,?poll_net_2_psock+1
co:15c9: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:15cb: 7f 08          :  mov R7,#(_match_socket)&255
co:15cd: 12 0b 73       :  lcall _xram_fast_copy
                        :>                if(res) return res+ui; // Return immediatelly if necessary
co:15d0: e5 23          :  mov A,?poll_net_2_res
co:15d2: 45 24          :  orl A,?poll_net_2_res+1
co:15d4: 60 12          :  jz ?305
                        : 
co:15d6: af 22          :  mov R7,?poll_net_2_ui
co:15d8: ad 07          :  mov R5,AR7
co:15da: 7c 00          :  mov R4,#0
co:15dc: ae 23          :  mov R6,?poll_net_2_res
co:15de: af 24          :  mov R7,?poll_net_2_res+1
co:15e0: ed             :  mov A,R5
co:15e1: 2f             :  add A,R7
co:15e2: ff             :  mov R7,A
co:15e3: ec             :  mov A,R4
co:15e4: 3e             :  addc A,R6
co:15e5: fe             :  mov R6,A
co:15e6: 80 22          :  sjmp ?263
                        : ?305:
                        :>    }
                        : ?303:
                        :>   }
co:15e8: 05 22          :  inc ?poll_net_2_ui
co:15ea: 74 32          :  mov A,#50
co:15ec: 25 21          :  add A,?poll_net_2_psock+1
co:15ee: f5 21          :  mov ?poll_net_2_psock+1,A
co:15f0: e4             :  clr A
co:15f1: 35 20          :  addc A,?poll_net_2_psock
co:15f3: f5 20          :  mov ?poll_net_2_psock,A
                        : 
co:15f5: 7d 02          :  mov R5,#2
co:15f7: af 22          :  mov R7,?poll_net_2_ui
co:15f9: c3             :  clr C
co:15fa: ef             :  mov A,R7
co:15fb: 9d             :  subb A,R5
co:15fc: 50 03          :  jnc ?_156
co:15fe: 02 15 98       :  ljmp ?299
                        : ?_156:
                        :>   return EVENT_SOCKET_IDLETIMER; // About twice/sec
co:1601: 7e d4          :  mov R6,#212
co:1603: 7f 00          :  mov R7,#0
co:1605: 80 03          :  sjmp ?263
                        : ?297:
                        :>  }
                        :>
                        :> }
co:1607: e4             :  clr A
co:1608: fe             :  mov R6,A
co:1609: ff             :  mov R7,A
                        : ?263:
co:160a: 22             :  ret
                        : ; end of function poll_net
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:5 bytes
                        : 
                        : _irq_vector _irq_timer0int ,0xB,_timer0int
                        :   .segment _irq_timer0int,org 0xB
co:000b: 02 0b 07       :   ljmp _timer0int
                        :   .hide
                        :  .export _timer0int ; void timer0int(void) interrupt
                        :  .segment _timer0int_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _timer0int_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _timer0int_formal_near, _timer0int_local_near, __timer0int
                        : 
                        :  .segment __timer0int
                        : _timer0int: ; (leaf function) void timer0int(void) interrupt
co:0b07: c0 07          :  push 7
co:0b09: c0 e0          :  push ACC
co:0b0b: c0 d0          :  push PSW
co:0b0d: 53 d0 e7       :  anl PSW,#231
co:0b10: af 3e          :  mov R7,_net_timer
co:0b12: ef             :  mov A,R7
co:0b13: 60 03          :  jz ?309
co:0b15: 1f             :  dec R7
co:0b16: 8f 3e          :  mov _net_timer,R7
                        : ?309:
co:0b18: d0 d0          :  pop PSW
co:0b1a: d0 e0          :  pop ACC
co:0b1c: d0 07          :  pop 7
co:0b1e: 32             :  reti
                        : ; end of function timer0int
                        : ; used: R-------7 BR-------- ACC
                        : 
                        :  .export _Init_net ; unsigned char Init_net(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __Init_net
                        : _Init_net: ; unsigned char Init_net(void)
                        :> return 0; // NO EVENT
                        :>}
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* IRQ: The system timer. Count down net_timer, leave it if 0!
                        :>**********************************************************************************/
                        :>#pragma option -g0  // We don't want to have debug info in the interrupt
                        :>IRQ_VECTOR(timer0int,TIMER0)
                        :>void timer0int (void) interrupt  {
                        :> uchar h;
                        :> h=net_timer;
                        :> if(h) net_timer=(--h);
                        :>}
                        :>#pragma option -g   // Restore debug info level to default
                        :>
                        :>/**********************************************************************************
                        :>* uchar Init_net()
                        :>*
                        :>* Initialise Network, return 0 if OK, else ERROR
                        :>**********************************************************************************/
                        :>uchar Init_net(void){
co:0ac7: 12 22 81       :  lcall _Init_Mac
co:0aca: ee             :  mov A,R6
co:0acb: 4f             :  orl A,R7
co:0acc: 60 04          :  jz ?312
                        :>
                        :>#ifdef PHY_ETH
                        :>// xram_fast_copy(my_ip.bytes,my_mac+2,4); // Lower 4 Bytes: IP of this node
                        :>#endif 
                        :>
                        :> if(Init_Mac()) return 1; // ERROR (MAC set as global!)
co:0ace: 7f 01          :  mov R7,#1
co:0ad0: 80 17          :  sjmp ?311
                        : ?312:
                        :>
                        :> // Use Timer 0 as TCP-Timer
                        :> EA=0;  // Disable all IRQ
co:0ad2: c2 af          :  clr _EA
                        :>
                        :> TMOD &=0xF0;
co:0ad4: 53 89 f0       :  anl _TMOD,#240
                        :> TMOD |=0x01; // 16 bit Prescaler: 28.125 Hz 
co:0ad7: 43 89 01       :  orl _TMOD,#1
                        :> TR0=1;  // Timer 0 RUN
co:0ada: d2 8c          :  setb _TR0
                        :> ET0=1;
co:0adc: d2 a9          :  setb _ET0
                        :>
                        :> EA=1;  // Enable all IRQ
co:0ade: d2 af          :  setb _EA
                        :>#ifdef PHY_ETH
                        :> _wait_ms(100); // May needs a few msec until ready
co:0ae0: 7e 00          :  mov R6,#0
co:0ae2: 7f 64          :  mov R7,#100
co:0ae4: 12 04 60       :  lcall __wait_ms
                        :>#endif
                        :> return 0; 
co:0ae7: e4             :  clr A
co:0ae8: ff             :  mov R7,A
                        : ?311:
co:0ae9: 22             :  ret
                        : ; end of function Init_net
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .import _Init_Mac ; int Init_Mac()
                        :  .segment bss, sclass xram, notext
                        :  .export _match_socket ; xdata UC_SOCKET match_socket
                        : _match_socket: ; xdata UC_SOCKET match_socket
xr:0008: xx xx xx xx xx :  .ds.b 50
xr:000d: xx xx xx xx xx :
xr:0012: xx xx xx xx xx :
xr:0017: xx xx xx xx xx :
xr:001c: xx xx xx xx xx :
xr:0021: xx xx xx xx xx :
xr:0026: xx xx xx xx xx :
xr:002b: xx xx xx xx xx :
xr:0030: xx xx xx xx xx :
xr:0035: xx xx xx xx xx :
                        :  .export _tx_buffers ; xdata unsigned char tx_buffers[4][101]
                        : _tx_buffers: ; xdata unsigned char tx_buffers[4][101]
xr:003a: xx xx xx xx xx :  .ds.b 404
xr:003f: xx xx xx xx xx :
xr:0044: xx xx xx xx xx :
xr:0049: xx xx xx xx xx :
xr:004e: xx xx xx xx xx :
xr:0053: xx xx xx xx xx :
xr:0058: xx xx xx xx xx :
xr:005d: xx xx xx xx xx :
xr:0062: xx xx xx xx xx :
xr:0067: xx xx xx xx xx :
xr:006c: xx xx xx xx xx :
xr:0071: xx xx xx xx xx :
xr:0076: xx xx xx xx xx :
xr:007b: xx xx xx xx xx :
xr:0080: xx xx xx xx xx :
xr:0085: xx xx xx xx xx :
xr:008a: xx xx xx xx xx :
xr:008f: xx xx xx xx xx :
xr:0094: xx xx xx xx xx :
xr:0099: xx xx xx xx xx :
xr:009e: xx xx xx xx xx :
xr:00a3: xx xx xx xx xx :
xr:00a8: xx xx xx xx xx :
xr:00ad: xx xx xx xx xx :
xr:00b2: xx xx xx xx xx :
xr:00b7: xx xx xx xx xx :
xr:00bc: xx xx xx xx xx :
xr:00c1: xx xx xx xx xx :
xr:00c6: xx xx xx xx xx :
xr:00cb: xx xx xx xx xx :
xr:00d0: xx xx xx xx xx :
xr:00d5: xx xx xx xx xx :
xr:00da: xx xx xx xx xx :
xr:00df: xx xx xx xx xx :
xr:00e4: xx xx xx xx xx :
xr:00e9: xx xx xx xx xx :
xr:00ee: xx xx xx xx xx :
xr:00f3: xx xx xx xx xx :
xr:00f8: xx xx xx xx xx :
xr:00fd: xx xx xx xx xx :
xr:0102: xx xx xx xx xx :
xr:0107: xx xx xx xx xx :
xr:010c: xx xx xx xx xx :
xr:0111: xx xx xx xx xx :
xr:0116: xx xx xx xx xx :
xr:011b: xx xx xx xx xx :
xr:0120: xx xx xx xx xx :
xr:0125: xx xx xx xx xx :
xr:012a: xx xx xx xx xx :
xr:012f: xx xx xx xx xx :
xr:0134: xx xx xx xx xx :
xr:0139: xx xx xx xx xx :
xr:013e: xx xx xx xx xx :
xr:0143: xx xx xx xx xx :
xr:0148: xx xx xx xx xx :
xr:014d: xx xx xx xx xx :
xr:0152: xx xx xx xx xx :
xr:0157: xx xx xx xx xx :
xr:015c: xx xx xx xx xx :
xr:0161: xx xx xx xx xx :
xr:0166: xx xx xx xx xx :
xr:016b: xx xx xx xx xx :
xr:0170: xx xx xx xx xx :
xr:0175: xx xx xx xx xx :
xr:017a: xx xx xx xx xx :
xr:017f: xx xx xx xx xx :
xr:0184: xx xx xx xx xx :
xr:0189: xx xx xx xx xx :
xr:018e: xx xx xx xx xx :
xr:0193: xx xx xx xx xx :
xr:0198: xx xx xx xx xx :
xr:019d: xx xx xx xx xx :
xr:01a2: xx xx xx xx xx :
xr:01a7: xx xx xx xx xx :
xr:01ac: xx xx xx xx xx :
xr:01b1: xx xx xx xx xx :
xr:01b6: xx xx xx xx xx :
xr:01bb: xx xx xx xx xx :
xr:01c0: xx xx xx xx xx :
xr:01c5: xx xx xx xx xx :
xr:01ca: xx xx xx xx    :
                        :  .segment nearbss, sclass dram, notext
                        :  .export _net_service_cnt ; near unsigned char net_service_cnt
                        : _net_service_cnt: ; near unsigned char net_service_cnt
dr:003d: xx             :  .ds.b 1
                        :  .export _net_timer ; near unsigned char net_timer
                        : _net_timer: ; near unsigned char net_timer
dr:003e: xx             :  .ds.b 1
                        :  .segment bss, sclass xram, notext
                        :  .export _hframe ; xdata HFRAME hframe
                        : _hframe: ; xdata HFRAME hframe
xr:01ce: xx xx xx xx xx :  .ds.b 20
xr:01d3: xx xx xx xx xx :
xr:01d8: xx xx xx xx xx :
xr:01dd: xx xx xx xx xx :
                        :  .export _pseudo_hdr ; xdata PSEUDO_HDR pseudo_hdr
                        : _pseudo_hdr: ; xdata PSEUDO_HDR pseudo_hdr
xr:01e2: xx xx xx xx xx :  .ds.b 12
xr:01e7: xx xx xx xx xx :
xr:01ec: xx xx          :
                        :  .export _hhdr ; xdata IP_HDR hhdr
                        : _hhdr: ; xdata IP_HDR hhdr
xr:01ee: xx xx xx xx xx :  .ds.b 20
xr:01f3: xx xx xx xx xx :
xr:01f8: xx xx xx xx xx :
xr:01fd: xx xx xx xx xx :
                        :  .export _gateway_mac ; xdata unsigned char gateway_mac[6]
                        : _gateway_mac: ; xdata unsigned char gateway_mac[6]
xr:0202: xx xx xx xx xx :  .ds.b 6
xr:0207: xx             :
                        :  .export _remote_mac ; xdata unsigned char remote_mac[6]
                        : _remote_mac: ; xdata unsigned char remote_mac[6]
xr:0208: xx xx xx xx xx :  .ds.b 6
xr:020d: xx             :
                        :  .import _xram_fast_copy ; void xram_fast_copy(xdata unsigned char *, xdata unsigned char *, unsigned 
                        :  .import _ip_check_more ; unsigned int ip_check_more(xdata unsigned char *, unsigned int, unsigned int
                        :  .import _ip_check ; unsigned int ip_check(xdata unsigned char *, unsigned int)
                        :  .import _net_match_uint ; unsigned char net_match_uint(unsigned int)
                        :  .import _net_match_ulong ; unsigned char net_match_ulong(unsigned long)
                        :  .import _init_rx ; void init_rx(void)
                        :  .import _find_RX_Buffer ; xdata oeth_bd *find_RX_Buffer(void)
                        :  .import _Read_Frame_xdata_Phy ; void Read_Frame_xdata_Phy(xdata unsigned char *, unsigned int)
                        :  .import _Read_Frame_long_Phy ; unsigned long Read_Frame_long_Phy(void)
                        :  .import _Read_Frame_word_Phy ; unsigned int Read_Frame_word_Phy(void)
                        :  .import _Write_Frame_xdata_Phy ; void Write_Frame_xdata_Phy(xdata unsigned char *, unsigned int)
                        :  .import _Write_Frame_long_Phy ; void Write_Frame_long_Phy(unsigned long)
                        :  .import _Write_Frame_word_Phy ; void Write_Frame_word_Phy(unsigned int)
                        :  .import _CommitSend_Phy ; void CommitSend_Phy(void)
                        :  .import _RequestSend_Phy ; void RequestSend_Phy(unsigned int)
                        :  .export _rcv_len ; xdata unsigned int rcv_len
                        : _rcv_len: ; xdata unsigned int rcv_len
xr:020e: xx xx          :  .ds.b 2
                        :  .export _rcv_buf ; xdata unsigned char rcv_buf[100]
                        : _rcv_buf: ; xdata unsigned char rcv_buf[100]
xr:0210: xx xx xx xx xx :  .ds.b 100
xr:0215: xx xx xx xx xx :
xr:021a: xx xx xx xx xx :
xr:021f: xx xx xx xx xx :
xr:0224: xx xx xx xx xx :
xr:0229: xx xx xx xx xx :
xr:022e: xx xx xx xx xx :
xr:0233: xx xx xx xx xx :
xr:0238: xx xx xx xx xx :
xr:023d: xx xx xx xx xx :
xr:0242: xx xx xx xx xx :
xr:0247: xx xx xx xx xx :
xr:024c: xx xx xx xx xx :
xr:0251: xx xx xx xx xx :
xr:0256: xx xx xx xx xx :
xr:025b: xx xx xx xx xx :
xr:0260: xx xx xx xx xx :
xr:0265: xx xx xx xx xx :
xr:026a: xx xx xx xx xx :
xr:026f: xx xx xx xx xx :
                        :  .export _uc_socket ; xdata UC_SOCKET uc_socket[2]
                        : _uc_socket: ; xdata UC_SOCKET uc_socket[2]
xr:0274: xx xx xx xx xx :  .ds.b 100
xr:0279: xx xx xx xx xx :
xr:027e: xx xx xx xx xx :
xr:0283: xx xx xx xx xx :
xr:0288: xx xx xx xx xx :
xr:028d: xx xx xx xx xx :
xr:0292: xx xx xx xx xx :
xr:0297: xx xx xx xx xx :
xr:029c: xx xx xx xx xx :
xr:02a1: xx xx xx xx xx :
xr:02a6: xx xx xx xx xx :
xr:02ab: xx xx xx xx xx :
xr:02b0: xx xx xx xx xx :
xr:02b5: xx xx xx xx xx :
xr:02ba: xx xx xx xx xx :
xr:02bf: xx xx xx xx xx :
xr:02c4: xx xx xx xx xx :
xr:02c9: xx xx xx xx xx :
xr:02ce: xx xx xx xx xx :
xr:02d3: xx xx xx xx xx :
                        :  .export _gateway_ip ; xdata IP_ADR gateway_ip
                        : _gateway_ip: ; xdata IP_ADR gateway_ip
xr:02d8: xx xx xx xx    :  .ds.b 4
                        :  .export _subnet_ip ; xdata IP_ADR subnet_ip
                        : _subnet_ip: ; xdata IP_ADR subnet_ip
xr:02dc: xx xx xx xx    :  .ds.b 4
                        :  .export _remote_ip ; xdata IP_ADR remote_ip
                        : _remote_ip: ; xdata IP_ADR remote_ip
xr:02e0: xx xx xx xx    :  .ds.b 4
                        :  .export _my_ip ; xdata IP_ADR my_ip
                        : _my_ip: ; xdata IP_ADR my_ip
xr:02e4: xx xx xx xx    :  .ds.b 4
                        :  .import _EA ; bit unsigned char EA
                        :  .import _ET0 ; bit unsigned char ET0
                        :  .import _TMOD ; near unsigned char TMOD
                        :  .import _TR0 ; bit unsigned char TR0
                        :  .import _bmove ; void bmove(far void *, far void *, unsigned int)
                        :  .import _strlen ; int strlen(far char *)
                        :  .import __wait_ms ; void _wait_ms(unsigned int) reentrant
                        :  .end
                        :>}
                        :>
                        :>
                        :>// END
=             _send_TCP =   587 (hex),   1415 (dez), text
=     _send_request_ARP =  276b (hex),  10091 (dez), text
=    _state_machine_TCP =   6cd (hex),   1741 (dez), text
=            _timer0int =   b07 (hex),   2823 (dez), text
=           _process_IP =   389 (hex),    905 (dez), text
=             _Init_net =   ac7 (hex),   2759 (dez), text
=    _send_match_ok_TCP =   4fd (hex),   1277 (dez), text
=            _subnet_ip =   2dc (hex),    732 (dez), xram
=                _rx_bd =    42 (hex),     66 (dez), dram
=          _process_ARP =  2926 (hex),  10534 (dez), text
=           _remote_mac =   208 (hex),    520 (dez), xram
=           _pseudo_hdr =   1e2 (hex),    482 (dez), xram
=  _final_timeout_socke =   a84 (hex),   2692 (dez), text
=                _my_ip =   2e4 (hex),    740 (dez), xram
=           _tx_bufleft =     6 (hex),      6 (dez), xram
=          _process_UDP =  2810 (hex),  10256 (dez), text
=            _net_timer =    3e (hex),     62 (dez), dram
=     _close_socket_tcp =  1e98 (hex),   7832 (dez), text
=    _retransmit_socket =    5d (hex),     93 (dez), text
=          _process_TCP =   1a2 (hex),    418 (dez), text
=         _match_socket =     8 (hex),      8 (dez), xram
=  _send_incomming_rese =  20a2 (hex),   8354 (dez), text
=            _remote_ip =   2e0 (hex),    736 (dez), xram
=          _free_tx_buf =  2cd6 (hex),  11478 (dez), text
=          _gateway_mac =   202 (hex),    514 (dez), xram
=              _rcv_len =   20e (hex),    526 (dez), xram
=             _poll_net =  138f (hex),   5007 (dez), text
=    _periodical_socket =    26 (hex),     38 (dez), text
=              _rcv_buf =   210 (hex),    528 (dez), xram
=           _tx_buffers =    3a (hex),     58 (dez), xram
=      _net_service_cnt =    3d (hex),     61 (dez), dram
=                 _hhdr =   1ee (hex),    494 (dez), xram
=            _uc_socket =   274 (hex),    628 (dez), xram
=         _process_ICMP =  2b03 (hex),  11011 (dez), text
=           _gateway_ip =   2d8 (hex),    728 (dez), xram
=               _hframe =   1ce (hex),    462 (dez), xram
=      _send_socket_tcp =  1d46 (hex),   7494 (dez), text
=    _free_match_socket =  2c20 (hex),  11296 (dez), text
=               _my_mac =     0 (hex),      0 (dez), xram
=  _notready_socket_tcp =  17f0 (hex),   6128 (dez), text
=      _allocate_tx_buf =  2c6f (hex),  11375 (dez), text

objectfile:tcpip\netutil.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'tcpip\netutil.c', time: Wed Dec 13 13:00:41 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :  .export _net_match_ulong ; unsigned char net_match_ulong(unsigned long)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __net_match_ulong
                        : _net_match_ulong: ; unsigned char net_match_ulong(unsigned long)
                        :  ; parameter 'm' in 'RL4567' moved and assigned to local '?net_match_ulong_m'
co:0aea: 74 24          :  mov A,#?net_match_ulong_m
co:0aec: 12 22 73       :  lcall __st_a_r47
                        :>/**********************************************************************************
                        :>* Netutil.c
                        :>*
                        :>* Some TCP/IP utility functions
                        :>*
                        :>* V2.01 (C) 2004 WWW.WICKENHAEUSER.DE
                        :>*
                        :>* Please support us:
                        :>* ==================
                        :>* 
                        :>* The offer the uC/51-ANSI-C-Compiler at a very low price. So we do not have a
                        :>* large budget for advertisements. Every link to our Internet pages
                        :>* (WWW.WICKENHAEUSER.COM, WWW.WICKENHAEUSER.DE, WWW.FLEXGATE.COM, WWW.FLEXGATE.DE)
                        :>* is welcome! 
                        :>*
                        :>**********************************************************************************/
                        :>
                        :>
                        :>#include <stdio.h>
                        :>#include <reg51.h>
                        :>
                        :>#include "phy.h"                // Physical Layer
                        :>#include "netutil.h"            // Utilities
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* uchar net_match_ulong(unsigned long m)
                        :>* 
                        :>* function, that returns 0 only if the nrext read word from the Ethernet matches
                        :>* matches a fixed one
                        :>**********************************************************************************/
                        :>uchar net_match_ulong(unsigned long m){
co:0aef: 12 21 42       :  lcall _Read_Frame_long_Phy
co:0af2: 12 2c bf       :  lcall __movel_4_0
co:0af5: 74 24          :  mov A,#?net_match_ulong_m
co:0af7: 12 2c c8       :  lcall __ld_a_r47
co:0afa: c3             :  clr C
co:0afb: 12 25 f6       :  lcall __cmp_i4
co:0afe: 60 04          :  jz ?2
                        :>        if(Read_Frame_long_Phy()!=m) return 1;
co:0b00: 7f 01          :  mov R7,#1
co:0b02: 80 02          :  sjmp ?1
                        : ?2:
                        :>        return 0;       // MATCH!
co:0b04: e4             :  clr A
co:0b05: ff             :  mov R7,A
                        : ?1:
co:0b06: 22             :  ret
                        : ; end of function net_match_ulong
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:4 bytes
                        : 
                        :  .export _net_match_uint ; unsigned char net_match_uint(unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __net_match_uint
                        : _net_match_uint: ; unsigned char net_match_uint(unsigned int)
                        :  ; parameter 'm' in 'RW67' moved and assigned to local '?net_match_uint_m'
co:0b1f: 8e 2a          :  mov ?net_match_uint_m,R6
co:0b21: 8f 2b          :  mov ?net_match_uint_m+1,R7
                        :>}
                        :>/**********************************************************************************
                        :>* uchar net_match_uint(uint m){
                        :>* 
                        :>* function, that returns 0 only if the next read long from the Ethernet matches
                        :>* matches a fixed one
                        :>**********************************************************************************/
                        :>uchar net_match_uint(uint m){
co:0b23: 12 21 bd       :  lcall _Read_Frame_word_Phy
co:0b26: ac 06          :  mov R4,AR6
co:0b28: ad 07          :  mov R5,AR7
co:0b2a: ae 2a          :  mov R6,?net_match_uint_m
co:0b2c: af 2b          :  mov R7,?net_match_uint_m+1
co:0b2e: ef             :  mov A,R7
co:0b2f: 6d             :  xrl A,R5
co:0b30: 70 04          :  jnz ?_2
co:0b32: ee             :  mov A,R6
co:0b33: 6c             :  xrl A,R4
co:0b34: 60 04          :  jz ?5
                        : ?_2:
                        :>        if(Read_Frame_word_Phy()!=m) return 1;
co:0b36: 7f 01          :  mov R7,#1
co:0b38: 80 02          :  sjmp ?4
                        : ?5:
                        :>        return 0;       // MATCH!
co:0b3a: e4             :  clr A
co:0b3b: ff             :  mov R7,A
                        : ?4:
co:0b3c: 22             :  ret
                        : ; end of function net_match_uint
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :         .segment __ip_check
                        :         .export _ip_check, _ip_check_more
                        : _ip_check:              ; Adr: R6:R7, len: R4:R5, tmp: B
co:0b3d: e4             :         clr A           ; R6:7 working reg. (delayed in R2:3)
co:0b3e: fa             :         mov R2,A
co:0b3f: fb             :         mov R3,A
                        : 
                        : _ip_check_more:         ; Adr: R6:R7, len: R4:R5, tmp: B, old_cs in R2:R3
co:0b40: 8f 82          :         mov DPL,R7
co:0b42: 8e 83          :         mov DPH,R6
co:0b44: ae 02          :         mov R6,2        ; CS Working register, copy from R2
co:0b46: af 03          :         mov R7,3        ; R3
co:0b48: 75 f0 00       :         mov B,#0        ;
co:0b4b: ec             :         mov A,R4        ; omit 0 words len
co:0b4c: 4d             :         orl A,R5
co:0b4d: 60 23          :         jz ?csx
co:0b4f: ed             :         mov A,R5        ; prepare to use 2 djnz
co:0b50: 60 01          :         jz ?cs1
co:0b52: 0c             :         inc R4
co:0b53: e0             : ?cs1:   movx A,@DPTR
co:0b54: a3             :         inc DPTR
co:0b55: 30 f0 0b       :         jnb B.0,?csh
co:0b58: 2f             :         add A,R7
co:0b59: ff             :         mov R7,A
co:0b5a: 50 10          :         jnc ?cs2
co:0b5c: 0e             :         inc R6
co:0b5d: ee             :         mov A,R6
co:0b5e: 70 0c          :         jnz ?cs2
co:0b60: 0f             :         inc R7
co:0b61: 80 09          :         sjmp ?cs2
co:0b63: 2e             : ?csh:   add A,R6
co:0b64: fe             :         mov R6,A
co:0b65: 50 05          :         jnc ?cs2
co:0b67: 0f             :         inc R7
co:0b68: ef             :         mov A,R7
co:0b69: 70 01          :         jnz ?cs2
co:0b6b: 0e             :         inc R6
co:0b6c: 05 f0          : ?cs2:   inc B
co:0b6e: dd e3          :         djnz R5,?cs1
co:0b70: dc e1          :         djnz R4,?cs1
                        : ?csx:
co:0b72: 22             :         ret
                        :         .segment __xram_fast_copy
                        :         .export _xram_fast_copy
                        : _xram_fast_copy:
                        :         ; src in R6/R7
                        :         ; dest in R4/R5
                        :         ; len in R2/R3
co:0b73: eb             :         mov A,R3        ; prepare to use 2 djnz
co:0b74: 60 01          :         jz ?xfc1
co:0b76: 0a             :         inc R2
                        : ?xfc1:  ; get from source byte
co:0b77: 8f 82          :         mov DPL,R7
co:0b79: 8e 83          :         mov DPH,R6
co:0b7b: e0             :         movx A,@DPTR
co:0b7c: a3             :         inc DPTR
co:0b7d: af 82          :         mov R7,DPL
co:0b7f: ae 83          :         mov R6,DPH
                        :         ; write to dest byte
co:0b81: 8d 82          :         mov DPL,R5
co:0b83: 8c 83          :         mov DPH,R4
co:0b85: f0             :         movx @DPTR,A
co:0b86: a3             :         inc DPTR
co:0b87: ad 82          :         mov R5,DPL
co:0b89: ac 83          :         mov R4,DPH
                        :         ; loop
co:0b8b: db ea          :         djnz R3,?xfc1
co:0b8d: da e8          :         djnz R2,?xfc1
co:0b8f: 22             :         ret
                        :  .import _Read_Frame_long_Phy ; unsigned long Read_Frame_long_Phy(void)
                        :  .import _Read_Frame_word_Phy ; unsigned int Read_Frame_word_Phy(void)
                        :  .end
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* unsigned int ip_check(xdata uchar* ps, uint len);
                        :>* unsigned int ip_check_more(xdata uchar* ps, uint len, uint old_cs);
                        :>*
                        :>* Calculate an IP Checksum of Xram Block Block , 
                        :>* Used Assembler: This is really FAST! 
                        :>* ip_check_more: Takes a given CS and adds some more bytes. This is necessary
                        :>* for TCP-segments (and optional UDP too), if data are not in a continous block...
                        :>* ip_check_more is only allowed if previously an even number of bytes was read...
                        :>**********************************************************************************/
                        :>#asm
                        :>        .segment __ip_check
                        :>        .export _ip_check, _ip_check_more
                        :>_ip_check:              ; Adr: R6:R7, len: R4:R5, tmp: B
                        :>        clr A           ; R6:7 working reg. (delayed in R2:3)
                        :>        mov R2,A
                        :>        mov R3,A
                        :>
                        :>_ip_check_more:         ; Adr: R6:R7, len: R4:R5, tmp: B, old_cs in R2:R3
                        :>        mov DPL,R7
                        :>        mov DPH,R6
                        :>        mov R6,2        ; CS Working register, copy from R2
                        :>        mov R7,3        ; R3
                        :>        mov B,#0        ; 
                        :>        mov A,R4        ; omit 0 words len
                        :>        orl A,R5
                        :>        jz ?csx
                        :>        mov A,R5        ; prepare to use 2 djnz
                        :>        jz ?cs1
                        :>        inc R4  
                        :>?cs1:   movx A,@DPTR
                        :>        inc DPTR
                        :>        jnb B.0,?csh
                        :>        add A,R7
                        :>        mov R7,A
                        :>        jnc ?cs2
                        :>        inc R6
                        :>        mov A,R6
                        :>        jnz ?cs2
                        :>        inc R7
                        :>        sjmp ?cs2
                        :>?csh:   add A,R6
                        :>        mov R6,A
                        :>        jnc ?cs2
                        :>        inc R7
                        :>        mov A,R7
                        :>        jnz ?cs2
                        :>        inc R6
                        :>?cs2:   inc B
                        :>        djnz R5,?cs1    
                        :>        djnz R4,?cs1    
                        :>?csx:   
                        :>        ret
                        :>#endasm
                        :>
                        :>/**********************************************************************************
                        :>* void xram_fast_copy(xdata uchar* src,xdata uchar* dest,uint size);
                        :>* 
                        :>* Copy size data in XRAM
                        :>**********************************************************************************/
                        :>void xram_fast_copy(xdata uchar* src,xdata uchar* dest,uint size);
                        :>#asm
                        :>        .segment __xram_fast_copy
                        :>        .export _xram_fast_copy
                        :>_xram_fast_copy:
                        :>        ; src in R6/R7
                        :>        ; dest in R4/R5
                        :>        ; len in R2/R3
                        :>        mov A,R3        ; prepare to use 2 djnz
                        :>        jz ?xfc1
                        :>        inc R2  
                        :>?xfc1:  ; get from source byte
                        :>        mov DPL,R7
                        :>        mov DPH,R6
                        :>        movx A,@DPTR
                        :>        inc DPTR
                        :>        mov R7,DPL
                        :>        mov R6,DPH
                        :>        ; write to dest byte
                        :>        mov DPL,R5
                        :>        mov DPH,R4
                        :>        movx @DPTR,A
                        :>        inc DPTR
                        :>        mov R5,DPL
                        :>        mov R4,DPH
                        :>        ; loop
                        :>        djnz R3,?xfc1
                        :>        djnz R2,?xfc1
                        :>        ret
                        :>#endasm
                        :>
                        :>// END
=      _net_match_ulong =   aea (hex),   2794 (dez), text
=             _ip_check =   b3d (hex),   2877 (dez), text
=       _net_match_uint =   b1f (hex),   2847 (dez), text
=        _ip_check_more =   b40 (hex),   2880 (dez), text
=       _xram_fast_copy =   b73 (hex),   2931 (dez), text

objectfile:tcpip\web_serv.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'tcpip\web_serv.c', time: Wed Dec 13 13:00:41 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :         .include <reg52.def>
                        : ; **** 80C52 (extended) defs ***
                        : 
                        :         .hide
                        :         .show
                        :  .segment lit
                        :  .export _html_notfound ; code unsigned char html_notfound[]
                        : _html_notfound: ; code unsigned char html_notfound[]
co:160b: 48 54 54 50 2f :  .dc.b "HTTP/1.0 200 OK",13,10,"Content-Type: text/html",13,10,"C"
co:1610: 31 2e 30 20 32 :
co:1615: 30 30 20 4f 4b :
co:161a: 0d 0a 43 6f 6e :
co:161f: 74 65 6e 74 2d :
co:1624: 54 79 70 65 3a :
co:1629: 20 74 65 78 74 :
co:162e: 2f 68 74 6d 6c :
co:1633: 0d 0a 43       :
co:1636: 6f 6e 6e 65 63 :  .dc.b "onnection: close",13,10,13,10,"<html><head><title>Elekto"
co:163b: 74 69 6f 6e 3a :
co:1640: 20 63 6c 6f 73 :
co:1645: 65 0d 0a 0d 0a :
co:164a: 3c 68 74 6d 6c :
co:164f: 3e 3c 68 65 61 :
co:1654: 64 3e 3c 74 69 :
co:1659: 74 6c 65 3e 45 :
co:165e: 6c 65 6b 74 6f :
co:1663: 72 20 46 50 47 :  .dc.b "r FPGA Webserver</title></head><body text=",34,"#0000FF",34
co:1668: 41 20 57 65 62 :
co:166d: 73 65 72 76 65 :
co:1672: 72 3c 2f 74 69 :
co:1677: 74 6c 65 3e 3c :
co:167c: 2f 68 65 61 64 :
co:1681: 3e 3c 62 6f 64 :
co:1686: 79 20 74 65 78 :
co:168b: 74 3d 22 23 30 :
co:1690: 30 30 30 46 46 :
co:1695: 22             :
co:1696: 20 62 67 63 6f :  .dc.b " bgcolor=",34,"#FFFF80",34," link=",34,"#FF0000",34,">Elekt"
co:169b: 6c 6f 72 3d 22 :
co:16a0: 23 46 46 46 46 :
co:16a5: 38 30 22 20 6c :
co:16aa: 69 6e 6b 3d 22 :
co:16af: 23 46 46 30 30 :
co:16b4: 30 30 22 3e 45 :
co:16b9: 6c 65 6b 74    :
co:16bd: 6f 72 20 46 50 :  .dc.b "or FPGA Webserver - Page not found</body></html>",13,10,0
co:16c2: 47 41 20 57 65 :
co:16c7: 62 73 65 72 76 :
co:16cc: 65 72 20 2d 20 :
co:16d1: 50 61 67 65 20 :
co:16d6: 6e 6f 74 20 66 :
co:16db: 6f 75 6e 64 3c :
co:16e0: 2f 62 6f 64 79 :
co:16e5: 3e 3c 2f 68 74 :
co:16ea: 6d 6c 3e 0d 0a :
co:16ef: 00             :
                        :  .segment data, sclass xram
                        :  .export _csock ; xdata unsigned char csock
                        : _csock: ; xdata unsigned char csock
xr:0007: ff             :  .dc.b 255
                        :  .export _gendyn_html ; unsigned int gendyn_html(xdata HTTP_INFO *, xdata unsigned char *)
                        :  .segment _gendyn_html_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _gendyn_html_local_near, size 3, fill, notext, sclass dram
                        :  .sgraph _gendyn_html_formal_near, _gendyn_html_local_near, __gendyn_html
                        : ?gendyn_html_df = _gendyn_html_local_near+2 ; unsigned char
                        : ?gendyn_html_pinfo = _gendyn_html_local_near+0 ; xdata HTTP_INFO *
                        : 
                        :  .segment __gendyn_html
                        : _gendyn_html: ; (leaf function) unsigned int gendyn_html(xdata HTTP_INFO *, xdata unsigned char *)
                        :  ; parameter 'pbuf' in 'RW45' assigned to 'B1_RW89'
                        :  ; parameter 'pinfo' in 'RW67' moved and assigned to local '?gendyn_html_pinfo'
co:1030: 8e 28          :  mov ?gendyn_html_pinfo,R6
co:1032: 8f 29          :  mov ?gendyn_html_pinfo+1,R7
co:1034: 8c 08          :  mov AR8,R4
co:1036: 8d 09          :  mov AR9,R5
                        :>/*********************************************************************************
                        :>* Web_serv.C
                        :>* 
                        :>* Webserver_Layer
                        :>* The Webserver is a top-layer of poll_net()
                        :>*
                        :>* V2.01 (C) 2004 WWW.WICKENHAEUSER.DE
                        :>*
                        :>* Please support us:
                        :>* ==================
                        :>* 
                        :>* The offer the uC/51-ANSI-C-Compiler at a very low price. So we do not have a
                        :>* large budget for advertisements. Every link to our Internet pages
                        :>* (WWW.WICKENHAEUSER.COM, WWW.WICKENHAEUSER.DE, WWW.FLEXGATE.COM, WWW.FLEXGATE.DE)
                        :>* is welcome! 
                        :>*
                        :>**********************************************************************************/
                        :>
                        :>#include <stdio.h>
                        :>#include <string.h>     
                        :>
                        :>#include <reg52.h>
                        :>
                        :>#include "net.h"                // Basic network handling (public)
                        :>#include "web_serv.h"           // Webserver
                        :>
                        :>// This is the Default Message. Using code 200 displays OUR page, whereas 404 may display a Browser's 
                        :>code uchar html_notfound[] = {
                        :>"HTTP/1.0 200 OK\r\n"
                        :>"Content-Type: text/html\r\n"
                        :>"Connection: close\r\n"
                        :>"\r\n"
                        :>"<html><head><title>Elektor FPGA Webserver</title></head>"
                        :>"<body text=\"#0000FF\" bgcolor=\"#FFFF80\" link=\"#FF0000\">"
                        :>"Elektor FPGA Webserver - Page not found"
                        :>"</body></html>\r\n"
                        :>};
                        :>
                        :>// Here the HTTP state machine is managed
                        :>HTTP_INFO http_info[MAX_SOCK];  
                        :>
                        :>xdata uchar *web_args; // static internal variable, points to start of first argument
                        :>
                        :>uchar csock=0xFF;       //   static internal variable, Current-Socket Index if !0xFF
                        :>
                        :>/**********************************************************************************
                        :>* uint gendyn_data(xdata HTTP_INFO *pinfo, xdata uchar *pbuf)
                        :>*
                        :>* Fill given buffer with dynamic data, return size (max MAX_TX)
                        :>**********************************************************************************/
                        :>uint gendyn_html(xdata HTTP_INFO *pinfo, xdata uchar *pbuf){
co:1038: ae 28          :  mov R6,?gendyn_html_pinfo
co:103a: af 29          :  mov R7,?gendyn_html_pinfo+1
co:103c: 74 02          :  mov A,#2
co:103e: 2f             :  add A,R7
co:103f: ff             :  mov R7,A
co:1040: e4             :  clr A
co:1041: 3e             :  addc A,R6
co:1042: fe             :  mov R6,A
co:1043: 8e 83          :  mov DPH,R6
co:1045: 8f 82          :  mov DPL,R7
co:1047: 12 0a af       :  lcall __ld_dptr_r67
                        :  ; variable 'psrc' assigned to register 'B1_RW1213'
co:104a: 8e 0c          :  mov AR12,R6
co:104c: 8f 0d          :  mov AR13,R7
                        :>        uint leftos;            // Left to send or process
                        :>        uint cnt;               // No. of data to send
                        :>        uint rlen;
                        :>
                        :>        xdata uchar *dsrc;
                        :>
                        :>        code uchar *psrc;       // Source is in pinfo
                        :>        uchar df;
                        :>        uchar c;
                        :>
                        :>        psrc=pinfo->pweb;
                        :>        leftos=pinfo->weblen;
co:104e: ae 28          :  mov R6,?gendyn_html_pinfo
co:1050: af 29          :  mov R7,?gendyn_html_pinfo+1
co:1052: 74 04          :  mov A,#4
co:1054: 2f             :  add A,R7
co:1055: ff             :  mov R7,A
co:1056: e4             :  clr A
co:1057: 3e             :  addc A,R6
co:1058: fe             :  mov R6,A
co:1059: 8e 83          :  mov DPH,R6
co:105b: 8f 82          :  mov DPL,R7
co:105d: 12 0a af       :  lcall __ld_dptr_r67
                        :  ; variable 'leftos' assigned to register 'B1_RW1415'
co:1060: 8e 0e          :  mov AR14,R6
co:1062: 8f 0f          :  mov AR15,R7
                        :>        df=pinfo->dyna_flag;
co:1064: ae 28          :  mov R6,?gendyn_html_pinfo
co:1066: af 29          :  mov R7,?gendyn_html_pinfo+1
co:1068: 0f             :  inc R7
co:1069: ef             :  mov A,R7
co:106a: 70 01          :  jnz ?__1
co:106c: 0e             :  inc R6
                        : ?__1:
co:106d: 85 06 83       :  mov DPH,AR6
co:1070: 85 07 82       :  mov DPL,AR7
co:1073: e0             :  movx A,@DPTR
co:1074: ff             :  mov R7,A
                        :  ; variable 'df' allocated as 'auto'
co:1075: 8f 2a          :  mov ?gendyn_html_df,R7
                        :  ; variable 'cnt' assigned to register 'B1_RW1011'
                        :>        cnt=0;
co:1077: e4             :  clr A
co:1078: f5 0a          :  mov AR10,A
co:107a: f5 0b          :  mov AR11,A
co:107c: 02 11 8e       :  ljmp ?8
                        : ?7:
                        :>        while(leftos){
co:107f: 85 0c 83       :  mov DPH,AR12
co:1082: 85 0d 82       :  mov DPL,AR13
co:1085: e4             :  clr A
co:1086: 93             :  movc A,@A+DPTR
co:1087: ff             :  mov R7,A
                        :  ; variable 'c' assigned to register 'B '
co:1088: 8f f0          :  mov B,R7
                        :>                c=*psrc;
                        :>                psrc++;
co:108a: 05 0d          :  inc AR13
co:108c: e5 0d          :  mov A,AR13
co:108e: 70 02          :  jnz ?_1
co:1090: 05 0c          :  inc AR12
                        : ?_1:
                        :>                leftos--;
co:1092: e5 0f          :  mov A,AR15
co:1094: 15 0f          :  dec AR15
co:1096: 70 02          :  jnz ?_2
co:1098: 15 0e          :  dec AR14
                        : ?_2:
                        :>                if(df && c==255){       // Dynamic Sentinel
co:109a: e5 2a          :  mov A,?gendyn_html_df
co:109c: 70 03          :  jnz ?_3
co:109e: 02 11 6a       :  ljmp ?10
                        : ?_3:
co:10a1: 74 ff          :  mov A,#255
co:10a3: 65 f0          :  xrl A,B
co:10a5: 60 03          :  jz ?_4
co:10a7: 02 11 6a       :  ljmp ?10
                        : ?_4:
                        : 
co:10aa: ae 0c          :  mov R6,AR12
co:10ac: af 0d          :  mov R7,AR13
co:10ae: 8e 83          :  mov DPH,R6
co:10b0: 8f 82          :  mov DPL,R7
co:10b2: 12 00 0e       :  lcall __ldc_dptr_r45
                        :  ; variable 'dsrc' assigned to register 'RW45'
                        :>
                        :>                        dsrc= (xdata uchar*)(*(code uint*)psrc);
                        :>                        rlen=0;
co:10b5: e4             :  clr A
co:10b6: f8             :  mov R0,A
co:10b7: f9             :  mov R1,A
                        :  ; variable 'rlen' assigned to register 'RW01'
co:10b8: 80 05          :  sjmp ?13
                        : ?12:
                        :>                        while(*dsrc++) rlen++;  // Calc. Stringlen of variable          
co:10ba: 09             :  inc R1
co:10bb: e9             :  mov A,R1
co:10bc: 70 01          :  jnz ?__2
co:10be: 08             :  inc R0
                        : ?__2:
                        : ?13:
                        : 
co:10bf: 8c 83          :  mov DPH,R4
co:10c1: 8d 82          :  mov DPL,R5
co:10c3: ae 83          :  mov R6,DPH
co:10c5: af 82          :  mov R7,DPL
co:10c7: 74 01          :  mov A,#1
co:10c9: 2f             :  add A,R7
co:10ca: fd             :  mov R5,A
co:10cb: e4             :  clr A
co:10cc: 3e             :  addc A,R6
co:10cd: fc             :  mov R4,A
co:10ce: e0             :  movx A,@DPTR
co:10cf: ff             :  mov R7,A
co:10d0: 70 e8          :  jnz ?12
                        :>
                        :>                        if(rlen>MAX_TX) rlen=MAX_TX;    // Clip too long variables to max. segment siz
co:10d2: 7e 00          :  mov R6,#0
co:10d4: 7f 64          :  mov R7,#100
co:10d6: d3             :  setb C
co:10d7: e9             :  mov A,R1
co:10d8: 9f             :  subb A,R7
co:10d9: e8             :  mov A,R0
co:10da: 9e             :  subb A,R6
co:10db: 40 04          :  jc ?15
                        : 
co:10dd: 78 00          :  mov R0,#0
co:10df: 79 64          :  mov R1,#100
                        : ?15:
                        :>
                        :>                        if(rlen+cnt>MAX_TX){    // Current data + Variable: Too much!
co:10e1: e5 0b          :  mov A,AR11
co:10e3: 29             :  add A,R1
co:10e4: fb             :  mov R3,A
co:10e5: e5 0a          :  mov A,AR10
co:10e7: 38             :  addc A,R0
co:10e8: fa             :  mov R2,A
co:10e9: 7e 00          :  mov R6,#0
co:10eb: 7f 64          :  mov R7,#100
co:10ed: d3             :  setb C
co:10ee: eb             :  mov A,R3
co:10ef: 9f             :  subb A,R7
co:10f0: ea             :  mov A,R2
co:10f1: 9e             :  subb A,R6
co:10f2: 40 17          :  jc ?17
                        : 
co:10f4: 74 ff          :  mov A,#255
co:10f6: 25 0d          :  add A,AR13
co:10f8: f5 0d          :  mov AR13,A
co:10fa: 74 ff          :  mov A,#255
co:10fc: 35 0c          :  addc A,AR12
co:10fe: f5 0c          :  mov AR12,A
                        :>                                psrc--;         // Wind back HTML-Template and 
                        :>                                leftos++;       // use a new segment...
co:1100: 05 0f          :  inc AR15
co:1102: e5 0f          :  mov A,AR15
co:1104: 70 02          :  jnz ?_8
co:1106: 05 0e          :  inc AR14
                        : ?_8:
                        :>                                break;          // Exit for now
co:1108: 02 11 97       :  ljmp ?9
                        : ?17:
                        :>                        }
                        :>
                        :>                        dsrc= (xdata uchar*)(*(code uint*)psrc);
co:110b: ae 0c          :  mov R6,AR12
co:110d: af 0d          :  mov R7,AR13
co:110f: 8e 83          :  mov DPH,R6
co:1111: 8f 82          :  mov DPL,R7
co:1113: 12 00 16       :  lcall __ldc_dptr_r23
                        :  ; variable 'dsrc' assigned to register 'RW23'
                        :>                        psrc+=2;        // Eat Address from Template
co:1116: 74 02          :  mov A,#2
co:1118: 25 0d          :  add A,AR13
co:111a: f5 0d          :  mov AR13,A
co:111c: e4             :  clr A
co:111d: 35 0c          :  addc A,AR12
co:111f: f5 0c          :  mov AR12,A
                        :>                        leftos-=2;
co:1121: 74 fe          :  mov A,#254
co:1123: 25 0f          :  add A,AR15
co:1125: f5 0f          :  mov AR15,A
co:1127: 74 ff          :  mov A,#255
co:1129: 35 0e          :  addc A,AR14
co:112b: f5 0e          :  mov AR14,A
co:112d: 80 29          :  sjmp ?20
                        : ?19:
                        :>
                        :>                        // Insert Var. string in HTML
                        :>                        while(rlen--){
co:112f: 8a 83          :  mov DPH,R2
co:1131: 8b 82          :  mov DPL,R3
co:1133: ae 83          :  mov R6,DPH
co:1135: af 82          :  mov R7,DPL
co:1137: 74 01          :  mov A,#1
co:1139: 2f             :  add A,R7
co:113a: fb             :  mov R3,A
co:113b: e4             :  clr A
co:113c: 3e             :  addc A,R6
co:113d: fa             :  mov R2,A
co:113e: e0             :  movx A,@DPTR
co:113f: ff             :  mov R7,A
                        :  ; variable 'c' assigned to register 'R7'
                        :>                                c=*dsrc++;
                        :>                                *pbuf=c;
co:1140: 85 08 83       :  mov DPH,AR8
co:1143: 85 09 82       :  mov DPL,AR9
co:1146: ef             :  mov A,R7
co:1147: f0             :  movx @DPTR,A
                        :>                                pbuf++;
co:1148: 05 09          :  inc AR9
co:114a: e5 09          :  mov A,AR9
co:114c: 70 02          :  jnz ?_9
co:114e: 05 08          :  inc AR8
                        : ?_9:
                        :>                                cnt++;
co:1150: 05 0b          :  inc AR11
co:1152: e5 0b          :  mov A,AR11
co:1154: 70 02          :  jnz ?_10
co:1156: 05 0a          :  inc AR10
                        : ?_10:
                        :>                        }                       
                        : ?20:
                        : 
co:1158: ac 00          :  mov R4,AR0
co:115a: ad 01          :  mov R5,AR1
co:115c: 74 ff          :  mov A,#255
co:115e: 2d             :  add A,R5
co:115f: f9             :  mov R1,A
co:1160: 74 ff          :  mov A,#255
co:1162: 3c             :  addc A,R4
co:1163: f8             :  mov R0,A
co:1164: ec             :  mov A,R4
co:1165: 4d             :  orl A,R5
co:1166: 70 c7          :  jnz ?19
                        :>
                        :>
                        :>                }else{
co:1168: 80 1a          :  sjmp ?11
                        : ?10:
                        : 
co:116a: af f0          :  mov R7,B
co:116c: 85 08 83       :  mov DPH,AR8
co:116f: 85 09 82       :  mov DPL,AR9
co:1172: ef             :  mov A,R7
co:1173: f0             :  movx @DPTR,A
                        :>                        *pbuf=c;
                        :>                        pbuf++;
co:1174: 05 09          :  inc AR9
co:1176: e5 09          :  mov A,AR9
co:1178: 70 02          :  jnz ?_12
co:117a: 05 08          :  inc AR8
                        : ?_12:
                        :>                        cnt++;
co:117c: 05 0b          :  inc AR11
co:117e: e5 0b          :  mov A,AR11
co:1180: 70 02          :  jnz ?_13
co:1182: 05 0a          :  inc AR10
                        : ?_13:
                        :>                }
                        : ?11:
                        :>                
                        :>                if(cnt==MAX_TX) break;  // Buffer full
co:1184: ae 0a          :  mov R6,AR10
co:1186: af 0b          :  mov R7,AR11
co:1188: ef             :  mov A,R7
co:1189: 64 64          :  xrl A,#100
co:118b: 4e             :  orl A,R6
                        : 
co:118c: 60 09          :  jz ?9
                        :>        }
                        : ?8:
                        : 
co:118e: e5 0e          :  mov A,AR14
co:1190: 45 0f          :  orl A,AR15
co:1192: 60 03          :  jz ?_15
co:1194: 02 10 7f       :  ljmp ?7
                        : ?_15:
                        : ?9:
                        :>
                        :>        pinfo->pweb=psrc;
co:1197: ae 28          :  mov R6,?gendyn_html_pinfo
co:1199: af 29          :  mov R7,?gendyn_html_pinfo+1
co:119b: 74 02          :  mov A,#2
co:119d: 2f             :  add A,R7
co:119e: fb             :  mov R3,A
co:119f: e4             :  clr A
co:11a0: 3e             :  addc A,R6
co:11a1: fa             :  mov R2,A
co:11a2: ae 0c          :  mov R6,AR12
co:11a4: af 0d          :  mov R7,AR13
co:11a6: 8a 83          :  mov DPH,R2
co:11a8: 8b 82          :  mov DPL,R3
co:11aa: 12 0a c1       :  lcall __st_dptr_r67
                        :>        pinfo->weblen=leftos;
co:11ad: ae 28          :  mov R6,?gendyn_html_pinfo
co:11af: af 29          :  mov R7,?gendyn_html_pinfo+1
co:11b1: 74 04          :  mov A,#4
co:11b3: 2f             :  add A,R7
co:11b4: fb             :  mov R3,A
co:11b5: e4             :  clr A
co:11b6: 3e             :  addc A,R6
co:11b7: fa             :  mov R2,A
co:11b8: ae 0e          :  mov R6,AR14
co:11ba: af 0f          :  mov R7,AR15
co:11bc: 8a 83          :  mov DPH,R2
co:11be: 8b 82          :  mov DPL,R3
co:11c0: 12 0a c1       :  lcall __st_dptr_r67
                        :>
                        :>        return cnt;
co:11c3: ae 0a          :  mov R6,AR10
co:11c5: af 0b          :  mov R7,AR11
co:11c7: 22             :  ret
                        : ; end of function gendyn_html
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:3 bytes
                        : 
                        :  .export _poll_webserver ; unsigned int poll_webserver(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __poll_webserver
                        : _poll_webserver: ; unsigned int poll_webserver(void)
                        :>}
                        :>
                        :>
                        :>/**********************************************************************************
                        :>*  poll_webserver()
                        :>**********************************************************************************/
                        :>uint poll_webserver(void){
co:0d18: 12 13 8f       :  lcall _poll_net
                        :  ; variable 'res' allocated as 'auto'
co:0d1b: 8e 20          :  mov ?poll_webserver_res,R6
co:0d1d: 8f 21          :  mov ?poll_webserver_res+1,R7
                        :>        uint res;
                        :>        uint i;
                        :>        uchar uci,c;
                        :>        uchar sock,state;
                        :>        xdata HTTP_INFO *pinfo;
                        :>
                        :>        uint sendlen;           // Temp. Len
                        :>        xdata uchar *pbuf;      // Temp. Buffer
                        :>        
                        :>        res=poll_net();
                        :>
                        :>        // First check if a socket is pending
                        :>        if(!res && csock!=0xFF && http_info[csock].html_state==3 &&  !notready_socket_tcp(csock,RDY_4_
co:0d1f: e5 20          :  mov A,?poll_webserver_res
co:0d21: 45 21          :  orl A,?poll_webserver_res+1
co:0d23: 60 03          :  jz ?_16
co:0d25: 02 0d 7e       :  ljmp ?27
                        : ?_16:
co:0d28: 90 00 07       :  mov DPTR,#_csock
co:0d2b: e0             :  movx A,@DPTR
co:0d2c: fb             :  mov R3,A
co:0d2d: f4             :  cpl A
co:0d2e: 70 03          :  jnz ?_17
co:0d30: 02 0d 7e       :  ljmp ?27
                        : ?_17:
co:0d33: af 03          :  mov R7,AR3
co:0d35: e4             :  clr A
co:0d36: fe             :  mov R6,A
co:0d37: fc             :  mov R4,A
co:0d38: 7d 06          :  mov R5,#6
co:0d3a: 12 22 2a       :  lcall __mul_i2
co:0d3d: 7c 02          :  mov R4,#((_http_info)>>8)&255
co:0d3f: 7d ea          :  mov R5,#(_http_info)&255
co:0d41: ed             :  mov A,R5
co:0d42: 2f             :  add A,R7
co:0d43: ff             :  mov R7,A
co:0d44: ec             :  mov A,R4
co:0d45: 3e             :  addc A,R6
co:0d46: fe             :  mov R6,A
co:0d47: 85 06 83       :  mov DPH,AR6
co:0d4a: 85 07 82       :  mov DPL,AR7
co:0d4d: e0             :  movx A,@DPTR
co:0d4e: ff             :  mov R7,A
co:0d4f: bf 03 2c       :  cjne R7,#3,?27
co:0d52: 7d 01          :  mov R5,#1
co:0d54: af 03          :  mov R7,AR3
co:0d56: 12 17 f0       :  lcall _notready_socket_tcp
co:0d59: ee             :  mov A,R6
co:0d5a: 4f             :  orl A,R7
co:0d5b: 70 21          :  jnz ?27
                        : 
co:0d5d: 90 00 07       :  mov DPTR,#_csock
co:0d60: e0             :  movx A,@DPTR
co:0d61: ff             :  mov R7,A
co:0d62: e4             :  clr A
co:0d63: fe             :  mov R6,A
co:0d64: 2f             :  add A,R7
co:0d65: ff             :  mov R7,A
co:0d66: 74 f5          :  mov A,#245
co:0d68: 3e             :  addc A,R6
co:0d69: fe             :  mov R6,A
co:0d6a: 8e 20          :  mov ?poll_webserver_res,R6
co:0d6c: 8f 21          :  mov ?poll_webserver_res+1,R7
                        :>                // Patch EVENT
                        :>                res=EVENT_TCP_DATARECEIVED+csock;
                        :>                rcv_len=0;
co:0d6e: 90 02 0e       :  mov DPTR,#_rcv_len
co:0d71: e4             :  clr A
co:0d72: f0             :  movx @DPTR,A
co:0d73: a3             :  inc DPTR
co:0d74: f0             :  movx @DPTR,A
                        :>                csock=0xFF;
co:0d75: 90 00 07       :  mov DPTR,#_csock
co:0d78: 74 ff          :  mov A,#255
co:0d7a: f0             :  movx @DPTR,A
                        :>        }else if(res==EVENT_SOCKET_IDLETIMER){
co:0d7b: 02 0d de       :  ljmp ?28
                        : ?27:
                        : 
co:0d7e: ae 20          :  mov R6,?poll_webserver_res
co:0d80: af 21          :  mov R7,?poll_webserver_res+1
co:0d82: bf 00 05       :  cjne R7,#0,?_21
co:0d85: be d4 02       :  cjne R6,#212,?_21
co:0d88: 80 03          :  sjmp ?_22
                        : ?_21:
co:0d8a: 02 0d de       :  ljmp ?29
                        : ?_22:
                        :  ; variable 'uci' allocated as 'auto'
                        : 
co:0d8d: e4             :  clr A
co:0d8e: f5 22          :  mov ?poll_webserver_uci,A
                        : ?31:
                        :>                for(uci=0;uci<MAX_SOCK;uci++){
co:0d90: af 22          :  mov R7,?poll_webserver_uci
co:0d92: e4             :  clr A
co:0d93: fe             :  mov R6,A
co:0d94: fc             :  mov R4,A
co:0d95: 7d 06          :  mov R5,#6
co:0d97: 12 22 2a       :  lcall __mul_i2
co:0d9a: 7c 02          :  mov R4,#((_http_info)>>8)&255
co:0d9c: 7d ea          :  mov R5,#(_http_info)&255
co:0d9e: ed             :  mov A,R5
co:0d9f: 2f             :  add A,R7
co:0da0: ff             :  mov R7,A
co:0da1: ec             :  mov A,R4
co:0da2: 3e             :  addc A,R6
co:0da3: fe             :  mov R6,A
co:0da4: 85 06 83       :  mov DPH,AR6
co:0da7: 85 07 82       :  mov DPL,AR7
co:0daa: e0             :  movx A,@DPTR
co:0dab: fd             :  mov R5,A
co:0dac: 7f 03          :  mov R7,#3
co:0dae: c3             :  clr C
co:0daf: ed             :  mov A,R5
co:0db0: 9f             :  subb A,R7
co:0db1: 40 20          :  jc ?35
co:0db3: 7d 01          :  mov R5,#1
co:0db5: af 22          :  mov R7,?poll_webserver_uci
co:0db7: 12 17 f0       :  lcall _notready_socket_tcp
co:0dba: ee             :  mov A,R6
co:0dbb: 4f             :  orl A,R7
co:0dbc: 70 15          :  jnz ?35
                        :>                        if(http_info[uci].html_state>=3 &&  !notready_socket_tcp(uci,RDY_4_TX)){
co:0dbe: af 22          :  mov R7,?poll_webserver_uci
co:0dc0: e4             :  clr A
co:0dc1: fe             :  mov R6,A
co:0dc2: 2f             :  add A,R7
co:0dc3: ff             :  mov R7,A
co:0dc4: 74 f5          :  mov A,#245
co:0dc6: 3e             :  addc A,R6
co:0dc7: fe             :  mov R6,A
co:0dc8: 8e 20          :  mov ?poll_webserver_res,R6
co:0dca: 8f 21          :  mov ?poll_webserver_res+1,R7
                        :>                                // Patch EVENT (simulate a received 0-size segment)
                        :>                                res=EVENT_TCP_DATARECEIVED+uci;
                        :>                                rcv_len=0;
co:0dcc: 90 02 0e       :  mov DPTR,#_rcv_len
co:0dcf: e4             :  clr A
co:0dd0: f0             :  movx @DPTR,A
co:0dd1: a3             :  inc DPTR
co:0dd2: f0             :  movx @DPTR,A
                        :>                        }
                        : ?35:
                        :>                }
co:0dd3: 05 22          :  inc ?poll_webserver_uci
                        : 
co:0dd5: 74 02          :  mov A,#2
co:0dd7: 65 22          :  xrl A,?poll_webserver_uci
co:0dd9: 60 03          :  jz ?_25
co:0ddb: 02 0d 90       :  ljmp ?31
                        : ?_25:
                        :>        }
                        : ?29:
                        : ?28:
                        :>
                        :>        // Received a TCP_EVENT. Could indicate received data or a closure of the TCP socket
                        :>        if(res>=0xF000){
co:0dde: 7c f0          :  mov R4,#240
co:0de0: 7d 00          :  mov R5,#0
co:0de2: ae 20          :  mov R6,?poll_webserver_res
co:0de4: af 21          :  mov R7,?poll_webserver_res+1
co:0de6: c3             :  clr C
co:0de7: ef             :  mov A,R7
co:0de8: 9d             :  subb A,R5
co:0de9: ee             :  mov A,R6
co:0dea: 9c             :  subb A,R4
co:0deb: 50 03          :  jnc ?_26
co:0ded: 02 0f d3       :  ljmp ?37
                        : ?_26:
                        : 
co:0df0: ae 20          :  mov R6,?poll_webserver_res
co:0df2: af 21          :  mov R7,?poll_webserver_res+1
                        :  ; variable 'sock' allocated as 'auto'
co:0df4: 8f 22          :  mov ?poll_webserver_sock,R7
                        :>                sock=(uchar)res;        // isolate socket index
                        :>
                        :>                // Only process HTTP-Sockets!
                        :>                if(uc_socket[sock].local_port!=80) return res;
co:0df6: af 22          :  mov R7,?poll_webserver_sock
co:0df8: e4             :  clr A
co:0df9: fe             :  mov R6,A
co:0dfa: fc             :  mov R4,A
co:0dfb: 7d 32          :  mov R5,#50
co:0dfd: 12 22 2a       :  lcall __mul_i2
co:0e00: 7c 02          :  mov R4,#((_uc_socket+14)>>8)&255
co:0e02: 7d 82          :  mov R5,#(_uc_socket+14)&255
co:0e04: ed             :  mov A,R5
co:0e05: 2f             :  add A,R7
co:0e06: ff             :  mov R7,A
co:0e07: ec             :  mov A,R4
co:0e08: 3e             :  addc A,R6
co:0e09: fe             :  mov R6,A
co:0e0a: 8e 83          :  mov DPH,R6
co:0e0c: 8f 82          :  mov DPL,R7
co:0e0e: 12 0a af       :  lcall __ld_dptr_r67
co:0e11: ef             :  mov A,R7
co:0e12: 64 50          :  xrl A,#80
co:0e14: 70 03          :  jnz ?_27
co:0e16: ee             :  mov A,R6
co:0e17: 60 07          :  jz ?39
                        : ?_27:
                        : 
co:0e19: ae 20          :  mov R6,?poll_webserver_res
co:0e1b: af 21          :  mov R7,?poll_webserver_res+1
co:0e1d: 02 0f d7       :  ljmp ?26
                        : ?39:
                        :>
                        :>                pinfo=&http_info[sock]; // Pointer to HTTP_INFO for the current socket
co:0e20: af 22          :  mov R7,?poll_webserver_sock
co:0e22: e4             :  clr A
co:0e23: fe             :  mov R6,A
co:0e24: fc             :  mov R4,A
co:0e25: 7d 06          :  mov R5,#6
co:0e27: 12 22 2a       :  lcall __mul_i2
co:0e2a: 7c 02          :  mov R4,#((_http_info)>>8)&255
co:0e2c: 7d ea          :  mov R5,#(_http_info)&255
co:0e2e: ed             :  mov A,R5
co:0e2f: 2f             :  add A,R7
co:0e30: ff             :  mov R7,A
co:0e31: ec             :  mov A,R4
co:0e32: 3e             :  addc A,R6
co:0e33: fe             :  mov R6,A
                        :  ; variable 'pinfo' allocated as 'auto'
co:0e34: 8e 23          :  mov ?poll_webserver_pinfo,R6
co:0e36: 8f 24          :  mov ?poll_webserver_pinfo+1,R7
                        :>
                        :>                state=pinfo->html_state;
co:0e38: 85 23 83       :  mov DPH,?poll_webserver_pinfo
co:0e3b: 85 24 82       :  mov DPL,?poll_webserver_pinfo+1
co:0e3e: e0             :  movx A,@DPTR
co:0e3f: ff             :  mov R7,A
                        :  ; variable 'state' allocated as 'auto'
co:0e40: 8f 25          :  mov ?poll_webserver_state,R7
                        :>                
                        :>                // *** RECEIVED DATA ***
                        :>                if((res&0xFF00)==EVENT_TCP_DATARECEIVED){
co:0e42: ae 20          :  mov R6,?poll_webserver_res
co:0e44: af 21          :  mov R7,?poll_webserver_res+1
co:0e46: 7f 00          :  mov R7,#0
co:0e48: bf 00 05       :  cjne R7,#0,?_29
co:0e4b: be f5 02       :  cjne R6,#245,?_29
co:0e4e: 80 03          :  sjmp ?_30
                        : ?_29:
co:0e50: 02 0f b7       :  ljmp ?41
                        : ?_30:
                        : 
co:0e53: e4             :  clr A
co:0e54: f8             :  mov R0,A
co:0e55: f9             :  mov R1,A
                        :  ; variable 'res' assigned to register 'RW01'
                        :>#if 0 // Disabled (enable only for debugging)
                        :>                        // Show request...
                        :>                        for(i=0;i<rcv_len;i++){
                        :>                                c=rcv_buf[i];
                        :>                                if(c=='\r') putsl("<CR>");
                        :>                                else if(c=='\n') puts("<LF>");
                        :>                                else putchar(c);
                        :>                        }
                        :>#endif
                        :>                        res=0;  // This is our new return EVENT (default: nothing)
                        :>                        // Parse request
                        :>                        for(i=0;i<rcv_len;i++){
co:0e56: e4             :  clr A
co:0e57: fa             :  mov R2,A
co:0e58: fb             :  mov R3,A
                        :  ; variable 'i' assigned to register 'RW23'
co:0e59: 02 0f 0d       :  ljmp ?46
                        : ?43:
                        : 
co:0e5c: 7e 02          :  mov R6,#((_rcv_buf)>>8)&255
co:0e5e: 7f 10          :  mov R7,#(_rcv_buf)&255
co:0e60: ef             :  mov A,R7
co:0e61: 2b             :  add A,R3
co:0e62: ff             :  mov R7,A
co:0e63: ee             :  mov A,R6
co:0e64: 3a             :  addc A,R2
co:0e65: fe             :  mov R6,A
co:0e66: 85 06 83       :  mov DPH,AR6
co:0e69: 85 07 82       :  mov DPL,AR7
co:0e6c: e0             :  movx A,@DPTR
co:0e6d: ff             :  mov R7,A
                        :  ; variable 'c' assigned to register 'B '
co:0e6e: 8f f0          :  mov B,R7
                        :>                                c=rcv_buf[i];
                        :>
                        :>                                switch(state){
co:0e70: e5 25          :  mov A,?poll_webserver_state
co:0e72: 60 17          :  jz ?49
co:0e74: af 25          :  mov R7,?poll_webserver_state
co:0e76: ef             :  mov A,R7
co:0e77: 64 01          :  xrl A,#1
co:0e79: 70 03          :  jnz ?_32
co:0e7b: 02 0e e8       :  ljmp ?52
                        : ?_32:
co:0e7e: af 25          :  mov R7,?poll_webserver_state
co:0e80: ef             :  mov A,R7
co:0e81: 64 02          :  xrl A,#2
co:0e83: 70 03          :  jnz ?_33
co:0e85: 02 0e f3       :  ljmp ?55
                        : ?_33:
co:0e88: 02 0f 08       :  ljmp ?47
                        : 
                        : ?49:
                        :>                                case 0:
                        :>                                        if(c=='G' && i==0){     // Assume a GET
co:0e8b: 74 47          :  mov A,#71
co:0e8d: 65 f0          :  xrl A,B
co:0e8f: 60 03          :  jz ?_34
co:0e91: 02 0f 08       :  ljmp ?48
                        : ?_34:
co:0e94: ea             :  mov A,R2
co:0e95: 4b             :  orl A,R3
co:0e96: 60 03          :  jz ?_35
co:0e98: 02 0f 08       :  ljmp ?48
                        : ?_35:
                        : 
co:0e9b: 75 25 01       :  mov ?poll_webserver_state,#1
                        :>                                                state=1;
                        :>                                                // Emit a HTTP-Request
                        :>                                                res=EVENT_HTTP_REQUEST+sock;
co:0e9e: af 22          :  mov R7,?poll_webserver_sock
co:0ea0: e4             :  clr A
co:0ea1: fe             :  mov R6,A
co:0ea2: 2f             :  add A,R7
co:0ea3: f9             :  mov R1,A
co:0ea4: 74 90          :  mov A,#144
co:0ea6: 3e             :  addc A,R6
co:0ea7: f8             :  mov R0,A
                        :>                
                        :>                                                // Set Default Reply to NotFound
                        :>                                                pinfo->pweb=html_notfound;
co:0ea8: ae 23          :  mov R6,?poll_webserver_pinfo
co:0eaa: af 24          :  mov R7,?poll_webserver_pinfo+1
co:0eac: 74 02          :  mov A,#2
co:0eae: 2f             :  add A,R7
co:0eaf: fd             :  mov R5,A
co:0eb0: e4             :  clr A
co:0eb1: 3e             :  addc A,R6
co:0eb2: fc             :  mov R4,A
co:0eb3: 7e 16          :  mov R6,#((_html_notfound)>>8)&255
co:0eb5: 7f 0b          :  mov R7,#(_html_notfound)&255
co:0eb7: 8c 83          :  mov DPH,R4
co:0eb9: 8d 82          :  mov DPL,R5
co:0ebb: 12 0a c1       :  lcall __st_dptr_r67
                        :>                                                pinfo->weblen=sizeof(html_notfound);
co:0ebe: ae 23          :  mov R6,?poll_webserver_pinfo
co:0ec0: af 24          :  mov R7,?poll_webserver_pinfo+1
co:0ec2: 74 04          :  mov A,#4
co:0ec4: 2f             :  add A,R7
co:0ec5: fd             :  mov R5,A
co:0ec6: e4             :  clr A
co:0ec7: 3e             :  addc A,R6
co:0ec8: fc             :  mov R4,A
co:0ec9: 7e 00          :  mov R6,#0
co:0ecb: 7f e5          :  mov R7,#229
co:0ecd: 8c 83          :  mov DPH,R4
co:0ecf: 8d 82          :  mov DPL,R5
co:0ed1: 12 0a c1       :  lcall __st_dptr_r67
                        :>                                                pinfo->dyna_flag=1; // With interpretation! (because H
co:0ed4: ae 23          :  mov R6,?poll_webserver_pinfo
co:0ed6: af 24          :  mov R7,?poll_webserver_pinfo+1
co:0ed8: 0f             :  inc R7
co:0ed9: ef             :  mov A,R7
co:0eda: 70 01          :  jnz ?__3
co:0edc: 0e             :  inc R6
                        : ?__3:
co:0edd: 85 06 83       :  mov DPH,AR6
co:0ee0: 85 07 82       :  mov DPL,AR7
co:0ee3: 74 01          :  mov A,#1
co:0ee5: f0             :  movx @DPTR,A
                        :>                                                
                        :>                                        }
co:0ee6: 80 20          :  sjmp ?48
                        : ?52:
                        :>                                        break;
                        :>                                case 1: // Wait for a EOL after chars were found
                        :>                                        if(c=='\n') state=2;
co:0ee8: 74 0a          :  mov A,#10
co:0eea: 65 f0          :  xrl A,B
co:0eec: 70 1a          :  jnz ?48
                        : 
co:0eee: 75 25 02       :  mov ?poll_webserver_state,#2
                        :>                                        break;
co:0ef1: 80 15          :  sjmp ?48
                        : ?55:
                        :>                                case 2: // Rec. new line, CR LF marks end of HTTP_Request
                        :>                                        if(c=='\n') {
co:0ef3: 74 0a          :  mov A,#10
co:0ef5: 65 f0          :  xrl A,B
co:0ef7: 70 05          :  jnz ?56
                        : 
co:0ef9: 75 25 03       :  mov ?poll_webserver_state,#3
                        :>                                                state=3;        // CR LF: End of Request
                        :>                                        }else {
co:0efc: 80 0a          :  sjmp ?57
                        : ?56:
                        : 
co:0efe: af f0          :  mov R7,B
co:0f00: ef             :  mov A,R7
co:0f01: 64 0d          :  xrl A,#13
co:0f03: 60 03          :  jz ?58
                        :>                                                if(c!='\r') state=1;    // ignore all visible chars
co:0f05: 75 25 01       :  mov ?poll_webserver_state,#1
                        : ?58:
                        :>                                        }
                        : ?57:
                        :>                                } // switch
                        : ?47:
                        : ?48:
                        :>                        } // for
co:0f08: 0b             :  inc R3
co:0f09: eb             :  mov A,R3
co:0f0a: 70 01          :  jnz ?__4
co:0f0c: 0a             :  inc R2
                        : ?__4:
                        : ?46:
                        : 
co:0f0d: 90 02 0e       :  mov DPTR,#_rcv_len
co:0f10: 12 0a af       :  lcall __ld_dptr_r67
co:0f13: c3             :  clr C
co:0f14: eb             :  mov A,R3
co:0f15: 9f             :  subb A,R7
co:0f16: ea             :  mov A,R2
co:0f17: 9e             :  subb A,R6
co:0f18: 50 03          :  jnc ?_39
co:0f1a: 02 0e 5c       :  ljmp ?43
                        : ?_39:
                        :>
                        :>                        // Inform User about page request
                        :>                        if(res) {
co:0f1d: e8             :  mov A,R0
co:0f1e: 49             :  orl A,R1
co:0f1f: 60 11          :  jz ?60
                        : 
co:0f21: af 25          :  mov R7,?poll_webserver_state
co:0f23: 85 23 83       :  mov DPH,?poll_webserver_pinfo
co:0f26: 85 24 82       :  mov DPL,?poll_webserver_pinfo+1
co:0f29: ef             :  mov A,R7
co:0f2a: f0             :  movx @DPTR,A
                        :>                                pinfo->html_state=state;        // Keep state
                        :>                                return res;                     // And return (0 or REQUEST) to the us
co:0f2b: ae 00          :  mov R6,AR0
co:0f2d: af 01          :  mov R7,AR1
co:0f2f: 02 0f d7       :  ljmp ?26
                        : ?60:
                        :>                        }
                        :>
                        :>                        // Try to send data for states 3 and 4
                        :>                        if(state>=3){
co:0f32: 7d 03          :  mov R5,#3
co:0f34: af 25          :  mov R7,?poll_webserver_state
co:0f36: c3             :  clr C
co:0f37: ef             :  mov A,R7
co:0f38: 9d             :  subb A,R5
co:0f39: 50 03          :  jnc ?_41
co:0f3b: 02 0f a8       :  ljmp ?62
                        : ?_41:
                        : 
co:0f3e: 7d 01          :  mov R5,#1
co:0f40: af 22          :  mov R7,?poll_webserver_sock
co:0f42: 12 17 f0       :  lcall _notready_socket_tcp
co:0f45: ee             :  mov A,R6
co:0f46: 4f             :  orl A,R7
co:0f47: 60 03          :  jz ?_42
co:0f49: 02 0f a5       :  ljmp ?64
                        : ?_42:
                        :>                                if(!notready_socket_tcp(sock,RDY_4_TX)){
co:0f4c: 75 25 03       :  mov ?poll_webserver_state,#3
                        :>                                        state=3;
                        :>                                        if(pinfo->weblen){      // There is still something to send
co:0f4f: ae 23          :  mov R6,?poll_webserver_pinfo
co:0f51: af 24          :  mov R7,?poll_webserver_pinfo+1
co:0f53: 74 04          :  mov A,#4
co:0f55: 2f             :  add A,R7
co:0f56: ff             :  mov R7,A
co:0f57: e4             :  clr A
co:0f58: 3e             :  addc A,R6
co:0f59: fe             :  mov R6,A
co:0f5a: 8e 83          :  mov DPH,R6
co:0f5c: 8f 82          :  mov DPL,R7
co:0f5e: 12 0a af       :  lcall __ld_dptr_r67
co:0f61: ee             :  mov A,R6
co:0f62: 4f             :  orl A,R7
co:0f63: 60 28          :  jz ?66
                        : 
co:0f65: 12 2c 6f       :  lcall _allocate_tx_buf
                        :  ; variable 'pbuf' allocated as 'auto'
co:0f68: 8e 26          :  mov ?poll_webserver_pbuf,R6
co:0f6a: 8f 27          :  mov ?poll_webserver_pbuf+1,R7
                        :>                                                pbuf=allocate_tx_buf(); // Allocate a buffer
                        :>                                                sendlen=gendyn_html(pinfo,pbuf); // Fill Buffer
co:0f6c: ac 26          :  mov R4,?poll_webserver_pbuf
co:0f6e: ad 27          :  mov R5,?poll_webserver_pbuf+1
co:0f70: ae 23          :  mov R6,?poll_webserver_pinfo
co:0f72: af 24          :  mov R7,?poll_webserver_pinfo+1
co:0f74: 12 10 30       :  lcall _gendyn_html
                        :  ; variable 'sendlen' assigned to register 'RW67'
                        :>                                                send_socket_tcp(sock, pbuf, sendlen); // Send buffer (
co:0f77: aa 06          :  mov R2,AR6
co:0f79: ab 07          :  mov R3,AR7
co:0f7b: ac 26          :  mov R4,?poll_webserver_pbuf
co:0f7d: ad 27          :  mov R5,?poll_webserver_pbuf+1
co:0f7f: af 22          :  mov R7,?poll_webserver_sock
co:0f81: 12 1d 46       :  lcall _send_socket_tcp
                        :>                                                csock=sock;     // Could send something, retry soon!
co:0f84: af 22          :  mov R7,?poll_webserver_sock
co:0f86: 90 00 07       :  mov DPTR,#_csock
co:0f89: ef             :  mov A,R7
co:0f8a: f0             :  movx @DPTR,A
                        :>                                        }else{ // Manually close only dynamic Pages...
co:0f8b: 80 1b          :  sjmp ?65
                        : ?66:
                        : 
co:0f8d: 75 25 04       :  mov ?poll_webserver_state,#4
                        :>                                                state=4;        // Waiting for close could block other
                        :>                                                if(!notready_socket_tcp(sock,RDY_4_CLOSE)){
co:0f90: e4             :  clr A
co:0f91: fd             :  mov R5,A
co:0f92: af 22          :  mov R7,?poll_webserver_sock
co:0f94: 12 17 f0       :  lcall _notready_socket_tcp
co:0f97: ee             :  mov A,R6
co:0f98: 4f             :  orl A,R7
co:0f99: 70 0d          :  jnz ?65
                        : 
co:0f9b: e4             :  clr A
co:0f9c: f5 25          :  mov ?poll_webserver_state,A
                        :>                                                        state=0;
                        :>                                                        close_socket_tcp(sock);
co:0f9e: af 22          :  mov R7,?poll_webserver_sock
co:0fa0: 12 1e 98       :  lcall _close_socket_tcp
                        :>                                                }
co:0fa3: 80 03          :  sjmp ?65
                        : ?64:
                        :>                                        }
                        :>
                        :>                                }else{ // !notready
co:0fa5: 75 25 04       :  mov ?poll_webserver_state,#4
                        :>                                        state=4; // Mark socket as pending, try in 500 msec again
                        :>                                }
                        : ?65:
                        :>
                        :>                        }
                        : ?62:
                        :>                        pinfo->html_state=state;        // Keep state
co:0fa8: af 25          :  mov R7,?poll_webserver_state
co:0faa: 85 23 83       :  mov DPH,?poll_webserver_pinfo
co:0fad: 85 24 82       :  mov DPL,?poll_webserver_pinfo+1
co:0fb0: ef             :  mov A,R7
co:0fb1: f0             :  movx @DPTR,A
                        :>                        return 0;                       // Ignore Webserver maintained events
co:0fb2: e4             :  clr A
co:0fb3: fe             :  mov R6,A
co:0fb4: ff             :  mov R7,A
co:0fb5: 80 20          :  sjmp ?26
                        : ?41:
                        :>
                        :>                }else if(res>=0xF800){ // all Events >=0xF800 close TCP Connections.
co:0fb7: 7c f8          :  mov R4,#248
co:0fb9: 7d 00          :  mov R5,#0
co:0fbb: ae 20          :  mov R6,?poll_webserver_res
co:0fbd: af 21          :  mov R7,?poll_webserver_res+1
co:0fbf: c3             :  clr C
co:0fc0: ef             :  mov A,R7
co:0fc1: 9d             :  subb A,R5
co:0fc2: ee             :  mov A,R6
co:0fc3: 9c             :  subb A,R4
co:0fc4: 40 0d          :  jc ?70
                        : 
co:0fc6: 85 23 83       :  mov DPH,?poll_webserver_pinfo
co:0fc9: 85 24 82       :  mov DPL,?poll_webserver_pinfo+1
co:0fcc: e4             :  clr A
co:0fcd: f0             :  movx @DPTR,A
                        :>                        pinfo->html_state=0;    // ALL other TCP_EVENTS close the socket (ensured by d
                        :>                        return 0;               // Ignore this Event, socket is maintained by webserve
co:0fce: e4             :  clr A
co:0fcf: fe             :  mov R6,A
co:0fd0: ff             :  mov R7,A
co:0fd1: 80 04          :  sjmp ?26
                        : ?70:
                        :>                }
                        :>        }
                        : ?37:
                        :>        return res;
co:0fd3: ae 20          :  mov R6,?poll_webserver_res
co:0fd5: af 21          :  mov R7,?poll_webserver_res+1
                        : ?26:
co:0fd7: 22             :  ret
                        : ; end of function poll_webserver
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:8 bytes
                        : 
                        :  .export _webpage_name ; xdata unsigned char *webpage_name(void)
                        :  .segment _webpage_name_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _webpage_name_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _webpage_name_formal_near, _webpage_name_local_near, __webpage_name
                        : 
                        :  .segment __webpage_name
                        : _webpage_name: ; (leaf function) xdata unsigned char *webpage_name(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>*  webpage_name(): Return the Name of the requested page. 
                        :>*
                        :>* Attention: Maybe called only ONCE, because terminates URL-String
                        :>**********************************************************************************/
                        :>xdata uchar * webpage_name(void){
co:1796: 7c 02          :  mov R4,#((_rcv_buf+5)>>8)&255
co:1798: 7d 15          :  mov R5,#(_rcv_buf+5)&255
                        :  ; variable 'pc' assigned to register 'RW45'
                        :>        uchar c;
                        :>        xdata uchar *pc=rcv_buf+5;      // Kill GET slash (5 chars)
                        :>        web_args=0;             // Assume NO Arguments
co:179a: e4             :  clr A
co:179b: fe             :  mov R6,A
co:179c: ff             :  mov R7,A
co:179d: 90 02 e8       :  mov DPTR,#_web_args
co:17a0: 12 0a c1       :  lcall __st_dptr_r67
                        :>        rcv_buf[MAX_RX-1]=0;    // Prevent Buffer overread
co:17a3: 90 02 73       :  mov DPTR,#_rcv_buf+99
co:17a6: e4             :  clr A
co:17a7: f0             :  movx @DPTR,A
                        :>        for(;;){
                        : ?74:
                        : 
co:17a8: 85 04 83       :  mov DPH,AR4
co:17ab: 85 05 82       :  mov DPL,AR5
co:17ae: e0             :  movx A,@DPTR
co:17af: fb             :  mov R3,A
                        :  ; variable 'c' assigned to register 'R3'
                        :>                c=*pc;
                        :>                if(c=='?') {
co:17b0: bb 3f 0f       :  cjne R3,#63,?78
                        : 
co:17b3: 74 01          :  mov A,#1
co:17b5: 2d             :  add A,R5
co:17b6: ff             :  mov R7,A
co:17b7: e4             :  clr A
co:17b8: 3c             :  addc A,R4
co:17b9: fe             :  mov R6,A
co:17ba: 90 02 e8       :  mov DPTR,#_web_args
co:17bd: 12 0a c1       :  lcall __st_dptr_r67
                        :>                        web_args=pc+1;
                        :>                        break;
co:17c0: 80 0e          :  sjmp ?76
                        : ?78:
                        :>                }else  if(c<=' ') break;
co:17c2: 7f 20          :  mov R7,#32
co:17c4: d3             :  setb C
co:17c5: eb             :  mov A,R3
co:17c6: 9f             :  subb A,R7
                        : 
co:17c7: 40 07          :  jc ?76
                        :>                pc++;
co:17c9: 0d             :  inc R5
co:17ca: ed             :  mov A,R5
co:17cb: 70 01          :  jnz ?__5
co:17cd: 0c             :  inc R4
                        : ?__5:
                        :>        }
co:17ce: 80 d8          :  sjmp ?74
                        : ?76:
                        :>        *pc=0;
co:17d0: 85 04 83       :  mov DPH,AR4
co:17d3: 85 05 82       :  mov DPL,AR5
co:17d6: e4             :  clr A
co:17d7: f0             :  movx @DPTR,A
                        :>        return rcv_buf+5;
co:17d8: 7e 02          :  mov R6,#((_rcv_buf+5)>>8)&255
co:17da: 7f 15          :  mov R7,#(_rcv_buf+5)&255
co:17dc: 22             :  ret
                        : ; end of function webpage_name
                        : ; used: R---34567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _url_getarg_no ; unsigned char url_getarg_no(void)
                        :  .segment _url_getarg_no_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _url_getarg_no_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _url_getarg_no_formal_near, _url_getarg_no_local_near, __url_getarg_no
                        : 
                        :  .segment __url_getarg_no
                        : _url_getarg_no: ; (leaf function) unsigned char url_getarg_no(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uchar url_getarg_no(void)
                        :>*
                        :>* Will return the index No of an argument or 0 for none. The Value of an argument
                        :>* can be retrieved with url_getarg_str();
                        :>* All Arguments must be named A1 - A255 or a1-a255
                        :>**********************************************************************************/
                        :>uchar url_getarg_no(void){
co:0473: 90 02 e8       :  mov DPTR,#_web_args
co:0476: 12 0a af       :  lcall __ld_dptr_r67
co:0479: ee             :  mov A,R6
co:047a: 4f             :  orl A,R7
co:047b: 70 05          :  jnz ?83
                        :>        uchar ano;
                        :>        uchar c;
                        :>        if(!web_args) return 0;
co:047d: e4             :  clr A
co:047e: ff             :  mov R7,A
co:047f: 02 04 ea       :  ljmp ?82
                        : ?83:
                        :>        c=*web_args++;
co:0482: 90 02 e8       :  mov DPTR,#_web_args
co:0485: 12 06 c7       :  lcall __ld_dptr_r45
co:0488: 74 01          :  mov A,#1
co:048a: 2d             :  add A,R5
co:048b: ff             :  mov R7,A
co:048c: e4             :  clr A
co:048d: 3c             :  addc A,R4
co:048e: fe             :  mov R6,A
co:048f: 90 02 e8       :  mov DPTR,#_web_args
co:0492: 12 0a c1       :  lcall __st_dptr_r67
co:0495: 85 04 83       :  mov DPH,AR4
co:0498: 85 05 82       :  mov DPL,AR5
co:049b: e0             :  movx A,@DPTR
                        :  ; variable 'c' assigned to register 'R7'
                        :>        if(c!='a' && c!='A') return 0;  // No Arg found!
co:049c: ff             :  mov R7,A
co:049d: 64 61          :  xrl A,#97
co:049f: 60 0a          :  jz ?85
co:04a1: ef             :  mov A,R7
co:04a2: 64 41          :  xrl A,#65
co:04a4: 60 05          :  jz ?85
                        : 
co:04a6: e4             :  clr A
co:04a7: ff             :  mov R7,A
co:04a8: 02 04 ea       :  ljmp ?82
                        : ?85:
                        :>        ano=0;
co:04ab: e4             :  clr A
co:04ac: fb             :  mov R3,A
                        :  ; variable 'ano' assigned to register 'R3'
                        :>        for(;;){
                        : ?87:
                        : 
co:04ad: 90 02 e8       :  mov DPTR,#_web_args
co:04b0: 12 06 c7       :  lcall __ld_dptr_r45
co:04b3: 74 01          :  mov A,#1
co:04b5: 2d             :  add A,R5
co:04b6: ff             :  mov R7,A
co:04b7: e4             :  clr A
co:04b8: 3c             :  addc A,R4
co:04b9: fe             :  mov R6,A
co:04ba: 90 02 e8       :  mov DPTR,#_web_args
co:04bd: 12 0a c1       :  lcall __st_dptr_r67
co:04c0: 85 04 83       :  mov DPH,AR4
co:04c3: 85 05 82       :  mov DPL,AR5
co:04c6: e0             :  movx A,@DPTR
co:04c7: ff             :  mov R7,A
co:04c8: 74 d0          :  mov A,#208
co:04ca: 2f             :  add A,R7
co:04cb: fd             :  mov R5,A
                        :  ; variable 'c' assigned to register 'R5'
                        :>                c=(*web_args++)-'0';
                        :>                if(c>9) break;
co:04cc: 7f 09          :  mov R7,#9
co:04ce: d3             :  setb C
co:04cf: ed             :  mov A,R5
co:04d0: 9f             :  subb A,R7
                        : 
co:04d1: 50 0c          :  jnc ?89
                        :>                ano*=10;
co:04d3: 7f 0a          :  mov R7,#10
co:04d5: eb             :  mov A,R3
co:04d6: 8f f0          :  mov B,R7
co:04d8: a4             :  mul AB
co:04d9: ff             :  mov R7,A
                        :  ; variable 'ano' assigned to register 'R7'
                        :>                ano+=c;
co:04da: ed             :  mov A,R5
co:04db: 2f             :  add A,R7
co:04dc: fb             :  mov R3,A
                        :>        }               
co:04dd: 80 ce          :  sjmp ?87
                        : ?89:
                        :>        if(c!= ('='-'0')) return 0;     // Format error
co:04df: ed             :  mov A,R5
co:04e0: 64 0d          :  xrl A,#13
co:04e2: 60 04          :  jz ?93
                        : 
co:04e4: e4             :  clr A
co:04e5: ff             :  mov R7,A
co:04e6: 80 02          :  sjmp ?82
                        : ?93:
                        :>        return ano;     
co:04e8: af 03          :  mov R7,AR3
                        : ?82:
co:04ea: 22             :  ret
                        : ; end of function url_getarg_no
                        : ; used: R---34567 BR-------- DPTR ACC PSW B
                        : 
                        :  .export _url_getarg_str ; xdata unsigned char *url_getarg_str(void)
                        :  .segment _url_getarg_str_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _url_getarg_str_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _url_getarg_str_formal_near, _url_getarg_str_local_near, __url_getarg_str
                        : 
                        :  .segment __url_getarg_str
                        : _url_getarg_str: ; (leaf function) xdata unsigned char *url_getarg_str(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* xdata uchar url_getarg_str(void)
                        :>*
                        :>* Will return the value of the last identified argument
                        :>**********************************************************************************/
                        :>xdata uchar *url_getarg_str(void){
co:0fd8: 90 02 e8       :  mov DPTR,#_web_args
co:0fdb: 12 06 c1       :  lcall __ld_dptr_r23
                        :  ; variable 'ret' assigned to register 'RW23'
                        :>        xdata uchar *ret;
                        :>         uchar c;
                        :>        ret=web_args;
                        :>        for(;;){
                        : ?98:
                        : 
co:0fde: 90 02 e8       :  mov DPTR,#_web_args
co:0fe1: 12 0a af       :  lcall __ld_dptr_r67
co:0fe4: 85 06 83       :  mov DPH,AR6
co:0fe7: 85 07 82       :  mov DPL,AR7
co:0fea: e0             :  movx A,@DPTR
                        :  ; variable 'c' assigned to register 'R5'
                        :>                c=*web_args;
                        :>                if(c=='&' || c<=' ') break;
co:0feb: fd             :  mov R5,A
co:0fec: 64 26          :  xrl A,#38
co:0fee: 60 07          :  jz ?104
co:0ff0: 7f 20          :  mov R7,#32
co:0ff2: d3             :  setb C
co:0ff3: ed             :  mov A,R5
co:0ff4: 9f             :  subb A,R7
co:0ff5: 50 02          :  jnc ?102
                        : ?104:
                        : 
co:0ff7: 80 13          :  sjmp ?100
                        : ?102:
                        :>                web_args++;     // Read over
co:0ff9: 90 02 e8       :  mov DPTR,#_web_args
co:0ffc: 12 0a af       :  lcall __ld_dptr_r67
co:0fff: 0f             :  inc R7
co:1000: ef             :  mov A,R7
co:1001: 70 01          :  jnz ?__6
co:1003: 0e             :  inc R6
                        : ?__6:
co:1004: 90 02 e8       :  mov DPTR,#_web_args
co:1007: 12 0a c1       :  lcall __st_dptr_r67
                        :>        }               
co:100a: 80 d2          :  sjmp ?98
                        : ?100:
                        :>        *web_args=0;    // Terminate string for this argument
co:100c: 90 02 e8       :  mov DPTR,#_web_args
co:100f: 12 0a af       :  lcall __ld_dptr_r67
co:1012: 85 06 83       :  mov DPH,AR6
co:1015: 85 07 82       :  mov DPL,AR7
co:1018: e4             :  clr A
co:1019: f0             :  movx @DPTR,A
                        :>        web_args++;     // and set to next Arg.
co:101a: 90 02 e8       :  mov DPTR,#_web_args
co:101d: 12 0a af       :  lcall __ld_dptr_r67
co:1020: 0f             :  inc R7
co:1021: ef             :  mov A,R7
co:1022: 70 01          :  jnz ?__7
co:1024: 0e             :  inc R6
                        : ?__7:
co:1025: 90 02 e8       :  mov DPTR,#_web_args
co:1028: 12 0a c1       :  lcall __st_dptr_r67
                        :>        return ret;
co:102b: ae 02          :  mov R6,AR2
co:102d: af 03          :  mov R7,AR3
co:102f: 22             :  ret
                        : ; end of function url_getarg_str
                        : ; used: R--23-567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _webpage_bind ; void webpage_bind(unsigned char, code unsigned char *)
                        :  .segment _webpage_bind_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _webpage_bind_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _webpage_bind_formal_near, _webpage_bind_local_near, __webpage_bind
                        : 
                        :  .segment __webpage_bind
                        : _webpage_bind: ; (leaf function) void webpage_bind(unsigned char, code unsigned char *)
                        :  ; parameter 'pd' in 'RW45' assigned to 'B1_RW89'
                        :  ; parameter 'sock' in 'R7'
co:1720: 8c 08          :  mov AR8,R4
co:1722: 8d 09          :  mov AR9,R5
                        :>}
                        :>
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* webpage_bind(uchar socket, code unsigned char *pd)
                        :>* This will bind a webpage to a given socket, after a HTTP-Request was received
                        :>* for this page.
                        :>**********************************************************************************/
                        :>void webpage_bind(uchar sock, code unsigned char *pd){
co:1724: ad 07          :  mov R5,AR7
co:1726: e4             :  clr A
co:1727: fc             :  mov R4,A
co:1728: fe             :  mov R6,A
co:1729: 7f 06          :  mov R7,#6
co:172b: 12 22 2a       :  lcall __mul_i2
co:172e: 7a 02          :  mov R2,#((_http_info)>>8)&255
co:1730: 7b ea          :  mov R3,#(_http_info)&255
co:1732: eb             :  mov A,R3
co:1733: 2f             :  add A,R7
co:1734: f9             :  mov R1,A
co:1735: ea             :  mov A,R2
co:1736: 3e             :  addc A,R6
co:1737: f8             :  mov R0,A
                        :  ; variable 'pinfo' assigned to register 'RW01'
                        :>        xdata HTTP_INFO *pinfo;
                        :>        pinfo=&http_info[sock]; // Pointer to HTTP_INFO for the current socket
                        :>
                        :>        pinfo->weblen=*((code uint*)pd);
co:1738: ae 08          :  mov R6,AR8
co:173a: af 09          :  mov R7,AR9
co:173c: 8e 83          :  mov DPH,R6
co:173e: 8f 82          :  mov DPL,R7
co:1740: 12 00 16       :  lcall __ldc_dptr_r23
co:1743: 74 04          :  mov A,#4
co:1745: 29             :  add A,R1
co:1746: ff             :  mov R7,A
co:1747: e4             :  clr A
co:1748: 38             :  addc A,R0
co:1749: fe             :  mov R6,A
co:174a: 8e 83          :  mov DPH,R6
co:174c: 8f 82          :  mov DPL,R7
co:174e: 12 00 03       :  lcall __st_dptr_r23
                        :>        pd+=2;
co:1751: ae 08          :  mov R6,AR8
co:1753: af 09          :  mov R7,AR9
co:1755: 74 02          :  mov A,#2
co:1757: 2f             :  add A,R7
co:1758: ff             :  mov R7,A
co:1759: e4             :  clr A
co:175a: 3e             :  addc A,R6
co:175b: fe             :  mov R6,A
                        :  ; variable 'pd' assigned to register 'RW67'
                        :>        pinfo->dyna_flag=*pd++;
co:175c: ac 06          :  mov R4,AR6
co:175e: ad 07          :  mov R5,AR7
co:1760: 74 01          :  mov A,#1
co:1762: 2d             :  add A,R5
co:1763: ff             :  mov R7,A
co:1764: e4             :  clr A
co:1765: 3c             :  addc A,R4
co:1766: fe             :  mov R6,A
                        :  ; variable 'pd' assigned to register 'B1_RW89'
co:1767: 8e 08          :  mov AR8,R6
co:1769: 8f 09          :  mov AR9,R7
co:176b: 85 04 83       :  mov DPH,AR4
co:176e: 85 05 82       :  mov DPL,AR5
co:1771: e4             :  clr A
co:1772: 93             :  movc A,@A+DPTR
co:1773: fb             :  mov R3,A
co:1774: 74 01          :  mov A,#1
co:1776: 29             :  add A,R1
co:1777: ff             :  mov R7,A
co:1778: e4             :  clr A
co:1779: 38             :  addc A,R0
co:177a: fe             :  mov R6,A
co:177b: 85 06 83       :  mov DPH,AR6
co:177e: 85 07 82       :  mov DPL,AR7
co:1781: eb             :  mov A,R3
co:1782: f0             :  movx @DPTR,A
                        :>        pinfo->pweb=pd;
co:1783: 74 02          :  mov A,#2
co:1785: 29             :  add A,R1
co:1786: fb             :  mov R3,A
co:1787: e4             :  clr A
co:1788: 38             :  addc A,R0
co:1789: fa             :  mov R2,A
co:178a: ae 08          :  mov R6,AR8
co:178c: af 09          :  mov R7,AR9
co:178e: 8a 83          :  mov DPH,R2
co:1790: 8b 82          :  mov DPL,R3
co:1792: 12 0a c1       :  lcall __st_dptr_r67
co:1795: 22             :  ret
                        : ; end of function webpage_bind
                        : ; used: R01234567 BR01------ DPTR ACC PSW B
                        : 
                        :  .segment bss, sclass xram, notext
                        :  .export _web_args ; xdata unsigned char *xdata web_args
                        : _web_args: ; xdata unsigned char *xdata web_args
xr:02e8: xx xx          :  .ds.b 2
                        :  .export _http_info ; xdata HTTP_INFO http_info[2]
                        : _http_info: ; xdata HTTP_INFO http_info[2]
xr:02ea: xx xx xx xx xx :  .ds.b 12
xr:02ef: xx xx xx xx xx :
xr:02f4: xx xx          :
                        :  .import _poll_net ; unsigned int poll_net(void)
                        :  .import _close_socket_tcp ; unsigned int close_socket_tcp(unsigned char)
                        :  .import _notready_socket_tcp ; unsigned int notready_socket_tcp(unsigned char, unsigned char)
                        :  .import _send_socket_tcp ; unsigned int send_socket_tcp(unsigned char, xdata unsigned char *, unsigne
                        :  .import _allocate_tx_buf ; xdata unsigned char *allocate_tx_buf(void)
                        :  .import _rcv_len ; xdata unsigned int rcv_len
                        :  .import _rcv_buf ; xdata unsigned char rcv_buf[100]
                        :  .import _uc_socket ; xdata UC_SOCKET uc_socket[2]
                        :  .end
                        :>}
                        :>
                        :>// EOF
=        _html_notfound =  160b (hex),   5643 (dez), text
=         _webpage_bind =  1720 (hex),   5920 (dez), text
=            _http_info =   2ea (hex),    746 (dez), xram
=         _webpage_name =  1796 (hex),   6038 (dez), text
=          _gendyn_html =  1030 (hex),   4144 (dez), text
=             _web_args =   2e8 (hex),    744 (dez), xram
=                _csock =     7 (hex),      7 (dez), xram
=       _url_getarg_str =   fd8 (hex),   4056 (dez), text
=        _url_getarg_no =   473 (hex),   1139 (dez), text
=       _poll_webserver =   d18 (hex),   3352 (dez), text

objectfile:fg1_http.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'fg1_http.c', time: Wed Dec 13 13:00:41 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :         .include <reg52.def>
                        : ; **** 80C52 (extended) defs ***
                        : 
                        :         .hide
                        :         .show
                        :         P0    = $80
                        :         sevseg_ctrl  = $C0;
                        :   sevseg_data0 = $C1;
                        :   sevseg_data1 = $C2;
                        :   sevseg_data2 = $C3;
                        :   sevseg_data3 = $C4;
                        :   sevseg_en    = $C5;
                        :   _sevseg_ctrl  = sevseg_ctrl;
                        :   _sevseg_data0 = sevseg_data0;
                        :   _sevseg_data1 = sevseg_data1;
                        :   _sevseg_data2 = sevseg_data2;
                        :   _sevseg_data3 = sevseg_data3;
                        :   _sevseg_en    = sevseg_en;
                        : 
                        :  .export _main ; void main(void)
                        : 
                        : ; *** RESET POINT ***
                        :  .export __reset
                        :  .segment ___reset, org $0
co:0000: 02 01 87       :  __reset: ljmp __startup
                        : 
                        :  .hide
                        :  .show
                        : 
                        :  .segment __main
                        : _main: ; void main(void)
                        :>/*********************************************************************************
                        :>* FG1_HTTP.C
                        :>* 
                        :>* A simple dynamic Webserver on Elektor FPGA Board
                        :>*
                        :>* (C) 2006 Andreas Voggeneder
                        :>**********************************************************************************/
                        :>
                        :>#include <stdio.h>
                        :>#include <string.h> 
                        :>#include <ctype.h>
                        :>#include <reg52.h>
                        :>
                        :>#include "tcpip/net.h"   // Basic network handling (public)
                        :>#include "tcpip/web_serv.h"  // Webserver
                        :>#include "tcpip/open_ether.h"
                        :>
                        :>
                        :>//#define LED P1_B7   // LED on (almost) all Wickenhaeuser boards
                        :>
                        :>// Declaration of the Pages
                        :>extern code unsigned char home[];
                        :>extern code unsigned char form[];
                        :>extern code unsigned char reply[];
                        :>
                        :>
                        :>// For form.html:
                        :>xdata uchar name[21];
                        :>xdata uchar adr[5];
                        :>xdata uchar cont[12];
                        :>
                        :>
                        :>
                        :>
                        :>
                        :>
                        :>/**********************************************************************************
                        :>*  M A I N
                        :>**********************************************************************************/
                        :>void main(void){
co:0b90: 75 89 01       :  mov _TMOD,#1
                        :> uint res;
                        :> uchar i;
                        :> uchar socket;
                        :> xdata uchar *pc;
                        :> 
                        :>  TMOD = 1;
                        :>  SCON = 0x52;    /* SCON */ 
co:0b93: 75 98 52       :  mov _SCON,#82
                        :>  T2CON=0;
co:0b96: e4             :  clr A
co:0b97: f5 c8          :  mov _T2CON,A
                        :>  RCAP2L=0xAE;                     // 9600 Baud @ 25 MHz
co:0b99: 75 ca ae       :  mov _RCAP2L,#174
                        :>  RCAP2H=0xff;
co:0b9c: 75 cb ff       :  mov _RCAP2H,#255
                        :>  T2CON=0x30;
co:0b9f: 75 c8 30       :  mov _T2CON,#48
                        :>  TR2=1;
co:0ba2: d2 ca          :  setb _TR2
                        :>  TR0=1;
co:0ba4: d2 8c          :  setb _TR0
                        :>
                        :> P1=0;
co:0ba6: e4             :  clr A
co:0ba7: f5 90          :  mov _P1,A
                        :>  
                        :>  // A HTTP-Server with only passive sockets requires only an IP address
                        :>
                        :> COMPOSE_IP(my_ip,192,168,0,1); 
co:0ba9: 90 02 e4       :  mov DPTR,#_my_ip
co:0bac: 74 c0          :  mov A,#192
co:0bae: f0             :  movx @DPTR,A
                        : 
co:0baf: 90 02 e5       :  mov DPTR,#_my_ip+1
co:0bb2: 74 a8          :  mov A,#168
co:0bb4: f0             :  movx @DPTR,A
                        : 
co:0bb5: 90 02 e6       :  mov DPTR,#_my_ip+2
co:0bb8: e4             :  clr A
co:0bb9: f0             :  movx @DPTR,A
                        : 
co:0bba: 90 02 e7       :  mov DPTR,#_my_ip+3
co:0bbd: 74 01          :  mov A,#1
co:0bbf: f0             :  movx @DPTR,A
                        : 
co:0bc0: 90 02 e7       :  mov DPTR,#_my_ip+3
co:0bc3: e0             :  movx A,@DPTR
co:0bc4: ff             :  mov R7,A
co:0bc5: 7e 00          :  mov R6,#0
co:0bc7: 8e 29          :  mov _printf_formal_near+6,R6
co:0bc9: 8f 2a          :  mov _printf_formal_near+7,R7
co:0bcb: 90 02 e6       :  mov DPTR,#_my_ip+2
co:0bce: e0             :  movx A,@DPTR
co:0bcf: ff             :  mov R7,A
co:0bd0: 7e 00          :  mov R6,#0
co:0bd2: 8e 27          :  mov _printf_formal_near+4,R6
co:0bd4: 8f 28          :  mov _printf_formal_near+5,R7
co:0bd6: 90 02 e5       :  mov DPTR,#_my_ip+1
co:0bd9: e0             :  movx A,@DPTR
co:0bda: ff             :  mov R7,A
co:0bdb: 7e 00          :  mov R6,#0
co:0bdd: 8e 25          :  mov _printf_formal_near+2,R6
co:0bdf: 8f 26          :  mov _printf_formal_near+3,R7
co:0be1: 90 02 e4       :  mov DPTR,#_my_ip
co:0be4: e0             :  movx A,@DPTR
co:0be5: ff             :  mov R7,A
co:0be6: 7e 00          :  mov R6,#0
co:0be8: 8e 23          :  mov _printf_formal_near,R6
co:0bea: 8f 24          :  mov _printf_formal_near+1,R7
co:0bec: 7e 17          :  mov R6,#((?i9)>>8)&255
co:0bee: 7f 0d          :  mov R7,#(?i9)&255
co:0bf0: 7c 01          :  mov R4,#COS
co:0bf2: 12 24 d7       :  lcall _printf
                        :>// COMPOSE_IP(my_ip,10,0,0,101);
                        :> printf("IP:  %u.%u.%u.%u\r\n",my_ip.bytes[0],my_ip.bytes[1],my_ip.bytes[2],my_ip.bytes[3]);
                        :>
                        :> if(Init_net()) {
co:0bf5: 12 0a c7       :  lcall _Init_net
co:0bf8: ef             :  mov A,R7
co:0bf9: 60 0e          :  jz ?10
                        : 
co:0bfb: 7e 16          :  mov R6,#((?i12)>>8)&255
co:0bfd: 7f ff          :  mov R7,#(?i12)&255
co:0bff: 7c 01          :  mov R4,#COS
co:0c01: 12 18 b1       :  lcall _puts
                        :>  puts("<NET FAILURE>"); // Init Variables, Counter, ...
                        :>  sevseg_data0=1;
co:0c04: 75 c1 01       :  mov _sevseg_data0,#1
                        :>  for(;;);
                        : ?13:
                        : 
co:0c07: 80 fe          :  sjmp ?13
                        : ?10:
                        :> }
                        :> // Enable ALL (or less) Sockets  as General Server HTTP at port 80
                        :> for(i=0;i<MAX_SOCK;i++) SOCKET_SETUP(i,SOCKET_TCP,80,FLAG_PASSIVE_OPEN);
co:0c09: e4             :  clr A
co:0c0a: fb             :  mov R3,A
                        :  ; variable 'i' assigned to register 'R3'
                        : ?17:
                        : 
co:0c0b: af 03          :  mov R7,AR3
co:0c0d: e4             :  clr A
co:0c0e: fe             :  mov R6,A
co:0c0f: fc             :  mov R4,A
co:0c10: 7d 32          :  mov R5,#50
co:0c12: 12 22 2a       :  lcall __mul_i2
co:0c15: 74 74          :  mov A,#(_uc_socket)&255
co:0c17: 2f             :  add A,R7
co:0c18: f5 82          :  mov DPL,A
co:0c1a: 74 02          :  mov A,#((_uc_socket)>>8)&255
co:0c1c: 3e             :  addc A,R6
co:0c1d: f5 83          :  mov DPH,A
co:0c1f: 74 02          :  mov A,#2
co:0c21: f0             :  movx @DPTR,A
                        : 
co:0c22: af 03          :  mov R7,AR3
co:0c24: e4             :  clr A
co:0c25: fe             :  mov R6,A
co:0c26: fc             :  mov R4,A
co:0c27: 7d 32          :  mov R5,#50
co:0c29: 12 22 2a       :  lcall __mul_i2
co:0c2c: 7c 02          :  mov R4,#((_uc_socket+14)>>8)&255
co:0c2e: 7d 82          :  mov R5,#(_uc_socket+14)&255
co:0c30: ed             :  mov A,R5
co:0c31: 2f             :  add A,R7
co:0c32: fd             :  mov R5,A
co:0c33: ec             :  mov A,R4
co:0c34: 3e             :  addc A,R6
co:0c35: fc             :  mov R4,A
co:0c36: 7e 00          :  mov R6,#0
co:0c38: 7f 50          :  mov R7,#80
co:0c3a: 8c 83          :  mov DPH,R4
co:0c3c: 8d 82          :  mov DPL,R5
co:0c3e: 12 0a c1       :  lcall __st_dptr_r67
                        : 
co:0c41: 0b             :  inc R3
                        : 
co:0c42: bb 02 c6       :  cjne R3,#2,?17
                        : 
                        : ?21:
                        :> // * Now Net is ready to start *
                        :> for(;;){
co:0c45: 12 0d 18       :  lcall _poll_webserver
co:0c48: ac 06          :  mov R4,AR6
co:0c4a: ad 07          :  mov R5,AR7
                        :  ; variable 'res' assigned to register 'RW45'
                        :>
                        :>  // ENOUGH TIME IN THIS LOOP FOR OTHER JOBS...
                        :>
                        :>  
                        :>  res=poll_webserver();
                        :>  if((res&0xFF00) ==EVENT_HTTP_REQUEST){
co:0c4c: 7f 00          :  mov R7,#0
co:0c4e: ec             :  mov A,R4
co:0c4f: fe             :  mov R6,A
co:0c50: bf 00 f2       :  cjne R7,#0,?21
co:0c53: be 90 ef       :  cjne R6,#144,?21
                        : 
co:0c56: af 05          :  mov R7,AR5
                        :  ; variable 'socket' allocated as 'auto'
co:0c58: 8f 20          :  mov ?main_socket,R7
                        :>   socket=(uchar)res;
                        :>
                        :>   pc=webpage_name(); // get name of requested page
co:0c5a: 12 17 96       :  lcall _webpage_name
                        :  ; variable 'pc' allocated as 'auto'
co:0c5d: 8e 21          :  mov ?main_pc,R6
co:0c5f: 8f 22          :  mov ?main_pc+1,R7
                        :>
                        :>//   printf("'%s'/%u\n",pc,socket); // Show requested page and socket
                        :>
                        :>   if(*pc=='f'){
co:0c61: 85 21 83       :  mov DPH,?main_pc
co:0c64: 85 22 82       :  mov DPL,?main_pc+1
co:0c67: e0             :  movx A,@DPTR
co:0c68: ff             :  mov R7,A
co:0c69: bf 66 0b       :  cjne R7,#102,?27
                        : 
co:0c6c: 7c 18          :  mov R4,#((_form)>>8)&255
co:0c6e: 7d f3          :  mov R5,#(_form)&255
co:0c70: af 20          :  mov R7,?main_socket
co:0c72: 12 17 20       :  lcall _webpage_bind
                        :>    webpage_bind(socket,form);
                        :>   }else if(*pc=='r'){
co:0c75: 80 1f          :  sjmp ?28
                        : ?27:
                        : 
co:0c77: 85 21 83       :  mov DPH,?main_pc
co:0c7a: 85 22 82       :  mov DPL,?main_pc+1
co:0c7d: e0             :  movx A,@DPTR
co:0c7e: ff             :  mov R7,A
co:0c7f: bf 72 0b       :  cjne R7,#114,?29
                        : 
co:0c82: 7c 1b          :  mov R4,#((_reply)>>8)&255
co:0c84: 7d fa          :  mov R5,#(_reply)&255
co:0c86: af 20          :  mov R7,?main_socket
co:0c88: 12 17 20       :  lcall _webpage_bind
                        :>    webpage_bind(socket,reply);    
                        :>   }else{
co:0c8b: 80 09          :  sjmp ?30
                        : ?29:
                        : 
co:0c8d: 7c 11          :  mov R4,#((_home)>>8)&255
co:0c8f: 7d c8          :  mov R5,#(_home)&255
co:0c91: af 20          :  mov R7,?main_socket
co:0c93: 12 17 20       :  lcall _webpage_bind
                        :>    webpage_bind(socket,home); // HOME
                        :>   }
                        : ?30:
                        : ?28:
                        :>
                        :>   for(;;){
                        : ?31:
                        : 
co:0c96: 12 04 73       :  lcall _url_getarg_no
                        :  ; variable 'i' allocated as 'auto'
co:0c99: 8f 20          :  mov ?i44,R7
                        :>    i=url_getarg_no();
                        :>    if(!i) break;
co:0c9b: e5 20          :  mov A,?i44
co:0c9d: 70 03          :  jnz ?35
                        : 
co:0c9f: 02 0c 45       :  ljmp ?21
                        : ?35:
                        :>    pc=url_getarg_str();
co:0ca2: 12 0f d8       :  lcall _url_getarg_str
                        :  ; variable 'pc' allocated as 'auto'
                        :>
                        :>    printf("Arg A%u: '%s'\n",i,pc); // Opt. Show Args...
co:0ca5: 8e 21          :  mov ?i45,R6
co:0ca7: 8f 22          :  mov ?i45+1,R7
co:0ca9: 7c 00          :  mov R4,#XDS
co:0cab: 8c 25          :  mov _printf_formal_near+2,R4
co:0cad: 8d 26          :  mov _printf_formal_near+3,R5
co:0caf: 8e 27          :  mov _printf_formal_near+4,R6
co:0cb1: 8f 28          :  mov _printf_formal_near+5,R7
co:0cb3: 85 20 24       :  mov _printf_formal_near+1,?i44
co:0cb6: 75 23 00       :  mov _printf_formal_near,#0
co:0cb9: 7e 16          :  mov R6,#((?i37)>>8)&255
co:0cbb: 7f f0          :  mov R7,#(?i37)&255
co:0cbd: 7c 01          :  mov R4,#COS
co:0cbf: 12 24 d7       :  lcall _printf
                        :>
                        :>    if(i==1) strcpy(name,pc); // Copy without regarding max. len...
co:0cc2: 74 01          :  mov A,#1
co:0cc4: 65 20          :  xrl A,?i44
co:0cc6: 70 15          :  jnz ?38
                        : 
co:0cc8: ae 21          :  mov R6,?i45
co:0cca: af 22          :  mov R7,?i45+1
co:0ccc: ab 07          :  mov R3,AR7
co:0cce: aa 06          :  mov R2,AR6
co:0cd0: 78 00          :  mov R0,#XDS
co:0cd2: 7e 03          :  mov R6,#((_name)>>8)&255
co:0cd4: 7f 07          :  mov R7,#(_name)&255
co:0cd6: 7c 00          :  mov R4,#XDS
co:0cd8: 12 26 bb       :  lcall _strcpy
co:0cdb: 80 b9          :  sjmp ?31
                        : ?38:
                        :>    else if(i==2) strcpy(cont,pc);
co:0cdd: 74 02          :  mov A,#2
co:0cdf: 65 20          :  xrl A,?i44
co:0ce1: 70 16          :  jnz ?40
                        : 
co:0ce3: ae 21          :  mov R6,?i45
co:0ce5: af 22          :  mov R7,?i45+1
co:0ce7: ab 07          :  mov R3,AR7
co:0ce9: aa 06          :  mov R2,AR6
co:0ceb: 78 00          :  mov R0,#XDS
co:0ced: 7e 02          :  mov R6,#((_cont)>>8)&255
co:0cef: 7f f6          :  mov R7,#(_cont)&255
co:0cf1: 7c 00          :  mov R4,#XDS
co:0cf3: 12 26 bb       :  lcall _strcpy
co:0cf6: 02 0c 96       :  ljmp ?31
                        : ?40:
                        :>    else if(i==3) strcpy(adr,pc);
co:0cf9: 74 03          :  mov A,#3
co:0cfb: 65 20          :  xrl A,?i44
co:0cfd: 60 03          :  jz ?_13
co:0cff: 02 0c 96       :  ljmp ?31
                        : ?_13:
                        : 
co:0d02: ae 21          :  mov R6,?i45
co:0d04: af 22          :  mov R7,?i45+1
co:0d06: ab 07          :  mov R3,AR7
co:0d08: aa 06          :  mov R2,AR6
co:0d0a: 78 00          :  mov R0,#XDS
co:0d0c: 7e 03          :  mov R6,#((_adr)>>8)&255
co:0d0e: 7f 02          :  mov R7,#(_adr)&255
co:0d10: 7c 00          :  mov R4,#XDS
co:0d12: 12 26 bb       :  lcall _strcpy
                        :>
                        :>    // ignore other Args...
                        :>   }
co:0d15: 02 0c 96       :  ljmp ?31
                        : ; end of function main
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:3 bytes
                        : 
                        :  .segment bss, sclass xram, notext
                        :  .export _cont ; xdata unsigned char cont[12]
                        : _cont: ; xdata unsigned char cont[12]
xr:02f6: xx xx xx xx xx :  .ds.b 12
xr:02fb: xx xx xx xx xx :
xr:0300: xx xx          :
                        :  .export _adr ; xdata unsigned char adr[5]
                        : _adr: ; xdata unsigned char adr[5]
xr:0302: xx xx xx xx xx :  .ds.b 5
                        :  .export _name ; xdata unsigned char name[21]
                        : _name: ; xdata unsigned char name[21]
xr:0307: xx xx xx xx xx :  .ds.b 21
xr:030c: xx xx xx xx xx :
xr:0311: xx xx xx xx xx :
xr:0316: xx xx xx xx xx :
xr:031b: xx             :
                        :  .import _reply ; code unsigned char reply[]
                        :  .import _form ; code unsigned char form[]
                        :  .import _home ; code unsigned char home[]
                        :  .import _sevseg_data0 ; near unsigned char sevseg_data0
                        :  .import _webpage_bind ; void webpage_bind(unsigned char, code unsigned char *)
                        :  .import _url_getarg_str ; xdata unsigned char *url_getarg_str(void)
                        :  .import _url_getarg_no ; unsigned char url_getarg_no(void)
                        :  .import _webpage_name ; xdata unsigned char *webpage_name(void)
                        :  .import _poll_webserver ; unsigned int poll_webserver(void)
                        :  .import _Init_net ; unsigned char Init_net(void)
                        :  .import _uc_socket ; xdata UC_SOCKET uc_socket[2]
                        :  .import _my_ip ; xdata IP_ADR my_ip
                        :  .import _RCAP2H ; near unsigned char RCAP2H
                        :  .import _RCAP2L ; near unsigned char RCAP2L
                        :  .import _TR2 ; bit unsigned char TR2
                        :  .import _T2CON ; near unsigned char T2CON
                        :  .import _P1 ; near unsigned char P1
                        :  .import _TMOD ; near unsigned char TMOD
                        :  .import _TR0 ; bit unsigned char TR0
                        :  .import _SCON ; near unsigned char SCON
                        :  .import _strcpy ; far char *strcpy(far char *, far char *)
                        :  .import _printf ; int printf(far char *, ...)
                        :  .import _puts ; int puts(far char *)
                        :  .segment lit
                        : ?i37: ; code char [15]
co:16f0: 41 72 67 20 41 :  .dc.b "Arg A%u: '%s'",10,0
co:16f5: 25 75 3a 20 27 :
co:16fa: 25 73 27 0a 00 :
                        : ?i12: ; code char [14]
co:16ff: 3c 4e 45 54 20 :  .dc.b "<NET FAILURE>",0
co:1704: 46 41 49 4c 55 :
co:1709: 52 45 3e 00    :
                        : ?i9: ; code char [19]
co:170d: 49 50 3a 20 20 :  .dc.b "IP:  %u.%u.%u.%u",13,10,0
co:1712: 25 75 2e 25 75 :
co:1717: 2e 25 75 2e 25 :
co:171c: 75 0d 0a 00    :
                        :  .export PRINTF_TYPE_u
                        : PRINTF_TYPE_u=1
                        :  .export PRINTF_TYPE_s
                        : PRINTF_TYPE_s=1
                        :  .end
                        :>
                        :>#ifdef LED
                        :>  }else if(res==EVENT_SOCKET_IDLETIMER){
                        :>              LED^=1; // *** BLINK LED ***
                        :>#endif
                        :>  }
                        :>
                        :>     // else{ *** add a user-task here *** }
                        :>
                        :>  } // for(;;)
                        :>
                        :>}
                        :>
                        :>
                        :>// EOF
=         PRINTF_TYPE_s =     1 (hex),      1 (dez)
=         PRINTF_TYPE_u =     1 (hex),      1 (dez)
=               __reset =     0 (hex),      0 (dez), text
=                 _main =   b90 (hex),   2960 (dez), text
=                 _name =   307 (hex),    775 (dez), xram
=                  _adr =   302 (hex),    770 (dez), xram
=                 _cont =   2f6 (hex),    758 (dez), xram

objectfile:home.obj:
                        : ; ********************************************************
                        : ; * home.s51 (Source: home.html)
                        : ; * generated by WEBCODE 2004 (C) www.wickenhaeuser.de
                        : ; ********************************************************
                        : ; * extern code unsigned char home[];
                        : 
                        :   .segment __home
                        :   .export _home
                        :   .import ____home_size__
                        : _home: 
co:11c8: 01 c4          :   .dc.w ____home_size__-3
co:11ca: 01             :   .dc.b 1
co:11cb: 48 54 54 50 2f :   .dc.b "HTTP/1.0 200 OK",13,10
co:11d0: 31 2e 30 20 32 :
co:11d5: 30 30 20 4f 4b :
co:11da: 0d 0a          :
co:11dc: 43 6f 6e 74 65 :   .dc.b "Content-type: text/html",13,10
co:11e1: 6e 74 2d 74 79 :
co:11e6: 70 65 3a 20 74 :
co:11eb: 65 78 74 2f 68 :
co:11f0: 74 6d 6c 0d 0a :
co:11f5: 43 6f 6e 6e 65 :   .dc.b "Connection: close",13,10,13,10
co:11fa: 63 74 69 6f 6e :
co:11ff: 3a 20 63 6c 6f :
co:1204: 73 65 0d 0a 0d :
co:1209: 0a             :
                        : 
co:120a: 3c 68 74 6d 6c :   .dc.b "<html><head><title>Home</title></head>",13,10
co:120f: 3e 3c 68 65 61 :
co:1214: 64 3e 3c 74 69 :
co:1219: 74 6c 65 3e 48 :
co:121e: 6f 6d 65 3c 2f :
co:1223: 74 69 74 6c 65 :
co:1228: 3e 3c 2f 68 65 :
co:122d: 61 64 3e 0d 0a :
co:1232: 3c 62 6f 64 79 :   .dc.b "<body bgcolor=#505050 text=#FFFF00 vlink=#80FFFF link=#FF80FF al"
co:1237: 20 62 67 63 6f :
co:123c: 6c 6f 72 3d 23 :
co:1241: 35 30 35 30 35 :
co:1246: 30 20 74 65 78 :
co:124b: 74 3d 23 46 46 :
co:1250: 46 46 30 30 20 :
co:1255: 76 6c 69 6e 6b :
co:125a: 3d 23 38 30 46 :
co:125f: 46 46 46 20 6c :
co:1264: 69 6e 6b 3d 23 :
co:1269: 46 46 38 30 46 :
co:126e: 46 20 61 6c    :
co:1272: 69 6e 6b 3d 23 :   .dc.b "ink=#FF80FF>",13,10
co:1277: 46 46 38 30 46 :
co:127c: 46 3e 0d 0a    :
co:1280: 3c 70 3e 3c 62 :   .dc.b "<p><b><h2><i>Elektor FPGA-Webserver - Home </i></h2></b></p>",13
co:1285: 3e 3c 68 32 3e :
co:128a: 3c 69 3e 45 6c :
co:128f: 65 6b 74 6f 72 :
co:1294: 20 46 50 47 41 :
co:1299: 2d 57 65 62 73 :
co:129e: 65 72 76 65 72 :
co:12a3: 20 2d 20 48 6f :
co:12a8: 6d 65 20 3c 2f :
co:12ad: 69 3e 3c 2f 68 :
co:12b2: 32 3e 3c 2f 62 :
co:12b7: 3e 3c 2f 70 3e :
co:12bc: 0d             :
co:12bd: 0a             :   .dc.b 10
co:12be: 3c 74 61 62 6c :   .dc.b "<table border=0>",13,10
co:12c3: 65 20 62 6f 72 :
co:12c8: 64 65 72 3d 30 :
co:12cd: 3e 0d 0a       :
co:12d0: 3c 74 72 3e 3c :   .dc.b "<tr><td><a href=",34,"form.html",34,">Form demo:</a></td><td>Dyn"
co:12d5: 74 64 3e 3c 61 :
co:12da: 20 68 72 65 66 :
co:12df: 3d 22 66 6f 72 :
co:12e4: 6d 2e 68 74 6d :
co:12e9: 6c 22 3e 46 6f :
co:12ee: 72 6d 20 64 65 :
co:12f3: 6d 6f 3a 3c 2f :
co:12f8: 61 3e 3c 2f 74 :
co:12fd: 64 3e 3c 74 64 :
co:1302: 3e 44 79 6e    :
co:1306: 61 6d 69 63 20 :   .dc.b "amic forms</td></tr>",13,10
co:130b: 66 6f 72 6d 73 :
co:1310: 3c 2f 74 64 3e :
co:1315: 3c 2f 74 72 3e :
co:131a: 0d 0a          :
co:131c: 3c 74 72 3e 3c :   .dc.b "<tr><td><a href=",34,"http:\\www.elektor.de",34,">Elektor Homepa"
co:1321: 74 64 3e 3c 61 :
co:1326: 20 68 72 65 66 :
co:132b: 3d 22 68 74 74 :
co:1330: 70 3a 5c 5c 77 :
co:1335: 77 77 2e 65 6c :
co:133a: 65 6b 74 6f 72 :
co:133f: 2e 64 65 22 3e :
co:1344: 45 6c 65 6b 74 :
co:1349: 6f 72 20 48 6f :
co:134e: 6d 65 70 61    :
co:1352: 67 65 3c 2f 61 :   .dc.b "ge</a>:</td><td>Visit us!</td></tr>",13,10
co:1357: 3e 3a 3c 2f 74 :
co:135c: 64 3e 3c 74 64 :
co:1361: 3e 56 69 73 69 :
co:1366: 74 20 75 73 21 :
co:136b: 3c 2f 74 64 3e :
co:1370: 3c 2f 74 72 3e :
co:1375: 0d 0a          :
co:1377: 3c 2f 74 61 62 :   .dc.b "</table>",13,10
co:137c: 6c 65 3e 0d 0a :
co:1381: 3c 2f 62 6f 64 :   .dc.b "</body></html>"
co:1386: 79 3e 3c 2f 68 :
co:138b: 74 6d 6c 3e    :
                        : ; End
=                 _home =  11c8 (hex),   4552 (dez), text

objectfile:reply.obj:
                        : ; ********************************************************
                        : ; * reply.s51 (Source: reply.html)
                        : ; * generated by WEBCODE 2004 (C) www.wickenhaeuser.de
                        : ; ********************************************************
                        : ; * extern code unsigned char reply[];
                        : 
                        :   .segment __reply
                        :   .export _reply
                        :   .import ____reply_size__
                        : _reply: 
co:1bfa: 01 49          :   .dc.w ____reply_size__-3
co:1bfc: 01             :   .dc.b 1
co:1bfd: 48 54 54 50 2f :   .dc.b "HTTP/1.0 200 OK",13,10
co:1c02: 31 2e 30 20 32 :
co:1c07: 30 30 20 4f 4b :
co:1c0c: 0d 0a          :
co:1c0e: 43 6f 6e 74 65 :   .dc.b "Content-type: text/html",13,10
co:1c13: 6e 74 2d 74 79 :
co:1c18: 70 65 3a 20 74 :
co:1c1d: 65 78 74 2f 68 :
co:1c22: 74 6d 6c 0d 0a :
co:1c27: 43 6f 6e 6e 65 :   .dc.b "Connection: close",13,10,13,10
co:1c2c: 63 74 69 6f 6e :
co:1c31: 3a 20 63 6c 6f :
co:1c36: 73 65 0d 0a 0d :
co:1c3b: 0a             :
                        : 
co:1c3c: 3c 68 74 6d 6c :   .dc.b "<html><head><title>Reply</title></head>",13,10
co:1c41: 3e 3c 68 65 61 :
co:1c46: 64 3e 3c 74 69 :
co:1c4b: 74 6c 65 3e 52 :
co:1c50: 65 70 6c 79 3c :
co:1c55: 2f 74 69 74 6c :
co:1c5a: 65 3e 3c 2f 68 :
co:1c5f: 65 61 64 3e 0d :
co:1c64: 0a             :
co:1c65: 3c 62 6f 64 79 :   .dc.b "<body bgcolor=#505050 text=#FFFF00 vlink=#80FFFF link=#FF80FF al"
co:1c6a: 20 62 67 63 6f :
co:1c6f: 6c 6f 72 3d 23 :
co:1c74: 35 30 35 30 35 :
co:1c79: 30 20 74 65 78 :
co:1c7e: 74 3d 23 46 46 :
co:1c83: 46 46 30 30 20 :
co:1c88: 76 6c 69 6e 6b :
co:1c8d: 3d 23 38 30 46 :
co:1c92: 46 46 46 20 6c :
co:1c97: 69 6e 6b 3d 23 :
co:1c9c: 46 46 38 30 46 :
co:1ca1: 46 20 61 6c    :
co:1ca5: 69 6e 6b 3d 23 :   .dc.b "ink=#FF80FF>",13,10
co:1caa: 46 46 38 30 46 :
co:1caf: 46 3e 0d 0a    :
co:1cb3: 3c 70 3e 3c 62 :   .dc.b "<p><b><h2><i>Elektor FPGA-Webserver - Form Demo</i></h2></b></p>"
co:1cb8: 3e 3c 68 32 3e :
co:1cbd: 3c 69 3e 45 6c :
co:1cc2: 65 6b 74 6f 72 :
co:1cc7: 20 46 50 47 41 :
co:1ccc: 2d 57 65 62 73 :
co:1cd1: 65 72 76 65 72 :
co:1cd6: 20 2d 20 46 6f :
co:1cdb: 72 6d 20 44 65 :
co:1ce0: 6d 6f 3c 2f 69 :
co:1ce5: 3e 3c 2f 68 32 :
co:1cea: 3e 3c 2f 62 3e :
co:1cef: 3c 2f 70 3e    :
co:1cf3: 0d 0a          :   .dc.b 13,10
co:1cf5: 48 65 6c 6c 6f :   .dc.b "Hello "
co:1cfa: 20             :
co:1cfb: ff             :   .dc.b 255
                        :   .import _adr ;  (char xdata*)adr
co:1cfc: 03 02          :   .dc.w _adr
co:1cfe: 2e 20          :   .dc.b ". "
co:1d00: ff             :   .dc.b 255
                        :   .import _name ;  (char xdata*)name
co:1d01: 03 07          :   .dc.w _name
co:1d03: 20 66 72 6f 6d :   .dc.b " from "
co:1d08: 20             :
co:1d09: ff             :   .dc.b 255
                        :   .import _cont ;  (char xdata*)cont
co:1d0a: 02 f6          :   .dc.w _cont
co:1d0c: 21 3c 62 72 3e :   .dc.b "!<br><br>",13,10
co:1d11: 3c 62 72 3e 0d :
co:1d16: 0a             :
co:1d17: 3c 61 20 68 72 :   .dc.b "<a href=",34,"home.html",34,">Home...</a>",13,10
co:1d1c: 65 66 3d 22 68 :
co:1d21: 6f 6d 65 2e 68 :
co:1d26: 74 6d 6c 22 3e :
co:1d2b: 48 6f 6d 65 2e :
co:1d30: 2e 2e 3c 2f 61 :
co:1d35: 3e 0d 0a       :
co:1d38: 3c 2f 62 6f 64 :   .dc.b "</body></html>"
co:1d3d: 79 3e 3c 2f 68 :
co:1d42: 74 6d 6c 3e    :
                        : ; End
=                _reply =  1bfa (hex),   7162 (dez), text

objectfile:form.obj:
                        : ; ********************************************************
                        : ; * form.s51 (Source: form.html)
                        : ; * generated by WEBCODE 2004 (C) www.wickenhaeuser.de
                        : ; ********************************************************
                        : ; * extern code unsigned char form[];
                        : 
                        :   .segment __form
                        :   .export _form
                        :   .import ____form_size__
                        : _form: 
co:18f3: 03 04          :   .dc.w ____form_size__-3
co:18f5: 01             :   .dc.b 1
co:18f6: 48 54 54 50 2f :   .dc.b "HTTP/1.0 200 OK",13,10
co:18fb: 31 2e 30 20 32 :
co:1900: 30 30 20 4f 4b :
co:1905: 0d 0a          :
co:1907: 43 6f 6e 74 65 :   .dc.b "Content-type: text/html",13,10
co:190c: 6e 74 2d 74 79 :
co:1911: 70 65 3a 20 74 :
co:1916: 65 78 74 2f 68 :
co:191b: 74 6d 6c 0d 0a :
co:1920: 43 6f 6e 6e 65 :   .dc.b "Connection: close",13,10,13,10
co:1925: 63 74 69 6f 6e :
co:192a: 3a 20 63 6c 6f :
co:192f: 73 65 0d 0a 0d :
co:1934: 0a             :
                        : 
co:1935: 3c 68 74 6d 6c :   .dc.b "<html><head><title>Form</title></head>",13,10
co:193a: 3e 3c 68 65 61 :
co:193f: 64 3e 3c 74 69 :
co:1944: 74 6c 65 3e 46 :
co:1949: 6f 72 6d 3c 2f :
co:194e: 74 69 74 6c 65 :
co:1953: 3e 3c 2f 68 65 :
co:1958: 61 64 3e 0d 0a :
co:195d: 3c 62 6f 64 79 :   .dc.b "<body bgcolor=#505050 text=#FFFF00><p><b><h2><i>Elektor FPGA-Web"
co:1962: 20 62 67 63 6f :
co:1967: 6c 6f 72 3d 23 :
co:196c: 35 30 35 30 35 :
co:1971: 30 20 74 65 78 :
co:1976: 74 3d 23 46 46 :
co:197b: 46 46 30 30 3e :
co:1980: 3c 70 3e 3c 62 :
co:1985: 3e 3c 68 32 3e :
co:198a: 3c 69 3e 45 6c :
co:198f: 65 6b 74 6f 72 :
co:1994: 20 46 50 47 41 :
co:1999: 2d 57 65 62    :
co:199d: 73 65 72 76 65 :   .dc.b "server - Form Demo</i></h2></b></p>",13,10
co:19a2: 72 20 2d 20 46 :
co:19a7: 6f 72 6d 20 44 :
co:19ac: 65 6d 6f 3c 2f :
co:19b1: 69 3e 3c 2f 68 :
co:19b6: 32 3e 3c 2f 62 :
co:19bb: 3e 3c 2f 70 3e :
co:19c0: 0d 0a          :
co:19c2: 3c 66 6f 72 6d :   .dc.b "<form action=",34,"reply.html",34," method=",34,"get",34,">",13,10
co:19c7: 20 61 63 74 69 :
co:19cc: 6f 6e 3d 22 72 :
co:19d1: 65 70 6c 79 2e :
co:19d6: 68 74 6d 6c 22 :
co:19db: 20 6d 65 74 68 :
co:19e0: 6f 64 3d 22 67 :
co:19e5: 65 74 22 3e 0d :
co:19ea: 0a             :
co:19eb: 3c 74 61 62 6c :   .dc.b "<table>",13,10
co:19f0: 65 3e 0d 0a    :
co:19f4: 3c 74 72 3e 3c :   .dc.b "<tr><td>Your Surname:</td><td colspan=4><input type=text name=A1"
co:19f9: 74 64 3e 59 6f :
co:19fe: 75 72 20 53 75 :
co:1a03: 72 6e 61 6d 65 :
co:1a08: 3a 3c 2f 74 64 :
co:1a0d: 3e 3c 74 64 20 :
co:1a12: 63 6f 6c 73 70 :
co:1a17: 61 6e 3d 34 3e :
co:1a1c: 3c 69 6e 70 75 :
co:1a21: 74 20 74 79 70 :
co:1a26: 65 3d 74 65 78 :
co:1a2b: 74 20 6e 61 6d :
co:1a30: 65 3d 41 31    :
co:1a34: 20 6d 61 78 6c :   .dc.b " maxlength=20></td></tr>",13,10
co:1a39: 65 6e 67 74 68 :
co:1a3e: 3d 32 30 3e 3c :
co:1a43: 2f 74 64 3e 3c :
co:1a48: 2f 74 72 3e 0d :
co:1a4d: 0a             :
co:1a4e: 3c 74 72 3e 3c :   .dc.b "<tr><td>Location:</td><td colspan=4><select name=A2>",13,10
co:1a53: 74 64 3e 4c 6f :
co:1a58: 63 61 74 69 6f :
co:1a5d: 6e 3a 3c 2f 74 :
co:1a62: 64 3e 3c 74 64 :
co:1a67: 20 63 6f 6c 73 :
co:1a6c: 70 61 6e 3d 34 :
co:1a71: 3e 3c 73 65 6c :
co:1a76: 65 63 74 20 6e :
co:1a7b: 61 6d 65 3d 41 :
co:1a80: 32 3e 0d 0a    :
co:1a84: 3c 6f 70 74 69 :   .dc.b "<option>Asia",13,10
co:1a89: 6f 6e 3e 41 73 :
co:1a8e: 69 61 0d 0a    :
co:1a92: 3c 6f 70 74 69 :   .dc.b "<option>Australia",13,10
co:1a97: 6f 6e 3e 41 75 :
co:1a9c: 73 74 72 61 6c :
co:1aa1: 69 61 0d 0a    :
co:1aa5: 3c 6f 70 74 69 :   .dc.b "<option>Europe",13,10
co:1aaa: 6f 6e 3e 45 75 :
co:1aaf: 72 6f 70 65 0d :
co:1ab4: 0a             :
co:1ab5: 3c 6f 70 74 69 :   .dc.b "<option>N.-America",13,10
co:1aba: 6f 6e 3e 4e 2e :
co:1abf: 2d 41 6d 65 72 :
co:1ac4: 69 63 61 0d 0a :
co:1ac9: 3c 6f 70 74 69 :   .dc.b "<option>S.-America",13,10
co:1ace: 6f 6e 3e 53 2e :
co:1ad3: 2d 41 6d 65 72 :
co:1ad8: 69 63 61 0d 0a :
co:1add: 3c 2f 73 65 6c :   .dc.b "</select> </td></tr>",13,10
co:1ae2: 65 63 74 3e 20 :
co:1ae7: 3c 2f 74 64 3e :
co:1aec: 3c 2f 74 72 3e :
co:1af1: 0d 0a          :
co:1af3: 3c 74 72 3e 3c :   .dc.b "<tr><td>Addr.:</td>",13,10
co:1af8: 74 64 3e 41 64 :
co:1afd: 64 72 2e 3a 3c :
co:1b02: 2f 74 64 3e 0d :
co:1b07: 0a             :
co:1b08: 3c 74 64 3e 4d :   .dc.b "<td>Mr.</td ><td><input type=radio name=A3 value=Mr checked></td"
co:1b0d: 72 2e 3c 2f 74 :
co:1b12: 64 20 3e 3c 74 :
co:1b17: 64 3e 3c 69 6e :
co:1b1c: 70 75 74 20 74 :
co:1b21: 79 70 65 3d 72 :
co:1b26: 61 64 69 6f 20 :
co:1b2b: 6e 61 6d 65 3d :
co:1b30: 41 33 20 76 61 :
co:1b35: 6c 75 65 3d 4d :
co:1b3a: 72 20 63 68 65 :
co:1b3f: 63 6b 65 64 3e :
co:1b44: 3c 2f 74 64    :
co:1b48: 3e 0d 0a       :   .dc.b ">",13,10
co:1b4b: 3c 74 64 3e 4d :   .dc.b "<td>Mrs.</td><td><input type=radio name=A3 value=Mrs></td></tr>",13
co:1b50: 72 73 2e 3c 2f :
co:1b55: 74 64 3e 3c 74 :
co:1b5a: 64 3e 3c 69 6e :
co:1b5f: 70 75 74 20 74 :
co:1b64: 79 70 65 3d 72 :
co:1b69: 61 64 69 6f 20 :
co:1b6e: 6e 61 6d 65 3d :
co:1b73: 41 33 20 76 61 :
co:1b78: 6c 75 65 3d 4d :
co:1b7d: 72 73 3e 3c 2f :
co:1b82: 74 64 3e 3c 2f :
co:1b87: 74 72 3e 0d    :
co:1b8b: 0a             :   .dc.b 10
co:1b8c: 3c 74 72 3e 3c :   .dc.b "<tr><td>Send:</td>",13,10
co:1b91: 74 64 3e 53 65 :
co:1b96: 6e 64 3a 3c 2f :
co:1b9b: 74 64 3e 0d 0a :
co:1ba0: 3c 74 64 20 63 :   .dc.b "<td colspan=4><input type=submit value=Send name=A9></td>",13,10
co:1ba5: 6f 6c 73 70 61 :
co:1baa: 6e 3d 34 3e 3c :
co:1baf: 69 6e 70 75 74 :
co:1bb4: 20 74 79 70 65 :
co:1bb9: 3d 73 75 62 6d :
co:1bbe: 69 74 20 76 61 :
co:1bc3: 6c 75 65 3d 53 :
co:1bc8: 65 6e 64 20 6e :
co:1bcd: 61 6d 65 3d 41 :
co:1bd2: 39 3e 3c 2f 74 :
co:1bd7: 64 3e 0d 0a    :
co:1bdb: 3c 2f 74 61 62 :   .dc.b "</table></form>",13,10
co:1be0: 6c 65 3e 3c 2f :
co:1be5: 66 6f 72 6d 3e :
co:1bea: 0d 0a          :
co:1bec: 3c 2f 62 6f 64 :   .dc.b "</body></html>"
co:1bf1: 79 3e 3c 2f 68 :
co:1bf6: 74 6d 6c 3e    :
                        : ; End
=                 _form =  18f3 (hex),   6387 (dez), text

objectfile:_doprnt.obj:

objectfile:_startup.obj:

objectfile:peep.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:puts.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:ind_call.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:strlen.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:add_i4.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:strcpy.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:bxor_i4.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:copy_l.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:bmove.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:band_i4.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:mem32.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:mul_i2.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:cmp_i4.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:dimo_2.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:printf.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:sub_i4.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:ser_iod.obj: (in C:\uC51\lib\small\ser_ioD.lib):

