listing:fg1_http.lst, Thu Dec 14 11:33:36 2006
objectfile:tcpip\open_ether.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'tcpip\open_ether.c', time: Thu Dec 14 11:33:34 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :         .include <reg52.def>
                        : ; **** 80C52 (extended) defs ***
                        : 
                        :         .hide
                        :         .show
                        :         sevseg_ctrl  = $C0;
                        :   sevseg_data0 = $C1;
                        :   sevseg_data1 = $C2;
                        :   sevseg_data2 = $C3;
                        :   sevseg_data3 = $C4;
                        :   sevseg_en    = $C5;
                        :   _sevseg_ctrl  = sevseg_ctrl;
                        :   _sevseg_data0 = sevseg_data0;
                        :   _sevseg_data1 = sevseg_data1;
                        :   _sevseg_data2 = sevseg_data2;
                        :   _sevseg_data3 = sevseg_data3;
                        :   _sevseg_en    = sevseg_en;
                        : 
                        :   ps2_ctrl    = $d8;
                        :   ps2_rxf     = ps2_ctrl.0;
                        :   ps2_ovf     = ps2_ctrl.1;
                        :   ps2_rx_busy = ps2_ctrl.2;
                        :   ps2_tx_busy = ps2_ctrl.3;
                        :   ps2_ack     = ps2_ctrl.4;
                        :   ps2_init    = ps2_ctrl.7;
                        :   ps2_data    = $0xd9;
                        :   _ps2_ctrl    = ps2_ctrl;
                        :   _ps2_rxf     = ps2_rxf;
                        :   _ps2_ovf     = ps2_ovf;
                        :   _ps2_rx_busy = ps2_rx_busy;
                        :   _ps2_tx_busy = ps2_tx_busy;
                        :   _ps2_ack     = ps2_ack;
                        :   _ps2_init    = ps2_init;
                        :   _ps2_data    = ps2_data;
                        :   bank_sel   = $f9;
                        :   bank_en    = $f8;
                        :   vgaen      = bank_en.4;
                        :   sramb0     = bank_en.5;
                        :   sramen     = bank_en.6;
                        :   ethdis     = bank_en.7;
                        : 
                        :   _bank_sel   = bank_sel;
                        :   _bank_en    = bank_en;
                        :   _vgaen      = vgaen;
                        :   _sramb0     = sramb0;
                        :   _sramen     = sramen;
                        :   _ethdis     = ethdis;
                        :  .export _set_mac_add ; void set_mac_add(xdata unsigned char *)
                        :  .segment _set_mac_add_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _set_mac_add_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _set_mac_add_formal_near, _set_mac_add_local_near, __set_mac_add
                        : 
                        :  .segment __set_mac_add
                        : _set_mac_add: ; (leaf function) void set_mac_add(xdata unsigned char *)
                        :  ; parameter 'addr' in 'RW67' assigned to 'RW01'
co:4bda: a8 06          :  mov R0,AR6
co:4bdc: a9 07          :  mov R1,AR7
                        :>/*********************************************************************************
                        :>* open_ether.c
                        :>*
                        :>* This is the network driver for a OpenCores Ethernet MAC
                        :>* -> The Physical Layer ('PHY.C') <-
                        :>*
                        :>* V1.02 (C) 2006 Andreas Voggeneder
                        :>*
                        :>*
                        :>**********************************************************************************/
                        :>
                        :>#include <stdio.h>
                        :>
                        :>#include <reg52.h>
                        :>
                        :>#include "net.h"                // MAC
                        :>
                        :>#include "phy.h"                      // Physical Layer
                        :>#include "open_ether.h"         // OpenCores Ethernet MAC Register Definitions 
                        :>#include "../fpga_reg.h"
                        :>
                        :>#ifndef PHY_ETH
                        :> #error Ethernet-Phy must be defined in net.h
                        :>#endif
                        :>
                        :>xdata uchar* near pRxPtr;
                        :>
                        :>void set_mac_add(xdata uchar *addr)
                        :>{ 
co:4bde: 74 01          :  mov A,#1
co:4be0: 29             :  add A,R1
co:4be1: ff             :  mov R7,A
co:4be2: e4             :  clr A
co:4be3: 38             :  addc A,R0
co:4be4: fe             :  mov R6,A
co:4be5: 85 06 83       :  mov DPH,AR6
co:4be8: 85 07 82       :  mov DPL,AR7
co:4beb: e0             :  movx A,@DPTR
co:4bec: ff             :  mov R7,A
co:4bed: ab 07          :  mov R3,AR7
co:4bef: 7a 00          :  mov R2,#0
co:4bf1: 85 00 83       :  mov DPH,AR0
co:4bf4: 85 01 82       :  mov DPL,AR1
co:4bf7: e0             :  movx A,@DPTR
co:4bf8: ff             :  mov R7,A
co:4bf9: ad 07          :  mov R5,AR7
co:4bfb: 7c 00          :  mov R4,#0
co:4bfd: 7f 08          :  mov R7,#8
co:4bff: ae 04          :  mov R6,AR4
co:4c01: ed             :  mov A,R5
co:4c02: 8f f0          :  mov B,R7
co:4c04: 05 f0          :  inc B
co:4c06: 80 05          :  sjmp ?_1
                        : ?_2:
co:4c08: c3             :  clr C
co:4c09: 33             :  rlc A
co:4c0a: ce             :  xch A,R6
co:4c0b: 33             :  rlc A
co:4c0c: ce             :  xch A,R6
                        : ?_1:
co:4c0d: d5 f0 f8       :  djnz B,?_2
co:4c10: ff             :  mov R7,A
co:4c11: 4b             :  orl A,R3
co:4c12: ff             :  mov R7,A
co:4c13: ee             :  mov A,R6
co:4c14: 4a             :  orl A,R2
co:4c15: fe             :  mov R6,A
co:4c16: e4             :  clr A
co:4c17: fd             :  mov R5,A
co:4c18: fc             :  mov R4,A
co:4c19: 90 d0 44       :  mov DPTR,#53316
co:4c1c: 12 34 bc       :  lcall __st_dptr_r47
                        :>  *MAC_ADDR2 =  addr[0] << 8    |       addr[1];
                        :>  *MAC_ADDR1 = *((unsigned long*)       &addr[2]);
co:4c1f: 74 02          :  mov A,#2
co:4c21: 29             :  add A,R1
co:4c22: ff             :  mov R7,A
co:4c23: e4             :  clr A
co:4c24: 38             :  addc A,R0
co:4c25: fe             :  mov R6,A
co:4c26: 7c 00          :  mov R4,#XDS
co:4c28: 12 32 d2       :  lcall __gen_read32_i4
co:4c2b: 90 d0 40       :  mov DPTR,#53312
co:4c2e: 12 34 bc       :  lcall __st_dptr_r47
co:4c31: 22             :  ret
                        : ; end of function set_mac_add
                        : ; used: R01234567 BR-------- DPTR ACC PSW B
                        : 
                        :  .export _Init_Mac ; unsigned char Init_Mac(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __Init_Mac
                        : _Init_Mac: ; unsigned char Init_Mac(void)
                        :>}
                        :>
                        :>uchar Init_Mac(void) {
co:4c32: c2 ff          :  clr _ethdis
                        :>  unsigned char i;
                        :>  volatile xdata oeth_bd* rxtx_bd;
                        :>  
                        :>  ethdis=0;
                        :>  *MODER = OETH_MODER_RST;      /* Reset ON */
co:4c34: 90 d0 00       :  mov DPTR,#53248
co:4c37: e4             :  clr A
co:4c38: f0             :  movx @DPTR,A
co:4c39: a3             :  inc DPTR
co:4c3a: f0             :  movx @DPTR,A
co:4c3b: a3             :  inc DPTR
co:4c3c: 74 08          :  mov A,#8
co:4c3e: f0             :  movx @DPTR,A
co:4c3f: a3             :  inc DPTR
co:4c40: e4             :  clr A
co:4c41: f0             :  movx @DPTR,A
                        :>        *MODER &= ~OETH_MODER_RST;      /* Reset OFF */
co:4c42: 90 d0 00       :  mov DPTR,#53248
co:4c45: 12 34 f2       :  lcall __ld_dptr_r47
co:4c48: 53 06 f7       :  anl AR6,#247
co:4c4b: e4             :  clr A
co:4c4c: fd             :  mov R5,A
co:4c4d: fc             :  mov R4,A
co:4c4e: 90 d0 00       :  mov DPTR,#53248
co:4c51: 12 34 bc       :  lcall __st_dptr_r47
                        :>  *TX_BD_NUM=OETH_TXBD_NUM;
co:4c54: 90 d0 23       :  mov DPTR,#53283
co:4c57: 74 01          :  mov A,#1
co:4c59: f0             :  movx @DPTR,A
                        :>  *PACKETLEN = 0x00400600;
co:4c5a: 90 d0 18       :  mov DPTR,#53272
co:4c5d: e4             :  clr A
co:4c5e: f0             :  movx @DPTR,A
co:4c5f: a3             :  inc DPTR
co:4c60: 74 40          :  mov A,#64
co:4c62: f0             :  movx @DPTR,A
co:4c63: a3             :  inc DPTR
co:4c64: 74 06          :  mov A,#6
co:4c66: f0             :  movx @DPTR,A
co:4c67: a3             :  inc DPTR
co:4c68: e4             :  clr A
co:4c69: f0             :  movx @DPTR,A
                        :>  *IPGT = 0x00000012;
co:4c6a: 90 d0 0f       :  mov DPTR,#53263
co:4c6d: 74 12          :  mov A,#18
co:4c6f: f0             :  movx @DPTR,A
                        :>  *IPGR1 = 0x0000000c;
co:4c70: 90 d0 13       :  mov DPTR,#53267
co:4c73: 74 0c          :  mov A,#12
co:4c75: f0             :  movx @DPTR,A
                        :>  *IPGR2 = 0x00000012;
co:4c76: 90 d0 17       :  mov DPTR,#53271
co:4c79: 74 12          :  mov A,#18
co:4c7b: f0             :  movx @DPTR,A
                        :>  *COLLCONF = 0x000f003f;
co:4c7c: 90 d0 1c       :  mov DPTR,#53276
co:4c7f: e4             :  clr A
co:4c80: f0             :  movx @DPTR,A
co:4c81: a3             :  inc DPTR
co:4c82: 74 0f          :  mov A,#15
co:4c84: f0             :  movx @DPTR,A
co:4c85: a3             :  inc DPTR
co:4c86: e4             :  clr A
co:4c87: f0             :  movx @DPTR,A
co:4c88: a3             :  inc DPTR
co:4c89: 74 3f          :  mov A,#63
co:4c8b: f0             :  movx @DPTR,A
                        :>  *CTRLMODER = 0;
co:4c8c: 90 d0 27       :  mov DPTR,#53287
co:4c8f: e4             :  clr A
co:4c90: f0             :  movx @DPTR,A
                        :  ; variable 'rxtx_bd' assigned to register 'B1_RW89'
                        :>
                        :>/*
                        :>// Activate Fullduplex Mode
                        :>  i=0;
                        :>  *MIIADDRESS = 4<<8;
                        :>  *MII_TX_DATA = 0x1e1;
                        :>  *MIICOMMAND = OETH_MIICOMMAND_WCTRLDATA; 
                        :>  while(*MII_STATUS & OETH_MIISTATUS_BUSY) {
                        :>    i++;
                        :>  }
                        :>
                        :>  
                        :>  i=0;
                        :>  *MIIADDRESS = 0<<8;
                        :>  *MII_TX_DATA = 0x3300;
                        :>  *MIICOMMAND = OETH_MIICOMMAND_WCTRLDATA; 
                        :>  while(*MII_STATUS & OETH_MIISTATUS_BUSY) {
                        :>    i++;
                        :>  }   */ 
                        :>
                        :>  // Set up TX Descriptors
                        :>  // Mapped between A400 and A40f
                        :>  rxtx_bd = OETH_BD_BASE;
co:4c91: 75 08 d4       :  mov AR8,#212
                        :>  for(i = 0; i < OETH_TXBD_NUM; i++) {
co:4c94: e4             :  clr A
co:4c95: f5 09          :  mov AR9,A
co:4c97: f9             :  mov R1,A
                        :  ; variable 'i' assigned to register 'R1'
                        : ?9:
                        : 
co:4c98: ad 01          :  mov R5,AR1
co:4c9a: 7c 00          :  mov R4,#0
co:4c9c: 7f 03          :  mov R7,#3
co:4c9e: ae 04          :  mov R6,AR4
co:4ca0: ed             :  mov A,R5
co:4ca1: 8f f0          :  mov B,R7
co:4ca3: 05 f0          :  inc B
co:4ca5: 80 05          :  sjmp ?_3
                        : ?_4:
co:4ca7: c3             :  clr C
co:4ca8: 33             :  rlc A
co:4ca9: ce             :  xch A,R6
co:4caa: 33             :  rlc A
co:4cab: ce             :  xch A,R6
                        : ?_3:
co:4cac: d5 f0 f8       :  djnz B,?_4
co:4caf: ff             :  mov R7,A
co:4cb0: e5 09          :  mov A,AR9
co:4cb2: 2f             :  add A,R7
co:4cb3: fb             :  mov R3,A
co:4cb4: e5 08          :  mov A,AR8
co:4cb6: 3e             :  addc A,R6
co:4cb7: fa             :  mov R2,A
co:4cb8: e4             :  clr A
co:4cb9: fc             :  mov R4,A
co:4cba: fd             :  mov R5,A
co:4cbb: 7e 58          :  mov R6,#88
co:4cbd: 7f 00          :  mov R7,#0
co:4cbf: 8a 83          :  mov DPH,R2
co:4cc1: 8b 82          :  mov DPL,R3
co:4cc3: 12 34 bc       :  lcall __st_dptr_r47
                        :>    rxtx_bd[i].u.len_status = OETH_TX_BD_PAD | OETH_TX_BD_CRC | OETH_RX_BD_IRQ;
                        :>    rxtx_bd[i].addr = TX_BD_BASE+(MAX_FRAME_SIZE*i);
co:4cc6: ad 01          :  mov R5,AR1
co:4cc8: 7c 00          :  mov R4,#0
co:4cca: 7f 03          :  mov R7,#3
co:4ccc: ae 04          :  mov R6,AR4
co:4cce: ed             :  mov A,R5
co:4ccf: 8f f0          :  mov B,R7
co:4cd1: 05 f0          :  inc B
co:4cd3: 80 05          :  sjmp ?_5
                        : ?_6:
co:4cd5: c3             :  clr C
co:4cd6: 33             :  rlc A
co:4cd7: ce             :  xch A,R6
co:4cd8: 33             :  rlc A
co:4cd9: ce             :  xch A,R6
                        : ?_5:
co:4cda: d5 f0 f8       :  djnz B,?_6
co:4cdd: ff             :  mov R7,A
co:4cde: e5 09          :  mov A,AR9
co:4ce0: 2f             :  add A,R7
co:4ce1: ff             :  mov R7,A
co:4ce2: e5 08          :  mov A,AR8
co:4ce4: 3e             :  addc A,R6
co:4ce5: fe             :  mov R6,A
co:4ce6: 74 04          :  mov A,#4
co:4ce8: 2f             :  add A,R7
co:4ce9: fb             :  mov R3,A
co:4cea: e4             :  clr A
co:4ceb: 3e             :  addc A,R6
co:4cec: fa             :  mov R2,A
co:4ced: ae 04          :  mov R6,AR4
co:4cef: af 05          :  mov R7,AR5
co:4cf1: 7c 06          :  mov R4,#6
co:4cf3: 7d 00          :  mov R5,#0
co:4cf5: 12 34 21       :  lcall __mul_i2
co:4cf8: e4             :  clr A
co:4cf9: 2f             :  add A,R7
co:4cfa: ff             :  mov R7,A
co:4cfb: 74 18          :  mov A,#24
co:4cfd: 3e             :  addc A,R6
co:4cfe: fe             :  mov R6,A
co:4cff: e4             :  clr A
co:4d00: fd             :  mov R5,A
co:4d01: fc             :  mov R4,A
co:4d02: 8a 83          :  mov DPH,R2
co:4d04: 8b 82          :  mov DPL,R3
co:4d06: 12 34 bc       :  lcall __st_dptr_r47
                        :>  }
co:4d09: 09             :  inc R1
                        : 
co:4d0a: b9 01 02       :  cjne R1,#1,?_7
co:4d0d: 80 03          :  sjmp ?_8
                        : ?_7:
co:4d0f: 02 4c 98       :  ljmp ?9
                        : ?_8:
                        :>  rxtx_bd[OETH_TXBD_NUM - 1].u.len_status |= OETH_TX_BD_WRAP;
co:4d12: ae 08          :  mov R6,AR8
co:4d14: af 09          :  mov R7,AR9
co:4d16: 8e 83          :  mov DPH,R6
co:4d18: 8f 82          :  mov DPL,R7
co:4d1a: 12 34 f2       :  lcall __ld_dptr_r47
co:4d1d: 43 06 20       :  orl AR6,#32
co:4d20: aa 08          :  mov R2,AR8
co:4d22: ab 09          :  mov R3,AR9
co:4d24: 8a 83          :  mov DPH,R2
co:4d26: 8b 82          :  mov DPL,R3
co:4d28: 12 34 bc       :  lcall __st_dptr_r47
                        :>
                        :>  // Set up RX Descriptors
                        :>  rxtx_bd = (xdata oeth_bd*)((uint)OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd));   //RX_BD_BASE|OETH_BD
co:4d2b: 7e d4          :  mov R6,#212
co:4d2d: 7f 00          :  mov R7,#0
co:4d2f: 74 08          :  mov A,#8
co:4d31: 2f             :  add A,R7
co:4d32: ff             :  mov R7,A
co:4d33: e4             :  clr A
co:4d34: 3e             :  addc A,R6
co:4d35: fe             :  mov R6,A
                        :  ; variable 'rxtx_bd' assigned to register 'B1_RW89'
co:4d36: 8e 08          :  mov AR8,R6
co:4d38: 8f 09          :  mov AR9,R7
                        :>
                        :>  
                        :>  for(i = 0; i < OETH_RXBD_NUM; i++) {
co:4d3a: e4             :  clr A
co:4d3b: f9             :  mov R1,A
                        :  ; variable 'i' assigned to register 'R1'
                        : ?13:
                        : 
co:4d3c: ad 01          :  mov R5,AR1
co:4d3e: 7c 00          :  mov R4,#0
co:4d40: 7f 03          :  mov R7,#3
co:4d42: ae 04          :  mov R6,AR4
co:4d44: ed             :  mov A,R5
co:4d45: 8f f0          :  mov B,R7
co:4d47: 05 f0          :  inc B
co:4d49: 80 05          :  sjmp ?_9
                        : ?_10:
co:4d4b: c3             :  clr C
co:4d4c: 33             :  rlc A
co:4d4d: ce             :  xch A,R6
co:4d4e: 33             :  rlc A
co:4d4f: ce             :  xch A,R6
                        : ?_9:
co:4d50: d5 f0 f8       :  djnz B,?_10
co:4d53: ff             :  mov R7,A
co:4d54: e5 09          :  mov A,AR9
co:4d56: 2f             :  add A,R7
co:4d57: fb             :  mov R3,A
co:4d58: e5 08          :  mov A,AR8
co:4d5a: 3e             :  addc A,R6
co:4d5b: fa             :  mov R2,A
co:4d5c: 7d 10          :  mov R5,#16
co:4d5e: e4             :  clr A
co:4d5f: fe             :  mov R6,A
co:4d60: ff             :  mov R7,A
co:4d61: 8d f0          :  mov B,R5
co:4d63: 05 f0          :  inc B
co:4d65: 80 05          :  sjmp ?_11
                        : ?_12:
co:4d67: c3             :  clr C
co:4d68: 33             :  rlc A
co:4d69: ce             :  xch A,R6
co:4d6a: 33             :  rlc A
co:4d6b: ce             :  xch A,R6
                        : ?_11:
co:4d6c: d5 f0 f8       :  djnz B,?_12
co:4d6f: ff             :  mov R7,A
co:4d70: ff             :  mov R7,A
co:4d71: 43 06 80       :  orl AR6,#128
co:4d74: 43 06 40       :  orl AR6,#64
co:4d77: e4             :  clr A
co:4d78: fd             :  mov R5,A
co:4d79: fc             :  mov R4,A
co:4d7a: 8a 83          :  mov DPH,R2
co:4d7c: 8b 82          :  mov DPL,R3
co:4d7e: 12 34 bc       :  lcall __st_dptr_r47
                        :>    rxtx_bd[i].u.len_status = (0 << 16) | OETH_RX_BD_EMPTY | OETH_RX_BD_IRQ;
                        :>    rxtx_bd[i].addr = RX_BD_BASE+(MAX_FRAME_SIZE*i);
co:4d81: ad 01          :  mov R5,AR1
co:4d83: 7c 00          :  mov R4,#0
co:4d85: 7f 03          :  mov R7,#3
co:4d87: ae 04          :  mov R6,AR4
co:4d89: ed             :  mov A,R5
co:4d8a: 8f f0          :  mov B,R7
co:4d8c: 05 f0          :  inc B
co:4d8e: 80 05          :  sjmp ?_13
                        : ?_14:
co:4d90: c3             :  clr C
co:4d91: 33             :  rlc A
co:4d92: ce             :  xch A,R6
co:4d93: 33             :  rlc A
co:4d94: ce             :  xch A,R6
                        : ?_13:
co:4d95: d5 f0 f8       :  djnz B,?_14
co:4d98: ff             :  mov R7,A
co:4d99: e5 09          :  mov A,AR9
co:4d9b: 2f             :  add A,R7
co:4d9c: ff             :  mov R7,A
co:4d9d: e5 08          :  mov A,AR8
co:4d9f: 3e             :  addc A,R6
co:4da0: fe             :  mov R6,A
co:4da1: 74 04          :  mov A,#4
co:4da3: 2f             :  add A,R7
co:4da4: fb             :  mov R3,A
co:4da5: e4             :  clr A
co:4da6: 3e             :  addc A,R6
co:4da7: fa             :  mov R2,A
co:4da8: ae 04          :  mov R6,AR4
co:4daa: af 05          :  mov R7,AR5
co:4dac: 7c 06          :  mov R4,#6
co:4dae: 7d 00          :  mov R5,#0
co:4db0: 12 34 21       :  lcall __mul_i2
co:4db3: e4             :  clr A
co:4db4: fd             :  mov R5,A
co:4db5: fc             :  mov R4,A
co:4db6: 8a 83          :  mov DPH,R2
co:4db8: 8b 82          :  mov DPL,R3
co:4dba: 12 34 bc       :  lcall __st_dptr_r47
                        :>  }
co:4dbd: 09             :  inc R1
                        : 
co:4dbe: b9 04 02       :  cjne R1,#4,?_15
co:4dc1: 80 03          :  sjmp ?_16
                        : ?_15:
co:4dc3: 02 4d 3c       :  ljmp ?13
                        : ?_16:
                        :>  rxtx_bd[OETH_RXBD_NUM - 1].u.len_status |= OETH_RX_BD_WRAP;
co:4dc6: 74 18          :  mov A,#24
co:4dc8: 25 09          :  add A,AR9
co:4dca: f5 09          :  mov AR9,A
co:4dcc: e4             :  clr A
co:4dcd: 35 08          :  addc A,AR8
co:4dcf: f5 08          :  mov AR8,A
co:4dd1: ae 08          :  mov R6,AR8
co:4dd3: af 09          :  mov R7,AR9
co:4dd5: 8e 83          :  mov DPH,R6
co:4dd7: 8f 82          :  mov DPL,R7
co:4dd9: 12 34 f2       :  lcall __ld_dptr_r47
co:4ddc: 43 06 20       :  orl AR6,#32
co:4ddf: aa 08          :  mov R2,AR8
co:4de1: ab 09          :  mov R3,AR9
co:4de3: 8a 83          :  mov DPH,R2
co:4de5: 8b 82          :  mov DPL,R3
co:4de7: 12 34 bc       :  lcall __st_dptr_r47
                        :>
                        :>  set_mac_add(my_mac);
co:4dea: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:4dec: 7f 00          :  mov R7,#(_my_mac)&255
co:4dee: 12 4b da       :  lcall _set_mac_add
                        :>
                        :>  *INT_SOURCE = 0xffffffff;
co:4df1: 7c ff          :  mov R4,#255
co:4df3: 7d ff          :  mov R5,#255
co:4df5: 7e ff          :  mov R6,#255
co:4df7: 7f ff          :  mov R7,#255
co:4df9: 90 d0 07       :  mov DPTR,#53255
co:4dfc: ef             :  mov A,R7
co:4dfd: f0             :  movx @DPTR,A
                        :>  *INT_MASK = OETH_INT_MASK_TXB         | 
co:4dfe: 90 d0 0b       :  mov DPTR,#53259
co:4e01: 74 7f          :  mov A,#127
co:4e03: f0             :  movx @DPTR,A
                        :>                                OETH_INT_MASK_TXE       | 
                        :>                                OETH_INT_MASK_RXF       | 
                        :>                                OETH_INT_MASK_RXE       |
                        :>                                OETH_INT_MASK_BUSY      |
                        :>                                OETH_INT_MASK_TXC         |
                        :>                                OETH_INT_MASK_RXC;
                        :>  *MODER |=  OETH_MODER_PAD | OETH_MODER_IFG | OETH_MODER_CRCEN
co:4e04: 90 d0 00       :  mov DPTR,#53248
co:4e07: 12 34 f2       :  lcall __ld_dptr_r47
co:4e0a: 43 07 43       :  orl AR7,#67
co:4e0d: 43 06 a0       :  orl AR6,#160
co:4e10: 90 d0 00       :  mov DPTR,#53248
co:4e13: 12 34 bc       :  lcall __st_dptr_r47
                        :>         | OETH_MODER_RXEN | OETH_MODER_TXEN ;
                        :>  return 0;
co:4e16: e4             :  clr A
co:4e17: ff             :  mov R7,A
co:4e18: 22             :  ret
                        : ; end of function Init_Mac
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _init_rx ; void init_rx(void)
                        :  .segment _init_rx_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _init_rx_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _init_rx_formal_near, _init_rx_local_near, __init_rx
                        : 
                        :  .segment __init_rx
                        : _init_rx: ; (leaf function) void init_rx(void)
                        :>}
                        :>
                        :>extern xdata oeth_bd* near rx_bd;
                        :>
                        :>void init_rx(void) {
co:4e19: ae 22          :  mov R6,_rx_bd
co:4e1b: af 23          :  mov R7,_rx_bd+1
co:4e1d: 74 06          :  mov A,#6
co:4e1f: 2f             :  add A,R7
co:4e20: ff             :  mov R7,A
co:4e21: e4             :  clr A
co:4e22: 3e             :  addc A,R6
co:4e23: fe             :  mov R6,A
co:4e24: 8e 83          :  mov DPH,R6
co:4e26: 8f 82          :  mov DPL,R7
co:4e28: 12 35 4c       :  lcall __ld_dptr_r67
                        :  ; variable 'ptmp' assigned to register 'RW67'
                        :>//    pRxPtr=(xdata uchar*)((*((xdata uint*)(rx_bd->addr)+1))|((uint)ETH_BUFFER_BASE));
                        :>// stupid compiler :-(
                        :>    xdata uint* ptmp= (xdata uint*)*((xdata uint*)(&rx_bd->addr)+1);
                        :>    pRxPtr=(xdata uchar*)((uint)ptmp|ETH_BUFFER_BASE);
co:4e2b: 43 06 e0       :  orl AR6,#224
co:4e2e: 8e 24          :  mov _pRxPtr,R6
co:4e30: 8f 25          :  mov _pRxPtr+1,R7
co:4e32: 22             :  ret
                        : ; end of function init_rx
                        : ; used: R------67 BR-------- DPTR ACC PSW
                        : 
                        :  .export _find_RX_Buffer ; xdata oeth_bd *find_RX_Buffer(void)
                        :  .segment _find_RX_Buffer_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _find_RX_Buffer_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _find_RX_Buffer_formal_near, _find_RX_Buffer_local_near, __find_RX_Buffer
                        : 
                        :  .segment __find_RX_Buffer
                        : _find_RX_Buffer: ; (leaf function) xdata oeth_bd *find_RX_Buffer(void)
                        :>}
                        :>
                        :>xdata oeth_bd* find_RX_Buffer() {
co:4b48: 7e d4          :  mov R6,#212
co:4b4a: 7f 00          :  mov R7,#0
co:4b4c: 74 08          :  mov A,#8
co:4b4e: 2f             :  add A,R7
co:4b4f: fd             :  mov R5,A
co:4b50: e4             :  clr A
co:4b51: 3e             :  addc A,R6
co:4b52: fc             :  mov R4,A
                        :  ; variable 'rx_bd' assigned to register 'RW45'
                        :>  volatile xdata oeth_bd *rx_bd=(xdata oeth_bd*)((uint)OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd));
                        :>  uchar i;
                        :>  for(i=0;i < OETH_RXBD_NUM; i++,rx_bd++) {
co:4b53: e4             :  clr A
co:4b54: fb             :  mov R3,A
                        :  ; variable 'i' assigned to register 'R3'
                        : ?21:
                        : 
co:4b55: 74 02          :  mov A,#2
co:4b57: 2d             :  add A,R5
co:4b58: ff             :  mov R7,A
co:4b59: e4             :  clr A
co:4b5a: 3c             :  addc A,R4
co:4b5b: fe             :  mov R6,A
co:4b5c: 8e 83          :  mov DPH,R6
co:4b5e: 8f 82          :  mov DPL,R7
co:4b60: 12 35 4c       :  lcall __ld_dptr_r67
co:4b63: 7f 00          :  mov R7,#0
co:4b65: 53 06 80       :  anl AR6,#128
co:4b68: ee             :  mov A,R6
co:4b69: 4f             :  orl A,R7
                        :>    if (!(rx_bd->u.ls.status & OETH_RX_BD_EMPTY)){
co:4b6a: 60 0f          :  jz ?23
                        :>      break;
                        :>    }
                        :>    
                        :>  }
co:4b6c: 0b             :  inc R3
co:4b6d: 74 08          :  mov A,#8
co:4b6f: 2d             :  add A,R5
co:4b70: fd             :  mov R5,A
co:4b71: e4             :  clr A
co:4b72: 3c             :  addc A,R4
co:4b73: fc             :  mov R4,A
                        : 
co:4b74: 7f 04          :  mov R7,#4
co:4b76: c3             :  clr C
co:4b77: eb             :  mov A,R3
co:4b78: 9f             :  subb A,R7
co:4b79: 40 da          :  jc ?21
                        : ?23:
                        :>  if(i== OETH_RXBD_NUM) return 0;
co:4b7b: bb 04 05       :  cjne R3,#4,?27
                        : 
co:4b7e: e4             :  clr A
co:4b7f: fe             :  mov R6,A
co:4b80: ff             :  mov R7,A
co:4b81: 80 04          :  sjmp ?20
                        : ?27:
                        :>  return rx_bd;
co:4b83: ae 04          :  mov R6,AR4
co:4b85: af 05          :  mov R7,AR5
                        : ?20:
co:4b87: 22             :  ret
                        : ; end of function find_RX_Buffer
                        : ; used: R---34567 BR-------- DPTR ACC PSW
                        : 
                        :  .segment neardata, sclass dram
                        :  .export _pTxPtr ; xdata unsigned char *near pTxPtr
                        : _pTxPtr: ; xdata unsigned char *near pTxPtr
dr:0020: 00 00          :  .dc.w 0
                        :  .export _RequestSend_Phy ; void RequestSend_Phy(unsigned int)
                        :  .segment _RequestSend_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _RequestSend_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _RequestSend_Phy_formal_near, _RequestSend_Phy_local_near, __RequestSend_Phy
                        : 
                        :  .segment __RequestSend_Phy
                        : _RequestSend_Phy: ; (leaf function) void RequestSend_Phy(unsigned int)
                        :  ; parameter 'FrameSize' in 'RW67'
                        :>
                        :>}
                        :>
                        :>
                        :>/*********************************************************************************
                        :>* void RequestSend(uint FrameSize);
                        :>*
                        :>* Note: Frame-Size in BYTES
                        :>* Requests space in on-chip memory for storing an outgoing frame
                        :>* This function must only be called ONCE.
                        :>**********************************************************************************/
                        :>//#define TX_BD         (volatile struct _oeth_bd xdata*)(OETH_BD_BASE)
                        :>
                        :>xdata uchar* near pTxPtr=0;
                        :>
                        :>void RequestSend_Phy(uint FrameSize){
co:4a7d: 90 d4 00       :  mov DPTR,#54272
co:4a80: 12 35 40       :  lcall __st_dptr_r67
                        :>
                        :>  volatile xdata oeth_bd* tx_bd= OETH_BD_BASE;
                        :>  tx_bd->u.ls.len    = FrameSize;
                        :>  tx_bd->u.ls.status = OETH_TX_BD_PAD | OETH_TX_BD_CRC | OETH_RX_BD_IRQ | OETH_TX_BD_WRAP;
co:4a83: 7c d4          :  mov R4,#212
co:4a85: 7d 00          :  mov R5,#0
co:4a87: 74 02          :  mov A,#2
co:4a89: 2d             :  add A,R5
co:4a8a: fb             :  mov R3,A
co:4a8b: e4             :  clr A
co:4a8c: 3c             :  addc A,R4
co:4a8d: fa             :  mov R2,A
co:4a8e: 7c 78          :  mov R4,#120
co:4a90: 7d 00          :  mov R5,#0
co:4a92: 8a 83          :  mov DPH,R2
co:4a94: 8b 82          :  mov DPL,R3
co:4a96: 12 34 e0       :  lcall __st_dptr_r45
                        :>  tx_bd->addr = TX_BD_BASE;
co:4a99: 7c d4          :  mov R4,#212
co:4a9b: 7d 00          :  mov R5,#0
co:4a9d: 74 04          :  mov A,#4
co:4a9f: 2d             :  add A,R5
co:4aa0: fd             :  mov R5,A
co:4aa1: e4             :  clr A
co:4aa2: 3c             :  addc A,R4
co:4aa3: fc             :  mov R4,A
co:4aa4: e4             :  clr A
co:4aa5: f8             :  mov R0,A
co:4aa6: f9             :  mov R1,A
co:4aa7: 7a 18          :  mov R2,#24
co:4aa9: 7b 00          :  mov R3,#0
co:4aab: 8c 83          :  mov DPH,R4
co:4aad: 8d 82          :  mov DPL,R5
co:4aaf: 12 34 c8       :  lcall __st_dptr_r03
                        :>  pTxPtr=(volatile xdata unsigned long*)(TX_BD_BASE|(ETH_BUFFER_BASE));
co:4ab2: 75 20 f8       :  mov _pTxPtr,#248
co:4ab5: 75 21 00       :  mov _pTxPtr+1,#0
co:4ab8: 22             :  ret
                        : ; end of function RequestSend_Phy
                        : ; used: R01234567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _CommitSend_Phy ; void CommitSend_Phy(void)
                        :  .segment _CommitSend_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _CommitSend_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _CommitSend_Phy_formal_near, _CommitSend_Phy_local_near, __CommitSend_Phy
                        : 
                        :  .segment __CommitSend_Phy
                        : _CommitSend_Phy: ; (leaf function) void CommitSend_Phy(void)
                        :>  
                        :>}
                        :>
                        :>void CommitSend_Phy() {
co:4e33: 7e d4          :  mov R6,#212
co:4e35: 7f 00          :  mov R7,#0
co:4e37: 74 02          :  mov A,#2
co:4e39: 2f             :  add A,R7
co:4e3a: ff             :  mov R7,A
co:4e3b: e4             :  clr A
co:4e3c: 3e             :  addc A,R6
co:4e3d: fe             :  mov R6,A
co:4e3e: 8e 08          :  mov AR8,R6
co:4e40: 8f 09          :  mov AR9,R7
co:4e42: 8e 83          :  mov DPH,R6
co:4e44: 8f 82          :  mov DPL,R7
co:4e46: 12 35 4c       :  lcall __ld_dptr_r67
co:4e49: ef             :  mov A,R7
co:4e4a: fd             :  mov R5,A
co:4e4b: ee             :  mov A,R6
co:4e4c: 44 c8          :  orl A,#200
co:4e4e: fc             :  mov R4,A
co:4e4f: ae 08          :  mov R6,AR8
co:4e51: af 09          :  mov R7,AR9
co:4e53: 8e 83          :  mov DPH,R6
co:4e55: 8f 82          :  mov DPL,R7
co:4e57: 12 34 e0       :  lcall __st_dptr_r45
co:4e5a: 22             :  ret
                        : ; end of function CommitSend_Phy
                        : ; used: R----4567 BR01------ DPTR ACC PSW
                        : 
                        :  .export _Read_Frame_word_Phy ; unsigned int Read_Frame_word_Phy(void)
                        :  .segment _Read_Frame_word_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Read_Frame_word_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Read_Frame_word_Phy_formal_near, _Read_Frame_word_Phy_local_near, __Read_Frame_word_Phy
                        : 
                        :  .segment __Read_Frame_word_Phy
                        : _Read_Frame_word_Phy: ; (leaf function) unsigned int Read_Frame_word_Phy(void)
                        :>  volatile oeth_bd xdata *tx_bd= OETH_BD_BASE;
                        :>  tx_bd->u.ls.status |= (OETH_TX_BD_READY | OETH_TX_BD_IRQ | OETH_TX_BD_CRC);
                        :>}
                        :>
                        :>unsigned int Read_Frame_word_Phy(void) {
co:4750: ae 24          :  mov R6,_pRxPtr
co:4752: af 25          :  mov R7,_pRxPtr+1
co:4754: 8e 83          :  mov DPH,R6
co:4756: 8f 82          :  mov DPL,R7
co:4758: 12 35 4c       :  lcall __ld_dptr_r67
                        :  ; variable 'tmp' assigned to register 'RW67'
                        :>  unsigned int tmp= *((xdata unsigned int*)pRxPtr);
                        :>  pRxPtr+=2;
co:475b: 74 02          :  mov A,#2
co:475d: 25 25          :  add A,_pRxPtr+1
co:475f: f5 25          :  mov _pRxPtr+1,A
co:4761: e4             :  clr A
co:4762: 35 24          :  addc A,_pRxPtr
co:4764: f5 24          :  mov _pRxPtr,A
co:4766: 22             :  ret
                        : ; end of function Read_Frame_word_Phy
                        : ; used: R------67 BR-------- DPTR ACC PSW
                        : 
                        :  .export _Read_Frame_long_Phy ; unsigned long Read_Frame_long_Phy(void)
                        :  .segment _Read_Frame_long_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Read_Frame_long_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Read_Frame_long_Phy_formal_near, _Read_Frame_long_Phy_local_near, __Read_Frame_long_Phy
                        : 
                        :  .segment __Read_Frame_long_Phy
                        : _Read_Frame_long_Phy: ; (leaf function) unsigned long Read_Frame_long_Phy(void)
                        :>  return tmp;
                        :>}
                        :>    
                        :>unsigned long Read_Frame_long_Phy(void) {
co:3eaa: ae 24          :  mov R6,_pRxPtr
co:3eac: af 25          :  mov R7,_pRxPtr+1
co:3eae: 8e 83          :  mov DPH,R6
co:3eb0: 8f 82          :  mov DPL,R7
co:3eb2: 12 34 f2       :  lcall __ld_dptr_r47
                        :  ; variable 'tmp' assigned to register 'RL4567'
                        :>  unsigned long tmp= *((xdata unsigned long*)pRxPtr);
                        :>  pRxPtr+=4;
co:3eb5: 74 04          :  mov A,#4
co:3eb7: 25 25          :  add A,_pRxPtr+1
co:3eb9: f5 25          :  mov _pRxPtr+1,A
co:3ebb: e4             :  clr A
co:3ebc: 35 24          :  addc A,_pRxPtr
co:3ebe: f5 24          :  mov _pRxPtr,A
co:3ec0: 22             :  ret
                        : ; end of function Read_Frame_long_Phy
                        : ; used: R----4567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _Read_Frame_xdata_Phy ; void Read_Frame_xdata_Phy(xdata unsigned char *, unsigned int)
                        :  .segment _Read_Frame_xdata_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Read_Frame_xdata_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Read_Frame_xdata_Phy_formal_near, _Read_Frame_xdata_Phy_local_near, __Read_Frame_xdata_Phy
                        : 
                        :  .segment __Read_Frame_xdata_Phy
                        : _Read_Frame_xdata_Phy: ; (leaf function) void Read_Frame_xdata_Phy(xdata unsigned char *, unsigned int
                        :  ; parameter 'ps' in 'RW67' assigned to 'RW45'
                        :  ; parameter 'len' in 'RW45' assigned to 'RW01'
co:3c3d: a8 04          :  mov R0,AR4
co:3c3f: a9 05          :  mov R1,AR5
co:3c41: ac 06          :  mov R4,AR6
co:3c43: ad 07          :  mov R5,AR7
                        :>  return tmp;
                        :>}   
                        :>
                        :>void Read_Frame_xdata_Phy(xdata uchar*ps, uint len) {
co:3c45: 80 2e          :  sjmp ?35
                        : ?34:
                        :>  while(len--) {
co:3c47: 8c 08          :  mov AR8,R4
co:3c49: 8d 09          :  mov AR9,R5
co:3c4b: aa 08          :  mov R2,AR8
co:3c4d: ab 09          :  mov R3,AR9
co:3c4f: 74 01          :  mov A,#1
co:3c51: 2b             :  add A,R3
co:3c52: fd             :  mov R5,A
co:3c53: e4             :  clr A
co:3c54: 3a             :  addc A,R2
co:3c55: fc             :  mov R4,A
co:3c56: ae 24          :  mov R6,_pRxPtr
co:3c58: af 25          :  mov R7,_pRxPtr+1
co:3c5a: 74 01          :  mov A,#1
co:3c5c: 2f             :  add A,R7
co:3c5d: fb             :  mov R3,A
co:3c5e: e4             :  clr A
co:3c5f: 3e             :  addc A,R6
co:3c60: fa             :  mov R2,A
co:3c61: 8a 24          :  mov _pRxPtr,R2
co:3c63: 8b 25          :  mov _pRxPtr+1,R3
co:3c65: 85 06 83       :  mov DPH,AR6
co:3c68: 85 07 82       :  mov DPL,AR7
co:3c6b: e0             :  movx A,@DPTR
co:3c6c: fb             :  mov R3,A
co:3c6d: 85 08 83       :  mov DPH,AR8
co:3c70: 85 09 82       :  mov DPL,AR9
co:3c73: eb             :  mov A,R3
co:3c74: f0             :  movx @DPTR,A
                        :>    *ps++=*pRxPtr++;
                        :>  } 
                        : ?35:
                        : 
co:3c75: ae 00          :  mov R6,AR0
co:3c77: af 01          :  mov R7,AR1
co:3c79: 74 ff          :  mov A,#255
co:3c7b: 2f             :  add A,R7
co:3c7c: f9             :  mov R1,A
co:3c7d: 74 ff          :  mov A,#255
co:3c7f: 3e             :  addc A,R6
co:3c80: f8             :  mov R0,A
co:3c81: ee             :  mov A,R6
co:3c82: 4f             :  orl A,R7
co:3c83: 70 c2          :  jnz ?34
co:3c85: 22             :  ret
                        : ; end of function Read_Frame_xdata_Phy
                        : ; used: R01234567 BR01------ DPTR ACC PSW
                        : 
                        :  .export _Write_Frame_word_Phy ; void Write_Frame_word_Phy(unsigned int)
                        :  .segment _Write_Frame_word_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Write_Frame_word_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Write_Frame_word_Phy_formal_near, _Write_Frame_word_Phy_local_near, __Write_Frame_word_Phy
                        : 
                        :  .segment __Write_Frame_word_Phy
                        : _Write_Frame_word_Phy: ; (leaf function) void Write_Frame_word_Phy(unsigned int)
                        :  ; parameter 'Data' in 'RW67'
                        :>}
                        :>
                        :>
                        :>void Write_Frame_word_Phy(uint Data) {
co:3e93: ac 20          :  mov R4,_pTxPtr
co:3e95: ad 21          :  mov R5,_pTxPtr+1
co:3e97: 8c 83          :  mov DPH,R4
co:3e99: 8d 82          :  mov DPL,R5
co:3e9b: 12 35 40       :  lcall __st_dptr_r67
                        :>  (*((xdata unsigned int*)pTxPtr)=Data); 
                        :>  pTxPtr+=2;
co:3e9e: 74 02          :  mov A,#2
co:3ea0: 25 21          :  add A,_pTxPtr+1
co:3ea2: f5 21          :  mov _pTxPtr+1,A
co:3ea4: e4             :  clr A
co:3ea5: 35 20          :  addc A,_pTxPtr
co:3ea7: f5 20          :  mov _pTxPtr,A
co:3ea9: 22             :  ret
                        : ; end of function Write_Frame_word_Phy
                        : ; used: R----4567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _Write_Frame_long_Phy ; void Write_Frame_long_Phy(unsigned long)
                        :  .segment _Write_Frame_long_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Write_Frame_long_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Write_Frame_long_Phy_formal_near, _Write_Frame_long_Phy_local_near, __Write_Frame_long_Phy
                        : 
                        :  .segment __Write_Frame_long_Phy
                        : _Write_Frame_long_Phy: ; (leaf function) void Write_Frame_long_Phy(unsigned long)
                        :  ; parameter 'Data' in 'RL4567'
                        :>}
                        :>
                        :>void Write_Frame_long_Phy(unsigned long Data){
co:3e7c: aa 20          :  mov R2,_pTxPtr
co:3e7e: ab 21          :  mov R3,_pTxPtr+1
co:3e80: 8a 83          :  mov DPH,R2
co:3e82: 8b 82          :  mov DPL,R3
co:3e84: 12 34 bc       :  lcall __st_dptr_r47
                        :>  (*((xdata unsigned long*)pTxPtr)=Data);
                        :>  pTxPtr+=4;
co:3e87: 74 04          :  mov A,#4
co:3e89: 25 21          :  add A,_pTxPtr+1
co:3e8b: f5 21          :  mov _pTxPtr+1,A
co:3e8d: e4             :  clr A
co:3e8e: 35 20          :  addc A,_pTxPtr
co:3e90: f5 20          :  mov _pTxPtr,A
co:3e92: 22             :  ret
                        : ; end of function Write_Frame_long_Phy
                        : ; used: R--234567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _Write_Frame_xdata_Phy ; void Write_Frame_xdata_Phy(xdata unsigned char *, unsigned int)
                        :  .segment _Write_Frame_xdata_Phy_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _Write_Frame_xdata_Phy_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _Write_Frame_xdata_Phy_formal_near, _Write_Frame_xdata_Phy_local_near, __Write_Frame_xdata_Ph
                        : 
                        :  .segment __Write_Frame_xdata_Phy
                        : _Write_Frame_xdata_Phy: ; (leaf function) void Write_Frame_xdata_Phy(xdata unsigned char *, unsigned i
                        :  ; parameter 'ps' in 'RW67' assigned to 'RW45'
                        :  ; parameter 'len' in 'RW45' assigned to 'RW01'
co:3ba7: a8 04          :  mov R0,AR4
co:3ba9: a9 05          :  mov R1,AR5
co:3bab: ac 06          :  mov R4,AR6
co:3bad: ad 07          :  mov R5,AR7
                        :>}
                        :>
                        :>void Write_Frame_xdata_Phy(xdata uchar* ps, uint len) {
co:3baf: 80 2c          :  sjmp ?41
                        : ?40:
                        :>  while(len--) {
co:3bb1: 85 20 08       :  mov AR8,_pTxPtr
co:3bb4: 85 21 09       :  mov AR9,_pTxPtr+1
co:3bb7: 74 01          :  mov A,#1
co:3bb9: 25 09          :  add A,AR9
co:3bbb: f5 21          :  mov _pTxPtr+1,A
co:3bbd: e4             :  clr A
co:3bbe: 35 08          :  addc A,AR8
co:3bc0: f5 20          :  mov _pTxPtr,A
co:3bc2: ae 04          :  mov R6,AR4
co:3bc4: af 05          :  mov R7,AR5
co:3bc6: 74 01          :  mov A,#1
co:3bc8: 2f             :  add A,R7
co:3bc9: fd             :  mov R5,A
co:3bca: e4             :  clr A
co:3bcb: 3e             :  addc A,R6
co:3bcc: fc             :  mov R4,A
co:3bcd: 85 06 83       :  mov DPH,AR6
co:3bd0: 85 07 82       :  mov DPL,AR7
co:3bd3: e0             :  movx A,@DPTR
co:3bd4: fb             :  mov R3,A
co:3bd5: 85 08 83       :  mov DPH,AR8
co:3bd8: 85 09 82       :  mov DPL,AR9
co:3bdb: eb             :  mov A,R3
co:3bdc: f0             :  movx @DPTR,A
                        :>    *pTxPtr++=*ps++;
                        :>  } 
                        : ?41:
                        : 
co:3bdd: ae 00          :  mov R6,AR0
co:3bdf: af 01          :  mov R7,AR1
co:3be1: 74 ff          :  mov A,#255
co:3be3: 2f             :  add A,R7
co:3be4: f9             :  mov R1,A
co:3be5: 74 ff          :  mov A,#255
co:3be7: 3e             :  addc A,R6
co:3be8: f8             :  mov R0,A
co:3be9: ee             :  mov A,R6
co:3bea: 4f             :  orl A,R7
co:3beb: 70 c4          :  jnz ?40
co:3bed: 22             :  ret
                        : ; end of function Write_Frame_xdata_Phy
                        : ; used: R01234567 BR01------ DPTR ACC PSW
                        : 
                        :  .import _rx_bd ; xdata oeth_bd *near rx_bd
                        :  .segment nearbss, sclass dram, notext
                        :  .export _pRxPtr ; xdata unsigned char *near pRxPtr
                        : _pRxPtr: ; xdata unsigned char *near pRxPtr
dr:0024: xx xx          :  .ds.b 2
                        :  .import _ethdis ; bit unsigned char ethdis
                        :  .import _my_mac ; xdata unsigned char my_mac[6]
                        :  .end
                        :>}
                        :>
                        :>// END
                        :>
                        :>
=             _Init_Mac =  4c32 (hex),  19506 (dez), text
=      _RequestSend_Phy =  4a7d (hex),  19069 (dez), text
=              _init_rx =  4e19 (hex),  19993 (dez), text
=  _Read_Frame_long_Phy =  3eaa (hex),  16042 (dez), text
=  _Read_Frame_word_Phy =  4750 (hex),  18256 (dez), text
=               _pTxPtr =    20 (hex),     32 (dez), dram
=       _find_RX_Buffer =  4b48 (hex),  19272 (dez), text
=               _pRxPtr =    24 (hex),     36 (dez), dram
=  _Write_Frame_long_Ph =  3e7c (hex),  15996 (dez), text
=  _Write_Frame_word_Ph =  3e93 (hex),  16019 (dez), text
=       _CommitSend_Phy =  4e33 (hex),  20019 (dez), text
=  _Write_Frame_xdata_P =  3ba7 (hex),  15271 (dez), text
=  _Read_Frame_xdata_Ph =  3c3d (hex),  15421 (dez), text
=          _set_mac_add =  4bda (hex),  19418 (dez), text

objectfile:tcpip\net.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'tcpip\net.c', time: Thu Dec 14 11:33:34 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :         .include <reg52.def>
                        : ; **** 80C52 (extended) defs ***
                        : 
                        :         .hide
                        :         .show
                        : .macro _irq_vector
                        :         .show
                        :         .segment @1, org @2
                        :         ljmp @3
                        :         .hide
                        : .endmacro
                        :  .segment data, sclass xram
                        :  .export _my_mac ; xdata unsigned char my_mac[6]
                        : _my_mac: ; xdata unsigned char my_mac[6]
xr:0000: 00 06          :  .dc.b 0,6
xr:0002: 98 01          :  .dc.b 152,1
xr:0004: 00 00          :  .dc.b 0,0
                        :  .export _tx_bufleft ; xdata unsigned char tx_bufleft
                        : _tx_bufleft: ; xdata unsigned char tx_bufleft
xr:0006: 04             :  .dc.b 4
                        :  .export _allocate_tx_buf ; xdata unsigned char *allocate_tx_buf(void)
                        :  .segment _allocate_tx_buf_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _allocate_tx_buf_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _allocate_tx_buf_formal_near, _allocate_tx_buf_local_near, __allocate_tx_buf
                        : 
                        :  .segment __allocate_tx_buf
                        : _allocate_tx_buf: ; (leaf function) xdata unsigned char *allocate_tx_buf(void)
                        :>/*********************************************************************************
                        :>* NET.C
                        :>* 
                        :>* IP/ICMP/ARP/TCP/UDP packet handler 
                        :>*
                        :>* V3.01 (C) 2004-2005 WWW.WICKENHAEUSER.DE
                        :>*
                        :>* Please support us:
                        :>* ==================
                        :>* 
                        :>* We offer the uC/51-ANSI-C-Compiler at a very low price. So we do not have a
                        :>* large budget for advertisements. Every link to our Internet pages
                        :>* (WWW.WICKENHAEUSER.COM, WWW.WICKENHAEUSER.DE, WWW.FLEXGATE.COM, WWW.FLEXGATE.DE)
                        :>* is welcome! 
                        :>*
                        :>**********************************************************************************/
                        :>
                        :>#include <stdio.h>
                        :>#include <string.h> 
                        :>
                        :>#include <reg52.h>
                        :>
                        :>#include <irq52.h>
                        :>
                        :>#include "net.h"  // Basic network handling (public)
                        :>#include "phy.h"  // Physical Network access
                        :>#include "open_ether.h"
                        :>#include "netutil.h"  // Toolbox
                        :>
                        :>/**********************************************************************************
                        :>* Private structs
                        :>**********************************************************************************/
                        :>typedef struct{
                        :> uint vhl_service; // 0x45xx-0x4Fxx
                        :> uint len;  
                        :> uint ident;
                        :> uint frags;
                        :> uchar ttl;
                        :> uchar pcol;
                        :> uint checksum;
                        :> IP_ADR sip;
                        :> IP_ADR dip;
                        :>} IP_HDR;
                        :>
                        :>/**********************************************************************************
                        :>* Private Definitions (not in net.h)
                        :>**********************************************************************************/
                        :>
                        :>/************ TCP Soecket states *************************/
                        :>//#define TCP_CLOSED  0 // 0 for all: Socket closed (and listen)
                        :>
                        :>// ** Initial Server States
                        :>#define TCP_SYNCON  1   // Confirmed an incomming SYN
                        :>//#define TCP_EST  2    // Established, Connection OK
                        :>
                        :>// ** Closing
                        :>#define TCP_FINSENT  3    // A FIN was sent. Wait for Acknowledge+FIN
                        :>#define TCP_FINCON 4    // Confirmed a FIN with FIN+ACK, waiting for last ACK
                        :>
                        :>// ** Client States
                        :>#ifdef USE_TCP_CLIENT
                        :> #define TCP_SYNSENT  5   // Arp was Ok, send SYN now
                        :>#endif
                        :>
                        :>/************ UDP Socket states *************************/
                        :>
                        :>// #define UDP_EST ARPREC
                        :>
                        :>/* TCP-Option-Flags */
                        :>#define TFIN 0x01
                        :>#define TSYN 0x02
                        :>#define TRST 0x04
                        :>#define TPUSH 0x08
                        :>#define TACK 0x10
                        :>#define TURGE 0x20  // Flag ignored
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* OPTION DEFS: see net.h
                        :>**********************************************************************************/
                        :>
                        :>/**********************************************************************************
                        :>* MAC-Level data
                        :>*
                        :>* Set a (default) MAC for THIS node
                        :>**********************************************************************************/
                        :>#ifdef PHY_ETH
                        :>MAC my_mac={0x00,0x06,0x98,0x01,0x00,0x00}; // MAC for this machine: M0:M1:M2:M3:M4:M5
                        :>MAC remote_mac;  // used as temp.
                        :> #if defined(USE_TCP_CLIENT) || defined(USE_UDP_CLIENT)
                        :>  MAC gateway_mac; // optional Gateway for active oen of an "ouside" peer
                        :> #endif
                        :>#endif
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* IP-Header-Level data
                        :>*
                        :>* Set a IP for THIS node
                        :>**********************************************************************************/
                        :>IP_ADR  my_ip;    // IP for this machine (public)
                        :>IP_ADR remote_ip;   // Last read IP
                        :>
                        :>#if defined(USE_TCP_CLIENT) || defined(USE_UDP_CLIENT)
                        :>IP_ADR subnet_ip;   // These two IPs require Setup!
                        :>IP_ADR gateway_ip;
                        :>#endif
                        :>
                        :>IP_HDR hhdr;    // Temporary header for sending IP-data
                        :>
                        :>/**********************************************************************************
                        :>* ICMP/ARP-Level data
                        :>*
                        :>* ICMP is designed for Standard WIN-pings with 0-32 bytes. Enlarge structs if req.
                        :>**********************************************************************************/
                        :>
                        :>
                        :>typedef struct{ // Definition
                        :>  IP_ADR sip;
                        :>  IP_ADR dip;
                        :>  uint pcol; // 6 for TCP, 17 for UDP 
                        :>  uint len;
                        :>} PSEUDO_HDR;
                        :>
                        :>PSEUDO_HDR pseudo_hdr;  // Used for TCP/IP-Checksums
                        :>
                        :>#ifdef USE_MSS
                        :> #if MAX_TX < 576
                        :>  #error Maximum Segment Size (MSS, = MAX_TX) too small, must be >=576!
                        :> #endif
                        :>#endif
                        :>
                        :>
                        :>#ifdef PHY_ETH
                        :>// Same variables for initial examination of incomming frames
                        :>typedef struct{ // Size: 20 Bytes
                        :> MAC sender_mac;
                        :> IP_ADR sender_ip;
                        :> MAC target_mac; 
                        :> IP_ADR target_ip;
                        :>} ARP_INFO; // The informative Part of an ARP message...
                        :>#endif
                        :>
                        :>typedef struct{ // Size: 40 Bytes
                        :> uchar type;
                        :> uchar icmp_code;
                        :> uint checksum;
                        :> uint ident; // Commonly unused
                        :> uint sequ; // dto.
                        :>#ifdef SHORT_PING
                        :> uchar data[12]; // Save to clip PING DATA for preserve RAM, so PING fits in 20 Bytes...
                        :>#else
                        :> uchar data[32]; // large enough for a standard WINDOWS ping...
                        :>#endif
                        :>} PING_INFO;  // A frame for a standard PING
                        :>
                        :>typedef struct{ // Size: 20 Bytes
                        :> uint sport; // Source port
                        :> uint dport; // Destination port
                        :>
                        :> WORD2_LONG seq; // Sequence ('my pointer');
                        :> WORD2_LONG ack; // Acknowledge ('your pointer')
                        :>
                        :> uchar hlen; // TCP header len <<2 (==80 without Options)
                        :> uchar flags; // option Flags TFIN-TURGE
                        :>
                        :> uint window; // window size
                        :> uint checksum; // 
                        :> uint urgent; // urgend pointer (commonly unused)
                        :>#ifdef USE_MSS
                        :> unsigned long mss;     // 4 Bytes 2 4 MAX_RX.16
                        :>#endif
                        :>} TCP_HDR;
                        :>
                        :>#ifdef USE_UDP
                        :>typedef struct{ // Size: 8 Bytes (Struct. Currently not used)
                        :> uint sport; // Source port
                        :> uint dport; // Destination port
                        :>
                        :> uint mlen; // MessageLen
                        :> uint checksum; // 
                        :>} UDP_HDR;
                        :>#endif
                        :>
                        :>#ifdef SHORT_PING
                        :> #ifdef USE_MSS
                        :>        #define HFRAME_SIZE 24 // For short Pings... (extended by 4 Bytes MSS)
                        :> #else
                        :>        #define HFRAME_SIZE 20 // For short Pings...
                        :> #endif
                        :>#else
                        :> #define HFRAME_SIZE 40 // Large enough for the biggest header
                        :>#endif
                        :>
                        :>typedef union{
                        :>#ifdef PHY_ETH
                        :> ARP_INFO  arp_info; // 2.nd Level      // Size: 20 Bytes
                        :>#endif
                        :> PING_INFO ping_info; // 2.nd Level     // Default Size: 40 Bytes (save to clip to 8, if PING_DATA cli
                        :> TCP_HDR  tcp_hdr; // 3.rd Level, remote IP in remote_ip, rest of IP_HDR known. 20 Bytes Standard
                        :>#ifdef USE_UDP
                        :> UDP_HDR  udp_hdr; // 3.rd Level        // Size: 8 Bytes
                        :>#endif
                        :> uchar bytes[HFRAME_SIZE]; // Bytes of "generic" access
                        :>} HFRAME;
                        :>
                        :>// A Frame for temporary usage 2.nd and 3.rd level
                        :>HFRAME hframe;
                        :>
                        :>/**********************************************************************************
                        :>* The timer, counts down with about 2 Hz
                        :>**********************************************************************************/
                        :>uchar near net_timer; // Temporary value, counts down until by an IRQ
                        :>uchar near net_service_cnt; // Additional Timer, counts up. twice /sec.
                        :>
                        :>/**********************************************************************************
                        :>* The 'official' buffers in XRAM
                        :>**********************************************************************************/
                        :>
                        :>// RX-Buffer (1)
                        :>#ifdef PHY_ETH
                        :>        uchar rcv_buf[MAX_RX];   // Physical Buffer for receiving data (Mainly HTTP-Header...)
                        :>#else
                        :>        xdata uchar* rcv_buf;   // [MAX_RX]Pointer to Buffer for receiving data (Mainly HTTP-Header...
                        :>#endif
                        :>
                        :>uint rcv_len;    // Size of received data (int)
                        :>
                        :>// TX-Buffers (x)
                        :>uchar tx_buffers[TX_BUFFERS][MAX_TX+1];
                        :>uchar tx_bufleft=TX_BUFFERS; // Counts left buffers
                        :>
                        :>/**********************************************************************************
                        :>* This uC/51 is designed to support a maximum of >8 simultaneous open sockets
                        :>*
                        :>* ** Only implemented as a fragment until now!
                        :>* ** later there will be a bit-mask holding the 'active' sockets
                        :>* ** ** Later socket types: SOCKET_NONE(==0), UDP(port), TCP(port), HTTP, TELNET, ...
                        :>*
                        :>**********************************************************************************/
                        :>
                        :>UC_SOCKET match_socket;  // Temporary matching socket (Work-pad!)
                        :>
                        :>// *** THE SOCKETS ***
                        :>UC_SOCKET uc_socket[MAX_SOCK];  // My (User's) Sockets!
                        :>
                        :>
                        :>
                        :>#ifdef DEBUG_REC
                        :>/**********************************************************************************
                        :>* Debugging Stuff: Records sent and receiced frames
                        :>**********************************************************************************/
                        :>
                        :>uint rec_no;
                        :>typedef struct{
                        :>    uchar typ;  // 'R': Received, 'T' Transmitted, 't' Retransmitted, ...
                        :>    uint port;
                        :>    unsigned long seq;
                        :>    unsigned long ack;
                        :>    uchar flags;
                        :>    uint len;
                        :>} REC_FRAME;
                        :>
                        :>REC_FRAME rec_frame[MAX_REC_FRAME];
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* record_frame: Record 1 Frame
                        :>**********************************************************************************/
                        :>void record_frame(uchar typ, uint port, unsigned long seq, unsigned long ack, uchar flags, uint len){
                        :>    xdata REC_FRAME *pr;
                        :>    if(rec_no==MAX_REC_FRAME) return;   // FULL!
                        :>    pr=rec_frame+rec_no;
                        :>    pr->typ=typ;
                        :>    pr->port=port;
                        :>    pr->seq=seq;
                        :>    pr->ack=ack;
                        :>    pr->flags=flags;
                        :>    pr->len=len;
                        :>    rec_no++;   
                        :>}
                        :>/**********************************************************************************
                        :>* Show Frame, return 1  if data available
                        :>**********************************************************************************/
                        :>uchar show_frame(uint no){
                        :>    uchar flags;
                        :>    xdata REC_FRAME *pr;
                        :>    if(no>=rec_no) return 0;
                        :>    pr=rec_frame+no;
                        :>    printf("No:%u '%c' P:%u  S:%lu    A:%lu    ",no+1, pr->typ, pr->port,  pr->seq, pr->ack);
                        :>    flags=pr->flags;
                        :>    if(flags & TFIN) printf("FIN ");
                        :>    if(flags & TSYN) printf("SYN ");
                        :>    if(flags & TRST) printf("RST ");
                        :>    if(flags & TACK) printf("ACK ");
                        :>
                        :>    printf("   L:%u\n",pr->len);
                        :>    return 1;   // OK!
                        :>}
                        :>
                        :>
                        :>
                        :>#endif
                        :>
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* xdata uchar* allocate_tx_buf(void);
                        :>*
                        :>* Find a free buffer, if one found, allocate it and return startadress,
                        :>* return 0 if none available!
                        :>**********************************************************************************/
                        :>xdata uchar* allocate_tx_buf(void){
co:3657: 7c 00          :  mov R4,#((_tx_buffers)>>8)&255
co:3659: 7d 3c          :  mov R5,#(_tx_buffers)&255
                        :  ; variable 'pbuf' assigned to register 'RW45'
                        :> uchar ui;
                        :> xdata uchar *pbuf=&tx_buffers[0][0];
                        :>
                        :> if(tx_bufleft) for(ui=0;ui<TX_BUFFERS;ui++,pbuf+=(MAX_TX+1)){
co:365b: 90 00 06       :  mov DPTR,#_tx_bufleft
co:365e: e0             :  movx A,@DPTR
co:365f: ff             :  mov R7,A
co:3660: 60 38          :  jz ?15
                        : 
co:3662: e4             :  clr A
co:3663: fb             :  mov R3,A
                        :  ; variable 'ui' assigned to register 'R3'
                        : ?17:
                        : 
co:3664: 85 04 83       :  mov DPH,AR4
co:3667: 85 05 82       :  mov DPL,AR5
co:366a: e0             :  movx A,@DPTR
co:366b: ff             :  mov R7,A
co:366c: 70 1d          :  jnz ?21
                        :>  if(!(*pbuf)) {
co:366e: 85 04 83       :  mov DPH,AR4
co:3671: 85 05 82       :  mov DPL,AR5
co:3674: 74 01          :  mov A,#1
co:3676: f0             :  movx @DPTR,A
                        :>   *pbuf=1; // Mark Buffer as allocated
                        :>   tx_bufleft--;
co:3677: 90 00 06       :  mov DPTR,#_tx_bufleft
co:367a: e0             :  movx A,@DPTR
co:367b: ff             :  mov R7,A
co:367c: 1f             :  dec R7
co:367d: 90 00 06       :  mov DPTR,#_tx_bufleft
co:3680: ef             :  mov A,R7
co:3681: f0             :  movx @DPTR,A
                        :>   return pbuf+1; // Return Startadress of buffer
co:3682: 74 01          :  mov A,#1
co:3684: 2d             :  add A,R5
co:3685: ff             :  mov R7,A
co:3686: e4             :  clr A
co:3687: 3c             :  addc A,R4
co:3688: fe             :  mov R6,A
co:3689: 80 12          :  sjmp ?14
                        : ?21:
                        :>  }
                        :> }
co:368b: 0b             :  inc R3
co:368c: 74 65          :  mov A,#101
co:368e: 2d             :  add A,R5
co:368f: fd             :  mov R5,A
co:3690: e4             :  clr A
co:3691: 3c             :  addc A,R4
co:3692: fc             :  mov R4,A
                        : 
co:3693: 7f 04          :  mov R7,#4
co:3695: c3             :  clr C
co:3696: eb             :  mov A,R3
co:3697: 9f             :  subb A,R7
co:3698: 40 ca          :  jc ?17
                        : ?15:
                        :> return 0; // Nothing found!
co:369a: e4             :  clr A
co:369b: fe             :  mov R6,A
co:369c: ff             :  mov R7,A
                        : ?14:
co:369d: 22             :  ret
                        : ; end of function allocate_tx_buf
                        : ; used: R---34567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _free_tx_buf ; void free_tx_buf(xdata unsigned char *)
                        :  .segment _free_tx_buf_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _free_tx_buf_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _free_tx_buf_formal_near, _free_tx_buf_local_near, __free_tx_buf
                        : 
                        :  .segment __free_tx_buf
                        : _free_tx_buf: ; (leaf function) void free_tx_buf(xdata unsigned char *)
                        :  ; parameter 'pbuf' in 'RW67'
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* void free_tx_buf(xdata uchar* pbuf)
                        :>*
                        :>* Free TX-Buffer if not more required
                        :>**********************************************************************************/
                        :>
                        :>void free_tx_buf(xdata uchar* pbuf){
co:3634: ef             :  mov A,R7
co:3635: 1f             :  dec R7
co:3636: 70 01          :  jnz ?__1
co:3638: 1e             :  dec R6
                        : ?__1:
                        :  ; variable 'pbuf' assigned to register 'RW67'
                        :> pbuf--;   // Pointer to Pos 0(Flag)
                        :> if(*pbuf){
co:3639: 85 06 83       :  mov DPH,AR6
co:363c: 85 07 82       :  mov DPL,AR7
co:363f: e0             :  movx A,@DPTR
co:3640: fd             :  mov R5,A
co:3641: 60 13          :  jz ?24
                        : 
co:3643: 85 06 83       :  mov DPH,AR6
co:3646: 85 07 82       :  mov DPL,AR7
co:3649: e4             :  clr A
co:364a: f0             :  movx @DPTR,A
                        :>  *pbuf=0; // Buffer now free again... 
                        :>  tx_bufleft++; // One more Buffer free...
co:364b: 90 00 06       :  mov DPTR,#_tx_bufleft
co:364e: e0             :  movx A,@DPTR
co:364f: fd             :  mov R5,A
co:3650: 0d             :  inc R5
co:3651: 90 00 06       :  mov DPTR,#_tx_bufleft
co:3654: ed             :  mov A,R5
co:3655: f0             :  movx @DPTR,A
                        :> }
                        : ?24:
co:3656: 22             :  ret
                        : ; end of function free_tx_buf
                        : ; used: R----4567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _free_match_socket ; void free_match_socket(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __free_match_socket
                        : _free_match_socket: ; void free_match_socket(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* void free_match_socket(void);
                        :>*
                        :>* Function for state transition to TCP_CLOSED for a socket, ensures freeing of the
                        :>* buffers!
                        :>**********************************************************************************/
                        :>void free_match_socket(void){
co:3bee: 90 00 34       :  mov DPTR,#_match_socket+42
co:3bf1: 12 35 4c       :  lcall __ld_dptr_r67
co:3bf4: ee             :  mov A,R6
co:3bf5: 4f             :  orl A,R7
co:3bf6: 60 10          :  jz ?28
                        :> if(match_socket.buf_outsize1){
co:3bf8: 90 00 34       :  mov DPTR,#_match_socket+42
co:3bfb: e4             :  clr A
co:3bfc: f0             :  movx @DPTR,A
co:3bfd: a3             :  inc DPTR
co:3bfe: f0             :  movx @DPTR,A
                        :>  match_socket.buf_outsize1=0;
                        :>  free_tx_buf(match_socket.p_outbuf1);   
co:3bff: 90 00 3a       :  mov DPTR,#_match_socket+48
co:3c02: 12 35 4c       :  lcall __ld_dptr_r67
co:3c05: 12 36 34       :  lcall _free_tx_buf
                        :> }
                        : ?28:
                        :> if(match_socket.buf_outsize2){
co:3c08: 90 00 2c       :  mov DPTR,#_match_socket+34
co:3c0b: 12 35 4c       :  lcall __ld_dptr_r67
co:3c0e: ee             :  mov A,R6
co:3c0f: 4f             :  orl A,R7
co:3c10: 60 10          :  jz ?30
                        : 
co:3c12: 90 00 2c       :  mov DPTR,#_match_socket+34
co:3c15: e4             :  clr A
co:3c16: f0             :  movx @DPTR,A
co:3c17: a3             :  inc DPTR
co:3c18: f0             :  movx @DPTR,A
                        :>  match_socket.buf_outsize2=0;
                        :>  free_tx_buf(match_socket.p_outbuf2);   
co:3c19: 90 00 32       :  mov DPTR,#_match_socket+40
co:3c1c: 12 35 4c       :  lcall __ld_dptr_r67
co:3c1f: 12 36 34       :  lcall _free_tx_buf
                        :> }
                        : ?30:
                        :> if(match_socket.buf_outsize3){
co:3c22: 90 00 24       :  mov DPTR,#_match_socket+26
co:3c25: 12 35 4c       :  lcall __ld_dptr_r67
co:3c28: ee             :  mov A,R6
co:3c29: 4f             :  orl A,R7
co:3c2a: 60 10          :  jz ?32
                        : 
co:3c2c: 90 00 24       :  mov DPTR,#_match_socket+26
co:3c2f: e4             :  clr A
co:3c30: f0             :  movx @DPTR,A
co:3c31: a3             :  inc DPTR
co:3c32: f0             :  movx @DPTR,A
                        :>  match_socket.buf_outsize3=0;
                        :>  free_tx_buf(match_socket.p_outbuf3);   
co:3c33: 90 00 2a       :  mov DPTR,#_match_socket+32
co:3c36: 12 35 4c       :  lcall __ld_dptr_r67
co:3c39: 12 36 34       :  lcall _free_tx_buf
                        :> }
                        : ?32:
co:3c3c: 22             :  ret
                        : ; end of function free_match_socket
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _send_request_ARP ; void send_request_ARP(unsigned long)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_request_ARP
                        : _send_request_ARP: ; void send_request_ARP(unsigned long)
                        :  ; parameter 'ipl' in 'RL4567' moved and assigned to local '?send_request_ARP_ipl'
co:3d05: 74 37          :  mov A,#?send_request_ARP_ipl
co:3d07: 12 32 9c       :  lcall __st_a_r47
                        :>}
                        :>
                        :>#ifdef PHY_ETH
                        :>#if defined(USE_TCP_CLIENT) || defined(USE_UDP_CLIENT)
                        :>/**********************************************************************************
                        :>* void send_request_ARP for a specific Internet
                        :>* 
                        :>* Send an ARP Request for a specific MAC
                        :>**********************************************************************************/
                        :>void send_request_ARP(unsigned long ipl){
co:3d0a: 7e 00          :  mov R6,#0
co:3d0c: 7f 2a          :  mov R7,#42
co:3d0e: 12 4a 7d       :  lcall _RequestSend_Phy
                        :> // puts("<ARP QUERRY>"); // Inform us...
                        :>
                        :> RequestSend_Phy(42);    // Send Reply
                        :>
                        :> Write_Frame_long_Phy(0xFFFFFFFF);  // To Broadcast
co:3d11: 7c ff          :  mov R4,#255
co:3d13: 7d ff          :  mov R5,#255
co:3d15: 7e ff          :  mov R6,#255
co:3d17: 7f ff          :  mov R7,#255
co:3d19: 12 3e 7c       :  lcall _Write_Frame_long_Phy
                        :> Write_Frame_word_Phy(0xFFFF);    // To Broadcast
co:3d1c: 7e ff          :  mov R6,#255
co:3d1e: 7f ff          :  mov R7,#255
co:3d20: 12 3e 93       :  lcall _Write_Frame_word_Phy
                        :>
                        :> Write_Frame_xdata_Phy(my_mac,6);   // From US (MAC)
co:3d23: 7c 00          :  mov R4,#0
co:3d25: 7d 06          :  mov R5,#6
co:3d27: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:3d29: 7f 00          :  mov R7,#(_my_mac)&255
co:3d2b: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :>
                        :> Write_Frame_word_Phy(0x0806);   // ARP!
co:3d2e: 7e 08          :  mov R6,#8
co:3d30: 7f 06          :  mov R7,#6
co:3d32: 12 3e 93       :  lcall _Write_Frame_word_Phy
                        :>
                        :> Write_Frame_long_Phy(0x10800);   // Ethernet
co:3d35: 7c 00          :  mov R4,#0
co:3d37: 7d 01          :  mov R5,#1
co:3d39: 7e 08          :  mov R6,#8
co:3d3b: 7f 00          :  mov R7,#0
co:3d3d: 12 3e 7c       :  lcall _Write_Frame_long_Phy
                        :> Write_Frame_long_Phy(0x6040001);  // Request
co:3d40: 7c 06          :  mov R4,#6
co:3d42: 7d 04          :  mov R5,#4
co:3d44: 7e 00          :  mov R6,#0
co:3d46: 7f 01          :  mov R7,#1
co:3d48: 12 3e 7c       :  lcall _Write_Frame_long_Phy
                        :>
                        :> Write_Frame_xdata_Phy(my_mac,6);   // From US (MAC)
co:3d4b: 7c 00          :  mov R4,#0
co:3d4d: 7d 06          :  mov R5,#6
co:3d4f: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:3d51: 7f 00          :  mov R7,#(_my_mac)&255
co:3d53: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_long_Phy(my_ip.ipl);  // and IP!
co:3d56: 90 07 fa       :  mov DPTR,#_my_ip
co:3d59: 12 34 f2       :  lcall __ld_dptr_r47
co:3d5c: 12 3e 7c       :  lcall _Write_Frame_long_Phy
                        :>
                        :> // Variable filled out by Host
                        :> Write_Frame_long_Phy(0xFFFFFFFF);  // To Broadcast
co:3d5f: 7c ff          :  mov R4,#255
co:3d61: 7d ff          :  mov R5,#255
co:3d63: 7e ff          :  mov R6,#255
co:3d65: 7f ff          :  mov R7,#255
co:3d67: 12 3e 7c       :  lcall _Write_Frame_long_Phy
                        :> Write_Frame_word_Phy(0xFFFF);    // To Broadcast
co:3d6a: 7e ff          :  mov R6,#255
co:3d6c: 7f ff          :  mov R7,#255
co:3d6e: 12 3e 93       :  lcall _Write_Frame_word_Phy
                        :>
                        :> // If Our Mask and Destin. Mask differs in the significant netbits, querry MAC of Gateway
                        :> if((ipl^my_ip.ipl)&subnet_ip.ipl) {
co:3d71: 90 07 fa       :  mov DPTR,#_my_ip
co:3d74: 12 34 e6       :  lcall __ld_dptr_r03
co:3d77: 74 37          :  mov A,#?send_request_ARP_ipl
co:3d79: 12 33 44       :  lcall __ld_a_r47
co:3d7c: 12 35 6d       :  lcall __bxor_i4
co:3d7f: 90 07 f2       :  mov DPTR,#_subnet_ip
co:3d82: 12 34 e6       :  lcall __ld_dptr_r03
co:3d85: 12 32 8f       :  lcall __band_i4
co:3d88: ec             :  mov A,R4
co:3d89: 4d             :  orl A,R5
co:3d8a: 4e             :  orl A,R6
co:3d8b: 4f             :  orl A,R7
co:3d8c: 60 0b          :  jz ?35
                        : 
co:3d8e: 90 07 ee       :  mov DPTR,#_gateway_ip
co:3d91: 12 34 f2       :  lcall __ld_dptr_r47
co:3d94: 12 3e 7c       :  lcall _Write_Frame_long_Phy
                        :>  Write_Frame_long_Phy(gateway_ip.ipl); // and IP! (far connection over gatewy)
                        :> }else{
co:3d97: 80 08          :  sjmp ?36
                        : ?35:
                        : 
co:3d99: 74 37          :  mov A,#?send_request_ARP_ipl
co:3d9b: 12 33 44       :  lcall __ld_a_r47
co:3d9e: 12 3e 7c       :  lcall _Write_Frame_long_Phy
                        :>  Write_Frame_long_Phy(ipl);   // and IP! (local connection)
                        :> }
                        : ?36:
                        :> CommitSend_Phy();      // Start TX
co:3da1: 12 4e 33       :  lcall _CommitSend_Phy
co:3da4: 22             :  ret
                        : ; end of function send_request_ARP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:4 bytes
                        : 
                        :  .export _process_ARP ; unsigned int process_ARP(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __process_ARP
                        : _process_ARP: ; unsigned int process_ARP(void)
                        :>}
                        :>#endif
                        :>
                        :>/**********************************************************************************
                        :>* void process_ARP(void){
                        :>* 
                        :>* 2.nd-Level-Multiplexer
                        :>* process an ARP request or (not implemented until now) an ARP reply
                        :>**********************************************************************************/
                        :>uint process_ARP(void){
co:4580: 7c 00          :  mov R4,#0
co:4582: 7d 01          :  mov R5,#1
co:4584: 7e 08          :  mov R6,#8
co:4586: 7f 00          :  mov R7,#0
co:4588: 12 24 d2       :  lcall _net_match_ulong
co:458b: ef             :  mov A,R7
co:458c: 60 07          :  jz ?38
                        :>#if defined(USE_TCP_CLIENT) || defined(USE_UDP_CLIENT)
                        :>     xdata UC_SOCKET *psock;
                        :>     uchar ui;
                        :>#endif
                        :>
                        :> uint type;
                        :> if(net_match_ulong(0x10800)) return EVENT_ARP_UNKNOWN; // No ARP!
co:458e: 7e a2          :  mov R6,#162
co:4590: 7f 00          :  mov R7,#0
co:4592: 02 47 4f       :  ljmp ?37
                        : ?38:
                        :> if(net_match_uint(0x604)) return EVENT_ARP_UNKNOWN; // No ARP!
co:4595: 7e 06          :  mov R6,#6
co:4597: 7f 04          :  mov R7,#4
co:4599: 12 27 f7       :  lcall _net_match_uint
co:459c: ef             :  mov A,R7
co:459d: 60 07          :  jz ?40
                        : 
co:459f: 7e a2          :  mov R6,#162
co:45a1: 7f 00          :  mov R7,#0
co:45a3: 02 47 4f       :  ljmp ?37
                        : ?40:
                        :> type=Read_Frame_word_Phy();  
co:45a6: 12 47 50       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'type' allocated as 'auto'
co:45a9: 8e 37          :  mov ?process_ARP_type,R6
co:45ab: 8f 38          :  mov ?process_ARP_type+1,R7
                        :>//    sevseg_data1=type&0xff;
                        :>//    sevseg_data0=type>>8;
                        :> Read_Frame_xdata_Phy(hframe.bytes,20); // Read informative part of ARP message
co:45ad: 7c 00          :  mov R4,#0
co:45af: 7d 14          :  mov R5,#20
co:45b1: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:45b3: 7f d0          :  mov R7,#(_hframe)&255
co:45b5: 12 3c 3d       :  lcall _Read_Frame_xdata_Phy
                        :> if(type>2) return EVENT_ARP_NOTYPE; // Unknown Reply
co:45b8: 7c 00          :  mov R4,#0
co:45ba: 7d 02          :  mov R5,#2
co:45bc: ae 37          :  mov R6,?process_ARP_type
co:45be: af 38          :  mov R7,?process_ARP_type+1
co:45c0: d3             :  setb C
co:45c1: ef             :  mov A,R7
co:45c2: 9d             :  subb A,R5
co:45c3: ee             :  mov A,R6
co:45c4: 9c             :  subb A,R4
co:45c5: 40 07          :  jc ?42
                        : 
co:45c7: 7e a3          :  mov R6,#163
co:45c9: 7f 00          :  mov R7,#0
co:45cb: 02 47 4f       :  ljmp ?37
                        : ?42:
                        :>
                        :> if(type==1){ // ARP Request!
co:45ce: ae 37          :  mov R6,?process_ARP_type
co:45d0: af 38          :  mov R7,?process_ARP_type+1
co:45d2: ef             :  mov A,R7
co:45d3: 64 01          :  xrl A,#1
co:45d5: 4e             :  orl A,R6
co:45d6: 60 03          :  jz ?_12
co:45d8: 02 46 57       :  ljmp ?44
                        : ?_12:
                        : 
co:45db: 90 07 fa       :  mov DPTR,#_my_ip
co:45de: 12 34 e6       :  lcall __ld_dptr_r03
co:45e1: 90 01 e0       :  mov DPTR,#_hframe+16
co:45e4: 12 34 f2       :  lcall __ld_dptr_r47
co:45e7: c3             :  clr C
co:45e8: 12 34 08       :  lcall __cmp_i4
co:45eb: 60 07          :  jz ?46
                        :>  if(hframe.arp_info.target_ip.ipl!=my_ip.ipl) return EVENT_ARP_OTHER; // ARP, but not for us...
co:45ed: 7e a4          :  mov R6,#164
co:45ef: 7f 00          :  mov R7,#0
co:45f1: 02 47 4f       :  ljmp ?37
                        : ?46:
                        :> 
                        :>  // puts("<ARP request>"); // Inform us...
                        :>  RequestSend_Phy(42);   // Send Reply
co:45f4: 7e 00          :  mov R6,#0
co:45f6: 7f 2a          :  mov R7,#42
co:45f8: 12 4a 7d       :  lcall _RequestSend_Phy
                        :>
                        :>  Write_Frame_xdata_Phy(remote_mac,6);  // Kick packet back...
co:45fb: 7c 00          :  mov R4,#0
co:45fd: 7d 06          :  mov R5,#6
co:45ff: 7e 02          :  mov R6,#((_remote_mac)>>8)&255
co:4601: 7f 0a          :  mov R7,#(_remote_mac)&255
co:4603: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_xdata_Phy(my_mac,6);  // From US (MAC)
co:4606: 7c 00          :  mov R4,#0
co:4608: 7d 06          :  mov R5,#6
co:460a: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:460c: 7f 00          :  mov R7,#(_my_mac)&255
co:460e: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_word_Phy(0x0806);  // ARP!
co:4611: 7e 08          :  mov R6,#8
co:4613: 7f 06          :  mov R7,#6
co:4615: 12 3e 93       :  lcall _Write_Frame_word_Phy
                        :>
                        :>  Write_Frame_long_Phy(0x10800);
co:4618: 7c 00          :  mov R4,#0
co:461a: 7d 01          :  mov R5,#1
co:461c: 7e 08          :  mov R6,#8
co:461e: 7f 00          :  mov R7,#0
co:4620: 12 3e 7c       :  lcall _Write_Frame_long_Phy
                        :>  Write_Frame_long_Phy(0x6040002); // Response
co:4623: 7c 06          :  mov R4,#6
co:4625: 7d 04          :  mov R5,#4
co:4627: 7e 00          :  mov R6,#0
co:4629: 7f 02          :  mov R7,#2
co:462b: 12 3e 7c       :  lcall _Write_Frame_long_Phy
                        :>
                        :>  Write_Frame_xdata_Phy(my_mac,6);  // From US (MAC)
co:462e: 7c 00          :  mov R4,#0
co:4630: 7d 06          :  mov R5,#6
co:4632: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:4634: 7f 00          :  mov R7,#(_my_mac)&255
co:4636: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_long_Phy(my_ip.ipl); // and IP!
co:4639: 90 07 fa       :  mov DPTR,#_my_ip
co:463c: 12 34 f2       :  lcall __ld_dptr_r47
co:463f: 12 3e 7c       :  lcall _Write_Frame_long_Phy
                        :>  Write_Frame_xdata_Phy(hframe.bytes,10);  // Kick half packet back...
co:4642: 7c 00          :  mov R4,#0
co:4644: 7d 0a          :  mov R5,#10
co:4646: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:4648: 7f d0          :  mov R7,#(_hframe)&255
co:464a: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :>  CommitSend_Phy();     // Start TX
co:464d: 12 4e 33       :  lcall _CommitSend_Phy
                        :>
                        :>  return EVENT_ARP_REQUEST;    // No Event of interest, but an EVENT
co:4650: 7e a0          :  mov R6,#160
co:4652: 7f 00          :  mov R7,#0
co:4654: 02 47 4f       :  ljmp ?37
                        : ?44:
                        :  ; variable 'psock' allocated as 'auto'
                        :>
                        :> }else{ // Arp response! For us?
co:4657: 75 37 07       :  mov ?process_ARP_psock,#((_uc_socket)>>8)&255
co:465a: 75 38 8a       :  mov ?process_ARP_psock+1,#(_uc_socket)&255
                        :  ; variable 'ui' allocated as 'auto'
                        :>#if defined(USE_TCP_CLIENT) || defined(USE_UDP_CLIENT)
                        :> 
                        :> //puts("<ARP response>");   
                        :>  // Will work with all non-0 type sockets!
                        :>      psock=uc_socket;
                        :>      for(ui=0;ui<MAX_SOCK;ui++,psock++){
co:465d: e4             :  clr A
co:465e: f5 39          :  mov ?process_ARP_ui,A
                        : ?48:
                        : 
co:4660: 85 37 83       :  mov DPH,?process_ARP_psock
co:4663: 85 38 82       :  mov DPL,?process_ARP_psock+1
co:4666: e0             :  movx A,@DPTR
co:4667: ff             :  mov R7,A
co:4668: 70 03          :  jnz ?_14
co:466a: 02 47 32       :  ljmp ?52
                        : ?_14:
co:466d: ae 37          :  mov R6,?process_ARP_psock
co:466f: af 38          :  mov R7,?process_ARP_psock+1
co:4671: 0f             :  inc R7
co:4672: ef             :  mov A,R7
co:4673: 70 01          :  jnz ?__2
co:4675: 0e             :  inc R6
                        : ?__2:
co:4676: 85 06 83       :  mov DPH,AR6
co:4679: 85 07 82       :  mov DPL,AR7
co:467c: e0             :  movx A,@DPTR
co:467d: ff             :  mov R7,A
co:467e: bf 06 02       :  cjne R7,#6,?_15
co:4681: 80 03          :  sjmp ?_16
                        : ?_15:
co:4683: 02 47 32       :  ljmp ?52
                        : ?_16:
                        :>          if(psock->socket_type && psock->state==ARPSENT){
co:4686: ae 37          :  mov R6,?process_ARP_psock
co:4688: af 38          :  mov R7,?process_ARP_psock+1
co:468a: 74 08          :  mov A,#8
co:468c: 2f             :  add A,R7
co:468d: ff             :  mov R7,A
co:468e: e4             :  clr A
co:468f: 3e             :  addc A,R6
co:4690: fe             :  mov R6,A
co:4691: 8e 83          :  mov DPH,R6
co:4693: 8f 82          :  mov DPL,R7
co:4695: 12 34 f2       :  lcall __ld_dptr_r47
co:4698: 12 35 52       :  lcall __movel_4_8
co:469b: 90 01 d6       :  mov DPTR,#_hframe+6
co:469e: 12 34 e6       :  lcall __ld_dptr_r03
co:46a1: 12 33 ff       :  lcall __movel_8_4
co:46a4: c3             :  clr C
co:46a5: 12 34 08       :  lcall __cmp_i4
co:46a8: 60 33          :  jz ?56
co:46aa: 90 07 fa       :  mov DPTR,#_my_ip
co:46ad: 12 34 e6       :  lcall __ld_dptr_r03
co:46b0: 12 33 ff       :  lcall __movel_8_4
co:46b3: 12 35 6d       :  lcall __bxor_i4
co:46b6: 90 07 f2       :  mov DPTR,#_subnet_ip
co:46b9: 12 34 e6       :  lcall __ld_dptr_r03
co:46bc: 12 32 8f       :  lcall __band_i4
co:46bf: ec             :  mov A,R4
co:46c0: 4d             :  orl A,R5
co:46c1: 4e             :  orl A,R6
co:46c2: 4f             :  orl A,R7
co:46c3: 70 03          :  jnz ?_18
co:46c5: 02 47 32       :  ljmp ?54
                        : ?_18:
co:46c8: 90 07 ee       :  mov DPTR,#_gateway_ip
co:46cb: 12 34 e6       :  lcall __ld_dptr_r03
co:46ce: 90 01 d6       :  mov DPTR,#_hframe+6
co:46d1: 12 34 f2       :  lcall __ld_dptr_r47
co:46d4: c3             :  clr C
co:46d5: 12 34 08       :  lcall __cmp_i4
co:46d8: 60 03          :  jz ?_19
co:46da: 02 47 32       :  ljmp ?54
                        : ?_19:
                        : ?56:
                        :>    // Only ARP-Sockets are of interest if an offered ip is matched
                        :>    if((psock->sremote_ip==hframe.arp_info.sender_ip.ipl) || // Either direct IP match
                        :>     // Or Response is from Gateway, if subnets differ
                        :>       ((  (psock->sremote_ip ^ my_ip.ipl) & subnet_ip.ipl  )&&(hframe.arp_info.sender_ip.ipl==gateway
co:46dd: 7a 00          :  mov R2,#0
co:46df: 7b 06          :  mov R3,#6
co:46e1: ae 37          :  mov R6,?process_ARP_psock
co:46e3: af 38          :  mov R7,?process_ARP_psock+1
co:46e5: 74 02          :  mov A,#2
co:46e7: 2f             :  add A,R7
co:46e8: fd             :  mov R5,A
co:46e9: e4             :  clr A
co:46ea: 3e             :  addc A,R6
co:46eb: fc             :  mov R4,A
co:46ec: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:46ee: 7f d0          :  mov R7,#(_hframe)&255
co:46f0: 12 23 e5       :  lcall _xram_fast_copy
                        :>
                        :>     // Copy MAC
                        :>     xram_fast_copy(hframe.arp_info.sender_mac,psock->sremote_mac,6);
                        :>     psock->state=ARPREC;       // After ARP was received, UDP connection is established, TCP may star
co:46f3: ae 37          :  mov R6,?process_ARP_psock
co:46f5: af 38          :  mov R7,?process_ARP_psock+1
co:46f7: 0f             :  inc R7
co:46f8: ef             :  mov A,R7
co:46f9: 70 01          :  jnz ?__3
co:46fb: 0e             :  inc R6
                        : ?__3:
co:46fc: 85 06 83       :  mov DPH,AR6
co:46ff: 85 07 82       :  mov DPL,AR7
co:4702: 74 07          :  mov A,#7
co:4704: f0             :  movx @DPTR,A
                        :>     psock->retry_cnt=0;
co:4705: ae 37          :  mov R6,?process_ARP_psock
co:4707: af 38          :  mov R7,?process_ARP_psock+1
co:4709: 74 18          :  mov A,#24
co:470b: 2f             :  add A,R7
co:470c: ff             :  mov R7,A
co:470d: e4             :  clr A
co:470e: 3e             :  addc A,R6
co:470f: fe             :  mov R6,A
co:4710: 85 06 83       :  mov DPH,AR6
co:4713: 85 07 82       :  mov DPL,AR7
co:4716: e4             :  clr A
co:4717: f0             :  movx @DPTR,A
                        :>     psock->timer=1;  // Start NOW!
co:4718: ae 37          :  mov R6,?process_ARP_psock
co:471a: af 38          :  mov R7,?process_ARP_psock+1
co:471c: 74 19          :  mov A,#25
co:471e: 2f             :  add A,R7
co:471f: ff             :  mov R7,A
co:4720: e4             :  clr A
co:4721: 3e             :  addc A,R6
co:4722: fe             :  mov R6,A
co:4723: 85 06 83       :  mov DPH,AR6
co:4726: 85 07 82       :  mov DPL,AR7
co:4729: 74 01          :  mov A,#1
co:472b: f0             :  movx @DPTR,A
                        :>
                        :>     return EVENT_ARP_OURREPLY;
co:472c: 7e a5          :  mov R6,#165
co:472e: 7f 00          :  mov R7,#0
co:4730: 80 1d          :  sjmp ?37
                        : ?54:
                        :>    
                        :>    }
                        :>   }  
                        : ?52:
                        :>  }
co:4732: 05 39          :  inc ?process_ARP_ui
co:4734: 74 32          :  mov A,#50
co:4736: 25 38          :  add A,?process_ARP_psock+1
co:4738: f5 38          :  mov ?process_ARP_psock+1,A
co:473a: e4             :  clr A
co:473b: 35 37          :  addc A,?process_ARP_psock
co:473d: f5 37          :  mov ?process_ARP_psock,A
                        : 
co:473f: 7d 02          :  mov R5,#2
co:4741: af 39          :  mov R7,?process_ARP_ui
co:4743: c3             :  clr C
co:4744: ef             :  mov A,R7
co:4745: 9d             :  subb A,R5
co:4746: 50 03          :  jnc ?_20
co:4748: 02 46 60       :  ljmp ?48
                        : ?_20:
                        :>#endif
                        :>  return EVENT_ARP_OTHERREPLY;
co:474b: 7e a1          :  mov R6,#161
co:474d: 7f 00          :  mov R7,#0
                        : ?37:
co:474f: 22             :  ret
                        : ; end of function process_ARP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:3 bytes
                        : 
                        :  .export _process_ICMP ; unsigned int process_ICMP(unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __process_ICMP
                        : _process_ICMP: ; unsigned int process_ICMP(unsigned int)
                        :  ; parameter 'dlen' in 'RW67' moved and assigned to local '?process_ICMP_dlen'
co:427c: 8e 3c          :  mov ?process_ICMP_dlen,R6
co:427e: 8f 3d          :  mov ?process_ICMP_dlen+1,R7
                        :> }
                        :>}
                        :>#endif // PHY_ETH
                        :>
                        :>/**********************************************************************************
                        :>* void process_ICMP(uint dlen)
                        :>*
                        :>* 2.nd-Level-Multiplexer
                        :>* received an ICMp frame ('PING') 
                        :>**********************************************************************************/
                        :>uint process_ICMP(uint dlen){
co:4280: 7c 00          :  mov R4,#0
co:4282: 7d 14          :  mov R5,#20
co:4284: ae 3c          :  mov R6,?process_ICMP_dlen
co:4286: af 3d          :  mov R7,?process_ICMP_dlen+1
co:4288: d3             :  setb C
co:4289: ef             :  mov A,R7
co:428a: 9d             :  subb A,R5
co:428b: ee             :  mov A,R6
co:428c: 9c             :  subb A,R4
co:428d: 40 06          :  jc ?58
                        :> //  MICROCHIP SAYS IT IS SAVE TO TRUNCATE ICMPs, so truncate...
                        :> if(dlen>sizeof(HFRAME)) dlen=sizeof(HFRAME);  // Truncate too long Pings!
co:428f: 75 3c 00       :  mov ?process_ICMP_dlen,#0
co:4292: 75 3d 14       :  mov ?process_ICMP_dlen+1,#20
                        : ?58:
                        :>
                        :> Read_Frame_xdata_Phy(hframe.bytes,dlen); // Read Sender's Data
co:4295: ac 3c          :  mov R4,?process_ICMP_dlen
co:4297: ad 3d          :  mov R5,?process_ICMP_dlen+1
co:4299: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:429b: 7f d0          :  mov R7,#(_hframe)&255
co:429d: 12 3c 3d       :  lcall _Read_Frame_xdata_Phy
                        :> if(hframe.ping_info.type==0){
co:42a0: 90 01 d0       :  mov DPTR,#_hframe
co:42a3: e0             :  movx A,@DPTR
co:42a4: ff             :  mov R7,A
co:42a5: 70 07          :  jnz ?60
                        : 
co:42a7: 7e b0          :  mov R6,#176
co:42a9: 7f 00          :  mov R7,#0
co:42ab: 02 43 98       :  ljmp ?57
                        : ?60:
                        :>  // *** NOT REQUIRED FOR SERVER MODE! ***
                        :>  // puts("<ECHO REPLY ???>");
                        :>  return EVENT_ICMP_REPLY;
                        :>
                        :> }else if(hframe.ping_info.type==8){
co:42ae: 90 01 d0       :  mov DPTR,#_hframe
co:42b1: e0             :  movx A,@DPTR
co:42b2: ff             :  mov R7,A
co:42b3: bf 08 02       :  cjne R7,#8,?_23
co:42b6: 80 03          :  sjmp ?_24
                        : ?_23:
co:42b8: 02 43 94       :  ljmp ?62
                        : ?_24:
                        : 
co:42bb: 90 01 d0       :  mov DPTR,#_hframe
co:42be: e4             :  clr A
co:42bf: f0             :  movx @DPTR,A
                        :>
                        :>  //puts("<ICMP ECHO REQUEST>"); // For debugging...
                        :>
                        :>  // Reflect block as reply
                        :>  hframe.ping_info.type=0;
                        :>  hframe.ping_info.checksum=0; 
co:42c0: 90 01 d2       :  mov DPTR,#_hframe+2
co:42c3: e4             :  clr A
co:42c4: f0             :  movx @DPTR,A
co:42c5: a3             :  inc DPTR
co:42c6: f0             :  movx @DPTR,A
                        :>  hframe.ping_info.checksum=~ip_check(hframe.bytes,dlen);
co:42c7: ac 3c          :  mov R4,?process_ICMP_dlen
co:42c9: ad 3d          :  mov R5,?process_ICMP_dlen+1
co:42cb: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:42cd: 7f d0          :  mov R7,#(_hframe)&255
co:42cf: 12 27 c1       :  lcall _ip_check
co:42d2: ef             :  mov A,R7
co:42d3: f4             :  cpl A
co:42d4: ff             :  mov R7,A
co:42d5: ee             :  mov A,R6
co:42d6: f4             :  cpl A
co:42d7: fe             :  mov R6,A
co:42d8: 90 01 d2       :  mov DPTR,#_hframe+2
co:42db: 12 35 40       :  lcall __st_dptr_r67
                        :>
                        :>  // Now, send out reply
                        :>  hhdr.vhl_service=0x4500;
co:42de: 90 01 f0       :  mov DPTR,#_hhdr
co:42e1: 74 45          :  mov A,#69
co:42e3: f0             :  movx @DPTR,A
co:42e4: a3             :  inc DPTR
co:42e5: e4             :  clr A
co:42e6: f0             :  movx @DPTR,A
                        :>  hhdr.len=sizeof(IP_HDR)+dlen;
co:42e7: ae 3c          :  mov R6,?process_ICMP_dlen
co:42e9: af 3d          :  mov R7,?process_ICMP_dlen+1
co:42eb: 74 14          :  mov A,#20
co:42ed: 2f             :  add A,R7
co:42ee: ff             :  mov R7,A
co:42ef: e4             :  clr A
co:42f0: 3e             :  addc A,R6
co:42f1: fe             :  mov R6,A
co:42f2: 90 01 f2       :  mov DPTR,#_hhdr+2
co:42f5: 12 35 40       :  lcall __st_dptr_r67
                        :>  hhdr.ident=0;
co:42f8: 90 01 f4       :  mov DPTR,#_hhdr+4
co:42fb: e4             :  clr A
co:42fc: f0             :  movx @DPTR,A
co:42fd: a3             :  inc DPTR
co:42fe: f0             :  movx @DPTR,A
                        :>  hhdr.frags=16384; // No Fragmentation
co:42ff: 90 01 f6       :  mov DPTR,#_hhdr+6
co:4302: 74 40          :  mov A,#64
co:4304: f0             :  movx @DPTR,A
co:4305: a3             :  inc DPTR
co:4306: e4             :  clr A
co:4307: f0             :  movx @DPTR,A
                        :>  hhdr.ttl=100; // Industrial standard
co:4308: 90 01 f8       :  mov DPTR,#_hhdr+8
co:430b: 74 64          :  mov A,#100
co:430d: f0             :  movx @DPTR,A
                        :>  hhdr.pcol=1; // ICMP
co:430e: 90 01 f9       :  mov DPTR,#_hhdr+9
co:4311: 74 01          :  mov A,#1
co:4313: f0             :  movx @DPTR,A
                        :>  hhdr.checksum=0;
co:4314: 90 01 fa       :  mov DPTR,#_hhdr+10
co:4317: e4             :  clr A
co:4318: f0             :  movx @DPTR,A
co:4319: a3             :  inc DPTR
co:431a: f0             :  movx @DPTR,A
                        :>  hhdr.sip.ipl=my_ip.ipl;
co:431b: 90 07 fa       :  mov DPTR,#_my_ip
co:431e: 12 34 f2       :  lcall __ld_dptr_r47
co:4321: 90 01 fc       :  mov DPTR,#_hhdr+12
co:4324: 12 34 bc       :  lcall __st_dptr_r47
                        :>  hhdr.dip.ipl=remote_ip.ipl;
co:4327: 90 07 f6       :  mov DPTR,#_remote_ip
co:432a: 12 34 f2       :  lcall __ld_dptr_r47
co:432d: 90 02 00       :  mov DPTR,#_hhdr+16
co:4330: 12 34 bc       :  lcall __st_dptr_r47
                        :>  hhdr.checksum=~ip_check((xdata uchar*)&hhdr,sizeof(IP_HDR));
co:4333: 7c 00          :  mov R4,#0
co:4335: 7d 14          :  mov R5,#20
co:4337: 7e 01          :  mov R6,#((_hhdr)>>8)&255
co:4339: 7f f0          :  mov R7,#(_hhdr)&255
co:433b: 12 27 c1       :  lcall _ip_check
co:433e: ef             :  mov A,R7
co:433f: f4             :  cpl A
co:4340: ff             :  mov R7,A
co:4341: ee             :  mov A,R6
co:4342: f4             :  cpl A
co:4343: fe             :  mov R6,A
co:4344: 90 01 fa       :  mov DPTR,#_hhdr+10
co:4347: 12 35 40       :  lcall __st_dptr_r67
                        :>
                        :>#ifdef PHY_ETH
                        :>  RequestSend_Phy(dlen+sizeof(IP_HDR)+14); // Send Reply
co:434a: ae 3c          :  mov R6,?process_ICMP_dlen
co:434c: af 3d          :  mov R7,?process_ICMP_dlen+1
co:434e: 74 22          :  mov A,#34
co:4350: 2f             :  add A,R7
co:4351: ff             :  mov R7,A
co:4352: e4             :  clr A
co:4353: 3e             :  addc A,R6
co:4354: fe             :  mov R6,A
co:4355: 12 4a 7d       :  lcall _RequestSend_Phy
                        :>  Write_Frame_xdata_Phy(remote_mac,6);  // Kick back...
co:4358: 7c 00          :  mov R4,#0
co:435a: 7d 06          :  mov R5,#6
co:435c: 7e 02          :  mov R6,#((_remote_mac)>>8)&255
co:435e: 7f 0a          :  mov R7,#(_remote_mac)&255
co:4360: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_xdata_Phy(my_mac,6);  // From US (MAC)
co:4363: 7c 00          :  mov R4,#0
co:4365: 7d 06          :  mov R5,#6
co:4367: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:4369: 7f 00          :  mov R7,#(_my_mac)&255
co:436b: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_word_Phy(0x800);  // type IP
co:436e: 7e 08          :  mov R6,#8
co:4370: 7f 00          :  mov R7,#0
co:4372: 12 3e 93       :  lcall _Write_Frame_word_Phy
                        :>#else
                        :>  RequestSend_Phy(dlen+sizeof(IP_HDR)); // Send Reply (PPP)
                        :>#endif
                        :>
                        :>  Write_Frame_xdata_Phy((xdata uchar*)&hhdr,sizeof(IP_HDR));  // Send Header
co:4375: 7c 00          :  mov R4,#0
co:4377: 7d 14          :  mov R5,#20
co:4379: 7e 01          :  mov R6,#((_hhdr)>>8)&255
co:437b: 7f f0          :  mov R7,#(_hhdr)&255
co:437d: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :>  Write_Frame_xdata_Phy(hframe.bytes,dlen);  // and echo
co:4380: ac 3c          :  mov R4,?process_ICMP_dlen
co:4382: ad 3d          :  mov R5,?process_ICMP_dlen+1
co:4384: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:4386: 7f d0          :  mov R7,#(_hframe)&255
co:4388: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :>  // puts("<PING>\a"); // show it!
                        :>  CommitSend_Phy();     // Start TX
co:438b: 12 4e 33       :  lcall _CommitSend_Phy
                        :>
                        :>  return EVENT_ICMP_REQUEST; // Someone has PINGED us!
co:438e: 7e b1          :  mov R6,#177
co:4390: 7f 00          :  mov R7,#0
co:4392: 80 04          :  sjmp ?57
                        : ?62:
                        :>
                        :> }else return EVENT_ICMP_UNKNOWN; // Ignore the Rest...
co:4394: 7e b2          :  mov R6,#178
co:4396: 7f 00          :  mov R7,#0
                        : ?57:
co:4398: 22             :  ret
                        : ; end of function process_ICMP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .export _process_UDP ; unsigned int process_UDP(unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __process_UDP
                        : _process_UDP: ; unsigned int process_UDP(unsigned int)
                        :  ; parameter 'dlen' in 'RW67' moved and assigned to local '?process_UDP_dlen'
co:4845: 8e 37          :  mov ?process_UDP_dlen,R6
co:4847: 8f 38          :  mov ?process_UDP_dlen+1,R7
                        :>}
                        :>
                        :>
                        :>#ifdef USE_UDP
                        :>/**********************************************************************************
                        :>* void process_UDP(void)
                        :>* 
                        :>* 3.rd-Level-Multiplexer
                        :>* Process the Header (and contents) of a UDP datagram.
                        :>*
                        :>* An UPD frame may arrive as broadcast, so treat is as non important first...
                        :>*
                        :>* Note: It is intended hframe my by used for synthesisinhg a response header...
                        :>* 
                        :>**********************************************************************************/
                        :>uint process_UDP(uint dlen){
co:4849: 12 47 50       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'udp_sport' allocated as 'auto'
co:484c: 8e 39          :  mov ?process_UDP_udp_sport,R6
co:484e: 8f 3a          :  mov ?process_UDP_udp_sport+1,R7
                        :> xdata UC_SOCKET *psock;
                        :> uint ui;
                        :>
                        :> uint udp_sport, udp_dport;
                        :> udp_sport=Read_Frame_word_Phy();
                        :> udp_dport=Read_Frame_word_Phy();
co:4850: 12 47 50       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'udp_dport' allocated as 'auto'
co:4853: 8e 3b          :  mov ?process_UDP_udp_dport,R6
co:4855: 8f 3c          :  mov ?process_UDP_udp_dport+1,R7
                        :> if(net_match_uint(dlen)) {
co:4857: ae 37          :  mov R6,?process_UDP_dlen
co:4859: af 38          :  mov R7,?process_UDP_dlen+1
co:485b: 12 27 f7       :  lcall _net_match_uint
co:485e: ef             :  mov A,R7
co:485f: 60 07          :  jz ?65
                        : 
co:4861: 7e e1          :  mov R6,#225
co:4863: 7f 00          :  mov R7,#0
co:4865: 02 49 51       :  ljmp ?64
                        : ?65:
                        :>  return EVENT_UDP_ERROR; // a simple check for plausibility...
                        :> }
                        :> Read_Frame_word_Phy(); // Ignore CS...
co:4868: 12 47 50       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'psock' allocated as 'auto'
                        :>
                        :>
                        :>     psock=uc_socket;
co:486b: 75 3d 07       :  mov ?process_UDP_psock,#((_uc_socket)>>8)&255
co:486e: 75 3e 8a       :  mov ?process_UDP_psock+1,#(_uc_socket)&255
                        :  ; variable 'ui' allocated as 'auto'
                        :>     for(ui=0;ui<MAX_SOCK;ui++,psock++){
co:4871: e4             :  clr A
co:4872: f5 3f          :  mov ?process_UDP_ui,A
co:4874: f5 40          :  mov ?process_UDP_ui+1,A
                        : ?67:
                        : 
co:4876: 85 3d 83       :  mov DPH,?process_UDP_psock
co:4879: 85 3e 82       :  mov DPL,?process_UDP_psock+1
co:487c: e0             :  movx A,@DPTR
co:487d: ff             :  mov R7,A
co:487e: bf 01 02       :  cjne R7,#1,?_26
co:4881: 80 03          :  sjmp ?_27
                        : ?_26:
co:4883: 02 49 28       :  ljmp ?71
                        : ?_27:
                        :>         if(psock->socket_type==SOCKET_UDP){  // Only UDP-Sockets are of interest
co:4886: ae 3d          :  mov R6,?process_UDP_psock
co:4888: af 3e          :  mov R7,?process_UDP_psock+1
co:488a: 74 0e          :  mov A,#14
co:488c: 2f             :  add A,R7
co:488d: ff             :  mov R7,A
co:488e: e4             :  clr A
co:488f: 3e             :  addc A,R6
co:4890: fe             :  mov R6,A
co:4891: 8e 83          :  mov DPH,R6
co:4893: 8f 82          :  mov DPL,R7
co:4895: 12 35 46       :  lcall __ld_dptr_r45
co:4898: ae 3b          :  mov R6,?process_UDP_udp_dport
co:489a: af 3c          :  mov R7,?process_UDP_udp_dport+1
co:489c: ed             :  mov A,R5
co:489d: 6f             :  xrl A,R7
co:489e: 70 04          :  jnz ?_28
co:48a0: ec             :  mov A,R4
co:48a1: 6e             :  xrl A,R6
co:48a2: 60 03          :  jz ?_29
                        : ?_28:
co:48a4: 02 49 28       :  ljmp ?73
                        : ?_29:
                        :>              // Test local port match
                        :>                 if(psock->local_port==udp_dport){
co:48a7: ae 3d          :  mov R6,?process_UDP_psock
co:48a9: af 3e          :  mov R7,?process_UDP_psock+1
co:48ab: 74 0c          :  mov A,#12
co:48ad: 2f             :  add A,R7
co:48ae: fd             :  mov R5,A
co:48af: e4             :  clr A
co:48b0: 3e             :  addc A,R6
co:48b1: fc             :  mov R4,A
co:48b2: ae 39          :  mov R6,?process_UDP_udp_sport
co:48b4: af 3a          :  mov R7,?process_UDP_udp_sport+1
co:48b6: 8c 83          :  mov DPH,R4
co:48b8: 8d 82          :  mov DPL,R5
co:48ba: 12 35 40       :  lcall __st_dptr_r67
                        :>                        // Still missing: This should only be done for PASSIVE UDP-Ports...
                        :>                        psock->sremote_port=udp_sport;  // Copy Sender's Sourceport
                        :>                        psock->sremote_ip=remote_ip.ipl; // Copy Sender's IP
co:48bd: ae 3d          :  mov R6,?process_UDP_psock
co:48bf: af 3e          :  mov R7,?process_UDP_psock+1
co:48c1: 74 08          :  mov A,#8
co:48c3: 2f             :  add A,R7
co:48c4: fb             :  mov R3,A
co:48c5: e4             :  clr A
co:48c6: 3e             :  addc A,R6
co:48c7: fa             :  mov R2,A
co:48c8: 90 07 f6       :  mov DPTR,#_remote_ip
co:48cb: 12 34 f2       :  lcall __ld_dptr_r47
co:48ce: 8a 83          :  mov DPH,R2
co:48d0: 8b 82          :  mov DPL,R3
co:48d2: 12 34 bc       :  lcall __st_dptr_r47
                        :>#ifdef PHY_ETH
                        :>                        xram_fast_copy(&remote_mac[0],psock->sremote_mac,6); // Copy Sender's MAC to s
co:48d5: 7a 00          :  mov R2,#0
co:48d7: 7b 06          :  mov R3,#6
co:48d9: ae 3d          :  mov R6,?process_UDP_psock
co:48db: af 3e          :  mov R7,?process_UDP_psock+1
co:48dd: 74 02          :  mov A,#2
co:48df: 2f             :  add A,R7
co:48e0: fd             :  mov R5,A
co:48e1: e4             :  clr A
co:48e2: 3e             :  addc A,R6
co:48e3: fc             :  mov R4,A
co:48e4: 7e 02          :  mov R6,#((_remote_mac)>>8)&255
co:48e6: 7f 0a          :  mov R7,#(_remote_mac)&255
co:48e8: 12 23 e5       :  lcall _xram_fast_copy
                        :  ; variable 'dlen' allocated as 'auto'
                        :>#endif
                        :>                        dlen-=8; // Subtract header length
co:48eb: 74 f8          :  mov A,#248
co:48ed: 25 38          :  add A,?process_UDP_dlen+1
co:48ef: f5 42          :  mov ?i77+1,A
co:48f1: 74 ff          :  mov A,#255
co:48f3: 35 37          :  addc A,?process_UDP_dlen
co:48f5: f5 41          :  mov ?i77,A
                        :>                        if(dlen>MAX_RX) break;   // Ignore too long frames...
co:48f7: 7c 05          :  mov R4,#5
co:48f9: 7d 78          :  mov R5,#120
co:48fb: ae 41          :  mov R6,?i77
co:48fd: af 42          :  mov R7,?i77+1
co:48ff: d3             :  setb C
co:4900: ef             :  mov A,R7
co:4901: 9d             :  subb A,R5
co:4902: ee             :  mov A,R6
co:4903: 9c             :  subb A,R4
                        : 
co:4904: 50 47          :  jnc ?69
                        :>#ifdef PHY_ETH
                        :>                        Read_Frame_xdata_Phy(rcv_buf,dlen);  // Read Sender's Data, if any
co:4906: ac 41          :  mov R4,?i77
co:4908: ad 42          :  mov R5,?i77+1
co:490a: 7e 02          :  mov R6,#((_rcv_buf)>>8)&255
co:490c: 7f 12          :  mov R7,#(_rcv_buf)&255
co:490e: 12 3c 3d       :  lcall _Read_Frame_xdata_Phy
                        :>#else
                        :>                        rcv_buf=Get_Frame_xdata_pointer();  // Why copy, if it is already there...
                        :>#endif
                        :>
                        :>                        rcv_len=dlen;    // remember size of read data...
co:4911: ae 41          :  mov R6,?i77
co:4913: af 42          :  mov R7,?i77+1
co:4915: 90 02 10       :  mov DPTR,#_rcv_len
co:4918: 12 35 40       :  lcall __st_dptr_r67
                        :>                        return EVENT_UDP_DATARECEIVED+ui;
co:491b: ae 3f          :  mov R6,?process_UDP_ui
co:491d: af 40          :  mov R7,?process_UDP_ui+1
co:491f: e4             :  clr A
co:4920: 2f             :  add A,R7
co:4921: ff             :  mov R7,A
co:4922: 74 e2          :  mov A,#226
co:4924: 3e             :  addc A,R6
co:4925: fe             :  mov R6,A
co:4926: 80 29          :  sjmp ?64
                        : ?73:
                        :>                  }
                        :>         }
                        : ?71:
                        :>     }
co:4928: 05 40          :  inc ?process_UDP_ui+1
co:492a: e5 40          :  mov A,?process_UDP_ui+1
co:492c: 70 02          :  jnz ?_31
co:492e: 05 3f          :  inc ?process_UDP_ui
                        : ?_31:
co:4930: 74 32          :  mov A,#50
co:4932: 25 3e          :  add A,?process_UDP_psock+1
co:4934: f5 3e          :  mov ?process_UDP_psock+1,A
co:4936: e4             :  clr A
co:4937: 35 3d          :  addc A,?process_UDP_psock
co:4939: f5 3d          :  mov ?process_UDP_psock,A
                        : 
co:493b: 7c 00          :  mov R4,#0
co:493d: 7d 02          :  mov R5,#2
co:493f: ae 3f          :  mov R6,?process_UDP_ui
co:4941: af 40          :  mov R7,?process_UDP_ui+1
co:4943: c3             :  clr C
co:4944: ef             :  mov A,R7
co:4945: 9d             :  subb A,R5
co:4946: ee             :  mov A,R6
co:4947: 9c             :  subb A,R4
co:4948: 50 03          :  jnc ?_32
co:494a: 02 48 76       :  ljmp ?67
                        : ?_32:
                        : ?69:
                        :>
                        :> // *********** Check local sockets for a match or return ...... ************
                        :> return EVENT_UDP_UNSOLICITED; // None of our Sockets: RETURN
co:494d: 7e e0          :  mov R6,#224
co:494f: 7f 00          :  mov R7,#0
                        : ?64:
co:4951: 22             :  ret
                        : ; end of function process_UDP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:12 bytes
                        : 
                        :  .export _send_upd ; void send_upd(xdata char *, unsigned int, xdata unsigned char (*)[6], unsigned lo
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_upd
                        : _send_upd: ; void send_upd(xdata char *, unsigned int, xdata unsigned char (*)[6], unsigned long, unsi
                        :  ; parameter 'len' in 'RW45' moved and assigned to local '?send_upd_len'
                        :  ; parameter 'rem_ipl' moved and assigned to 'RL0123'
                        :  ; parameter 'sport' assigned to local '?send_upd_0_sport'
                        :  ; parameter 'dport' assigned to local '?send_upd_0_dport'
                        :  ; parameter 'data' in 'RW67' moved and assigned to local '?send_upd_data'
                        :  ; parameter 'pmac' in 'RW23' moved and assigned to local '?send_upd_pmac'
co:4767: 8c 3a          :  mov ?send_upd_len,R4
co:4769: 8d 3b          :  mov ?send_upd_len+1,R5
co:476b: 8e 3c          :  mov ?send_upd_data,R6
co:476d: 8f 3d          :  mov ?send_upd_data+1,R7
co:476f: 8a 3e          :  mov ?send_upd_pmac,R2
co:4771: 8b 3f          :  mov ?send_upd_pmac+1,R3
co:4773: 78 32          :  mov R0,#?send_upd_0_rem_ipl
co:4775: 12 33 0e       :  lcall __ld_r0_r03
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* void send_upd();
                        :>**********************************************************************************/
                        :>#ifdef PHY_ETH
                        :> void send_upd(xdata char* data, uint len,xdata MAC *pmac,unsigned long rem_ipl,uint sport, uint dport
co:4778: 90 01 f0       :  mov DPTR,#_hhdr
co:477b: 74 45          :  mov A,#69
co:477d: f0             :  movx @DPTR,A
co:477e: a3             :  inc DPTR
co:477f: e4             :  clr A
co:4780: f0             :  movx @DPTR,A
                        :>#else
                        :> void send_upd(xdata char* data, uint len,unsigned long rem_ipl,uint sport, uint dport){
                        :>#endif
                        :> // Now fill out IP-Header
                        :> hhdr.vhl_service=0x4500;
                        :> hhdr.len=sizeof(IP_HDR)+8+len; // 8 Bytes UDP-Header
co:4781: ae 3a          :  mov R6,?send_upd_len
co:4783: af 3b          :  mov R7,?send_upd_len+1
co:4785: 74 1c          :  mov A,#28
co:4787: 2f             :  add A,R7
co:4788: ff             :  mov R7,A
co:4789: e4             :  clr A
co:478a: 3e             :  addc A,R6
co:478b: fe             :  mov R6,A
co:478c: 90 01 f2       :  mov DPTR,#_hhdr+2
co:478f: 12 35 40       :  lcall __st_dptr_r67
                        :> hhdr.ident=0;
co:4792: 90 01 f4       :  mov DPTR,#_hhdr+4
co:4795: e4             :  clr A
co:4796: f0             :  movx @DPTR,A
co:4797: a3             :  inc DPTR
co:4798: f0             :  movx @DPTR,A
                        :> hhdr.frags=16384; // No Fragmentation
co:4799: 90 01 f6       :  mov DPTR,#_hhdr+6
co:479c: 74 40          :  mov A,#64
co:479e: f0             :  movx @DPTR,A
co:479f: a3             :  inc DPTR
co:47a0: e4             :  clr A
co:47a1: f0             :  movx @DPTR,A
                        :> hhdr.ttl=100; // Industrial standard
co:47a2: 90 01 f8       :  mov DPTR,#_hhdr+8
co:47a5: 74 64          :  mov A,#100
co:47a7: f0             :  movx @DPTR,A
                        :> hhdr.pcol=17; // UDP
co:47a8: 90 01 f9       :  mov DPTR,#_hhdr+9
co:47ab: 74 11          :  mov A,#17
co:47ad: f0             :  movx @DPTR,A
                        :> hhdr.checksum=0;
co:47ae: 90 01 fa       :  mov DPTR,#_hhdr+10
co:47b1: e4             :  clr A
co:47b2: f0             :  movx @DPTR,A
co:47b3: a3             :  inc DPTR
co:47b4: f0             :  movx @DPTR,A
                        :> hhdr.sip.ipl=my_ip.ipl;
co:47b5: 90 07 fa       :  mov DPTR,#_my_ip
co:47b8: 12 34 f2       :  lcall __ld_dptr_r47
co:47bb: 90 01 fc       :  mov DPTR,#_hhdr+12
co:47be: 12 34 bc       :  lcall __st_dptr_r47
                        :> hhdr.dip.ipl=rem_ipl;
co:47c1: 90 02 00       :  mov DPTR,#_hhdr+16
co:47c4: 12 34 c8       :  lcall __st_dptr_r03
                        :> hhdr.checksum=~(ip_check((xdata uchar*)&hhdr,sizeof(IP_HDR))); // IP-Header only
co:47c7: 7c 00          :  mov R4,#0
co:47c9: 7d 14          :  mov R5,#20
co:47cb: 7e 01          :  mov R6,#((_hhdr)>>8)&255
co:47cd: 7f f0          :  mov R7,#(_hhdr)&255
co:47cf: 12 27 c1       :  lcall _ip_check
co:47d2: ef             :  mov A,R7
co:47d3: f4             :  cpl A
co:47d4: ff             :  mov R7,A
co:47d5: ee             :  mov A,R6
co:47d6: f4             :  cpl A
co:47d7: fe             :  mov R6,A
co:47d8: 90 01 fa       :  mov DPTR,#_hhdr+10
co:47db: 12 35 40       :  lcall __st_dptr_r67
                        :>
                        :> // Now, send out reply
                        :>#ifdef PHY_ETH
                        :> RequestSend_Phy(sizeof(IP_HDR)+14+8+len); // Send Reply:  ETHERNET_HDR IP_HDR UDP_HDR +(data)
co:47de: ae 3a          :  mov R6,?send_upd_len
co:47e0: af 3b          :  mov R7,?send_upd_len+1
co:47e2: 74 2a          :  mov A,#42
co:47e4: 2f             :  add A,R7
co:47e5: ff             :  mov R7,A
co:47e6: e4             :  clr A
co:47e7: 3e             :  addc A,R6
co:47e8: fe             :  mov R6,A
co:47e9: 12 4a 7d       :  lcall _RequestSend_Phy
                        :> Write_Frame_xdata_Phy((xdata uchar*)pmac,6);  // Physical destination
co:47ec: 7c 00          :  mov R4,#0
co:47ee: 7d 06          :  mov R5,#6
co:47f0: ae 3e          :  mov R6,?send_upd_pmac
co:47f2: af 3f          :  mov R7,?send_upd_pmac+1
co:47f4: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_xdata_Phy(my_mac,6);  // From US (MAC)
co:47f7: 7c 00          :  mov R4,#0
co:47f9: 7d 06          :  mov R5,#6
co:47fb: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:47fd: 7f 00          :  mov R7,#(_my_mac)&255
co:47ff: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_word_Phy(0x800);  // type IP
co:4802: 7e 08          :  mov R6,#8
co:4804: 7f 00          :  mov R7,#0
co:4806: 12 3e 93       :  lcall _Write_Frame_word_Phy
                        :>#else
                        :> RequestSend_Phy(sizeof(IP_HDR)+8+len); // Send Reply:  (PPP_HDR) IP_HDR UDP_HDR +(data)
                        :>#endif
                        :>
                        :>
                        :> Write_Frame_xdata_Phy((xdata uchar*)&hhdr,sizeof(IP_HDR));  // Send IP Header
co:4809: 7c 00          :  mov R4,#0
co:480b: 7d 14          :  mov R5,#20
co:480d: 7e 01          :  mov R6,#((_hhdr)>>8)&255
co:480f: 7f f0          :  mov R7,#(_hhdr)&255
co:4811: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_word_Phy(sport);
co:4814: ae 36          :  mov R6,?send_upd_0_sport
co:4816: af 37          :  mov R7,?send_upd_0_sport+1
co:4818: 12 3e 93       :  lcall _Write_Frame_word_Phy
                        :> Write_Frame_word_Phy(dport);
co:481b: ae 38          :  mov R6,?send_upd_0_dport
co:481d: af 39          :  mov R7,?send_upd_0_dport+1
co:481f: 12 3e 93       :  lcall _Write_Frame_word_Phy
                        :> Write_Frame_word_Phy(len+8);  // Including UDP_HDR...
co:4822: ae 3a          :  mov R6,?send_upd_len
co:4824: af 3b          :  mov R7,?send_upd_len+1
co:4826: 74 08          :  mov A,#8
co:4828: 2f             :  add A,R7
co:4829: ff             :  mov R7,A
co:482a: e4             :  clr A
co:482b: 3e             :  addc A,R6
co:482c: fe             :  mov R6,A
co:482d: 12 3e 93       :  lcall _Write_Frame_word_Phy
                        :> Write_Frame_word_Phy(0);  // 0: Means: Checksum not computed
co:4830: e4             :  clr A
co:4831: fe             :  mov R6,A
co:4832: ff             :  mov R7,A
co:4833: 12 3e 93       :  lcall _Write_Frame_word_Phy
                        :>
                        :> Write_Frame_xdata_Phy(data,len);   // Send data
co:4836: ac 3a          :  mov R4,?send_upd_len
co:4838: ad 3b          :  mov R5,?send_upd_len+1
co:483a: ae 3c          :  mov R6,?send_upd_data
co:483c: af 3d          :  mov R7,?send_upd_data+1
co:483e: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :> CommitSend_Phy();      // Start TX
co:4841: 12 4e 33       :  lcall _CommitSend_Phy
co:4844: 22             :  ret
                        : ; end of function send_upd
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:6 bytes formals:8 bytes
                        : 
                        :  .export _send_TCP ; void send_TCP(xdata char *, unsigned int, xdata unsigned char (*)[6], unsigned lo
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_TCP
                        : _send_TCP: ; void send_TCP(xdata char *, unsigned int, xdata unsigned char (*)[6], unsigned long)
                        :  ; parameter 'len' in 'RW45' moved and assigned to local '?send_TCP_len'
                        :  ; parameter 'rem_ipl' assigned to local '?send_TCP_0_rem_ipl'
                        :  ; parameter 'data' in 'RW67' moved and assigned to local '?send_TCP_data'
                        :  ; parameter 'pmac' in 'RW23' moved and assigned to local '?send_TCP_pmac'
co:40b7: 8c 47          :  mov ?send_TCP_len,R4
co:40b9: 8d 48          :  mov ?send_TCP_len+1,R5
co:40bb: 8e 49          :  mov ?send_TCP_data,R6
co:40bd: 8f 4a          :  mov ?send_TCP_data+1,R7
co:40bf: 8a 4b          :  mov ?send_TCP_pmac,R2
co:40c1: 8b 4c          :  mov ?send_TCP_pmac+1,R3
                        :>}
                        :>#endif
                        :>
                        :>/**********************************************************************************
                        :>* void send_TCP();
                        :>*
                        :>* Will send a given Segment as IP-TCP-(DATA). ACK,SEQU,WINDOW,FLAGS must be set
                        :>* by the caller! TCP-Checksum is computed. 
                        :>* MSS-option inserted for Flags with TSYN. Rem.: MSS must be >= 576 Bytes!
                        :>**********************************************************************************/
                        :>#ifdef PHY_ETH
                        :> void send_TCP(xdata char* data, uint len,xdata MAC *pmac,unsigned long rem_ipl){
co:40c3: 90 01 dc       :  mov DPTR,#_hframe+12
co:40c6: 74 50          :  mov A,#80
co:40c8: f0             :  movx @DPTR,A
                        :>#else
                        :> void send_TCP(xdata char* data, uint len,unsigned long rem_ipl){
                        :>#endif
                        :> uint data_cs;
                        :>
                        :>#ifdef USE_MSS
                        :> uint tcp_hdr_len;
                        :> if(hframe.tcp_hdr.flags & TSYN){
                        :>        tcp_hdr_len=24;
                        :>        hframe.tcp_hdr.mss=0x2040000+MAX_RX;
                        :>        hframe.tcp_hdr.hlen=96;   // Ext. Size: 24 Bytes
                        :> }else{
                        :>        tcp_hdr_len=20;
                        :>        hframe.tcp_hdr.hlen=80;   // Standard Size: 20 Bytes
                        :> }
                        :>#else
                        :> #define tcp_hdr_len 20
                        :> hframe.tcp_hdr.hlen=80;   // Standard Size: 20 Bytes
                        :>#endif
                        :>
                        :>
                        :> hframe.tcp_hdr.checksum=0;
co:40c9: 90 01 e0       :  mov DPTR,#_hframe+16
co:40cc: e4             :  clr A
co:40cd: f0             :  movx @DPTR,A
co:40ce: a3             :  inc DPTR
co:40cf: f0             :  movx @DPTR,A
                        :>
                        :> pseudo_hdr.sip.ipl=my_ip.ipl;  // Built Pseudo-Header for Checksum
co:40d0: 90 07 fa       :  mov DPTR,#_my_ip
co:40d3: 12 34 f2       :  lcall __ld_dptr_r47
co:40d6: 90 01 e4       :  mov DPTR,#_pseudo_hdr
co:40d9: 12 34 bc       :  lcall __st_dptr_r47
                        :> pseudo_hdr.dip.ipl=rem_ipl;
co:40dc: 74 43          :  mov A,#?send_TCP_0_rem_ipl
co:40de: 12 33 44       :  lcall __ld_a_r47
co:40e1: 90 01 e8       :  mov DPTR,#_pseudo_hdr+4
co:40e4: 12 34 bc       :  lcall __st_dptr_r47
                        :> pseudo_hdr.pcol=6; // TCP
co:40e7: 90 01 ec       :  mov DPTR,#_pseudo_hdr+8
co:40ea: e4             :  clr A
co:40eb: f0             :  movx @DPTR,A
co:40ec: a3             :  inc DPTR
co:40ed: 74 06          :  mov A,#6
co:40ef: f0             :  movx @DPTR,A
                        :> pseudo_hdr.len=len+tcp_hdr_len;   // Data+TCP-Header, without Pseudo-header!
co:40f0: ae 47          :  mov R6,?send_TCP_len
co:40f2: af 48          :  mov R7,?send_TCP_len+1
co:40f4: 74 14          :  mov A,#20
co:40f6: 2f             :  add A,R7
co:40f7: ff             :  mov R7,A
co:40f8: e4             :  clr A
co:40f9: 3e             :  addc A,R6
co:40fa: fe             :  mov R6,A
co:40fb: 90 01 ee       :  mov DPTR,#_pseudo_hdr+10
co:40fe: 12 35 40       :  lcall __st_dptr_r67
                        :> data_cs=ip_check(data,len); // Checksum of Data Block
co:4101: ac 47          :  mov R4,?send_TCP_len
co:4103: ad 48          :  mov R5,?send_TCP_len+1
co:4105: ae 49          :  mov R6,?send_TCP_data
co:4107: af 4a          :  mov R7,?send_TCP_data+1
co:4109: 12 27 c1       :  lcall _ip_check
                        :  ; variable 'data_cs' assigned to register 'RW67'
                        :> hframe.tcp_hdr.checksum = ~( // Checksum of Header, Datablock and Pseudo_header
co:410c: aa 06          :  mov R2,AR6
co:410e: ab 07          :  mov R3,AR7
co:4110: 7c 00          :  mov R4,#0
co:4112: 7d 0c          :  mov R5,#12
co:4114: 7e 01          :  mov R6,#((_pseudo_hdr)>>8)&255
co:4116: 7f e4          :  mov R7,#(_pseudo_hdr)&255
co:4118: 12 27 c4       :  lcall _ip_check_more
co:411b: aa 06          :  mov R2,AR6
co:411d: ab 07          :  mov R3,AR7
co:411f: 7c 00          :  mov R4,#0
co:4121: 7d 14          :  mov R5,#20
co:4123: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:4125: 7f d0          :  mov R7,#(_hframe)&255
co:4127: 12 27 c4       :  lcall _ip_check_more
co:412a: ef             :  mov A,R7
co:412b: f4             :  cpl A
co:412c: ff             :  mov R7,A
co:412d: ee             :  mov A,R6
co:412e: f4             :  cpl A
co:412f: fe             :  mov R6,A
co:4130: 90 01 e0       :  mov DPTR,#_hframe+16
co:4133: 12 35 40       :  lcall __st_dptr_r67
                        :>  ip_check_more(hframe.bytes,tcp_hdr_len, // TCP-Header
                        :>   ip_check_more((xdata uchar*)&pseudo_hdr,sizeof(PSEUDO_HDR), // Pseudo-header
                        :>    data_cs))); // Data
                        :>
                        :> // Now fill out IP-Header
                        :> hhdr.vhl_service=0x4500;
co:4136: 90 01 f0       :  mov DPTR,#_hhdr
co:4139: 74 45          :  mov A,#69
co:413b: f0             :  movx @DPTR,A
co:413c: a3             :  inc DPTR
co:413d: e4             :  clr A
co:413e: f0             :  movx @DPTR,A
                        :> hhdr.len=sizeof(IP_HDR)+tcp_hdr_len+len; // 20/24 Bytes TCP-Header (24 if MSS required)
co:413f: ae 47          :  mov R6,?send_TCP_len
co:4141: af 48          :  mov R7,?send_TCP_len+1
co:4143: 74 28          :  mov A,#40
co:4145: 2f             :  add A,R7
co:4146: ff             :  mov R7,A
co:4147: e4             :  clr A
co:4148: 3e             :  addc A,R6
co:4149: fe             :  mov R6,A
co:414a: 90 01 f2       :  mov DPTR,#_hhdr+2
co:414d: 12 35 40       :  lcall __st_dptr_r67
                        :> hhdr.ident=0;
co:4150: 90 01 f4       :  mov DPTR,#_hhdr+4
co:4153: e4             :  clr A
co:4154: f0             :  movx @DPTR,A
co:4155: a3             :  inc DPTR
co:4156: f0             :  movx @DPTR,A
                        :> hhdr.frags=16384; // No Fragmentation
co:4157: 90 01 f6       :  mov DPTR,#_hhdr+6
co:415a: 74 40          :  mov A,#64
co:415c: f0             :  movx @DPTR,A
co:415d: a3             :  inc DPTR
co:415e: e4             :  clr A
co:415f: f0             :  movx @DPTR,A
                        :> hhdr.ttl=100; // Industrial standard
co:4160: 90 01 f8       :  mov DPTR,#_hhdr+8
co:4163: 74 64          :  mov A,#100
co:4165: f0             :  movx @DPTR,A
                        :> hhdr.pcol=6; // TCP
co:4166: 90 01 f9       :  mov DPTR,#_hhdr+9
co:4169: 74 06          :  mov A,#6
co:416b: f0             :  movx @DPTR,A
                        :> hhdr.checksum=0;
co:416c: 90 01 fa       :  mov DPTR,#_hhdr+10
co:416f: e4             :  clr A
co:4170: f0             :  movx @DPTR,A
co:4171: a3             :  inc DPTR
co:4172: f0             :  movx @DPTR,A
                        :> hhdr.sip.ipl=my_ip.ipl;
co:4173: 90 07 fa       :  mov DPTR,#_my_ip
co:4176: 12 34 f2       :  lcall __ld_dptr_r47
co:4179: 90 01 fc       :  mov DPTR,#_hhdr+12
co:417c: 12 34 bc       :  lcall __st_dptr_r47
                        :> hhdr.dip.ipl=rem_ipl;
co:417f: 74 43          :  mov A,#?send_TCP_0_rem_ipl
co:4181: 12 33 44       :  lcall __ld_a_r47
co:4184: 90 02 00       :  mov DPTR,#_hhdr+16
co:4187: 12 34 bc       :  lcall __st_dptr_r47
                        :> hhdr.checksum=~(ip_check((xdata uchar*)&hhdr,sizeof(IP_HDR))); // IP-Header only
co:418a: 7c 00          :  mov R4,#0
co:418c: 7d 14          :  mov R5,#20
co:418e: 7e 01          :  mov R6,#((_hhdr)>>8)&255
co:4190: 7f f0          :  mov R7,#(_hhdr)&255
co:4192: 12 27 c1       :  lcall _ip_check
co:4195: ef             :  mov A,R7
co:4196: f4             :  cpl A
co:4197: ff             :  mov R7,A
co:4198: ee             :  mov A,R6
co:4199: f4             :  cpl A
co:419a: fe             :  mov R6,A
co:419b: 90 01 fa       :  mov DPTR,#_hhdr+10
co:419e: 12 35 40       :  lcall __st_dptr_r67
                        :>
                        :> // Now, send out reply
                        :>#ifdef PHY_ETH
                        :> RequestSend_Phy(sizeof(IP_HDR)+14+tcp_hdr_len+len); // Send Reply:  ETHERNET_HDR IP_HDR TCP_HDR +(dat
co:41a1: ae 47          :  mov R6,?send_TCP_len
co:41a3: af 48          :  mov R7,?send_TCP_len+1
co:41a5: 74 36          :  mov A,#54
co:41a7: 2f             :  add A,R7
co:41a8: ff             :  mov R7,A
co:41a9: e4             :  clr A
co:41aa: 3e             :  addc A,R6
co:41ab: fe             :  mov R6,A
co:41ac: 12 4a 7d       :  lcall _RequestSend_Phy
                        :> Write_Frame_xdata_Phy((xdata uchar*)pmac,6);  // Physical destination
co:41af: 7c 00          :  mov R4,#0
co:41b1: 7d 06          :  mov R5,#6
co:41b3: ae 4b          :  mov R6,?send_TCP_pmac
co:41b5: af 4c          :  mov R7,?send_TCP_pmac+1
co:41b7: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_xdata_Phy(my_mac,6);  // From US (MAC)
co:41ba: 7c 00          :  mov R4,#0
co:41bc: 7d 06          :  mov R5,#6
co:41be: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:41c0: 7f 00          :  mov R7,#(_my_mac)&255
co:41c2: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_word_Phy(0x800);  // type IP
co:41c5: 7e 08          :  mov R6,#8
co:41c7: 7f 00          :  mov R7,#0
co:41c9: 12 3e 93       :  lcall _Write_Frame_word_Phy
                        :>#else
                        :> RequestSend_Phy(sizeof(IP_HDR)+tcp_hdr_len+len); // Send Reply:  (PPP+ ) IP_HDR TCP_HDR +(data)
                        :>#endif
                        :>
                        :> Write_Frame_xdata_Phy((xdata uchar*)&hhdr,sizeof(IP_HDR));  // Send IP Header
co:41cc: 7c 00          :  mov R4,#0
co:41ce: 7d 14          :  mov R5,#20
co:41d0: 7e 01          :  mov R6,#((_hhdr)>>8)&255
co:41d2: 7f f0          :  mov R7,#(_hhdr)&255
co:41d4: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_xdata_Phy(hframe.bytes,tcp_hdr_len);  // Send TCP Header
co:41d7: 7c 00          :  mov R4,#0
co:41d9: 7d 14          :  mov R5,#20
co:41db: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:41dd: 7f d0          :  mov R7,#(_hframe)&255
co:41df: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :> Write_Frame_xdata_Phy(data,len);   // Send data
co:41e2: ac 47          :  mov R4,?send_TCP_len
co:41e4: ad 48          :  mov R5,?send_TCP_len+1
co:41e6: ae 49          :  mov R6,?send_TCP_data
co:41e8: af 4a          :  mov R7,?send_TCP_data+1
co:41ea: 12 3b a7       :  lcall _Write_Frame_xdata_Phy
                        :> CommitSend_Phy();      // Start TX
co:41ed: 12 4e 33       :  lcall _CommitSend_Phy
co:41f0: 22             :  ret
                        : ; end of function send_TCP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:6 bytes formals:4 bytes
                        : 
                        :  .export _send_incomming_reset_TCP ; void send_incomming_reset_TCP(unsigned int, xdata unsigned char (
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_incomming_reset_TCP
                        : _send_incomming_reset_TCP: ; void send_incomming_reset_TCP(unsigned int, xdata unsigned char (*)[6], u
                        :  ; parameter 'ipl' in 'RL0123' assigned to 'B1_RL12131415'
                        :  ; parameter 'pmac' in 'RW45' moved and assigned to local '?send_incomming_reset_TCP_pmac'
                        :  ; parameter 'dlen' in 'RW67' assigned to 'RW23'
co:3eec: 8c 41          :  mov ?send_incomming_reset_TCP_pmac,R4
co:3eee: 8d 42          :  mov ?send_incomming_reset_TCP_pmac+1,R5
co:3ef0: 12 35 5b       :  lcall __movel_0_12
co:3ef3: aa 06          :  mov R2,AR6
co:3ef5: ab 07          :  mov R3,AR7
                        :>
                        :>#ifdef DEBUG_REC
                        :>    // Record Data of Transmitted Frame
                        :>    record_frame('T',hframe.tcp_hdr.dport,hframe.tcp_hdr.seq.u,hframe.tcp_hdr.ack.u, hframe.tcp_hdr.fl
                        :>#endif
                        :>
                        :>}
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* void send_incomming_reset_TCP();
                        :>*
                        :>* Build reset-segment as reply without using match_socket, i.e. as denial for an
                        :>* incomming request... ACK included.
                        :>**********************************************************************************/
                        :>#ifdef PHY_ETH
                        :> void send_incomming_reset_TCP(uint dlen,xdata MAC *pmac,unsigned long ipl){
co:3ef7: 90 01 d2       :  mov DPTR,#_hframe+2
co:3efa: 12 35 46       :  lcall __ld_dptr_r45
                        :  ; variable 'sport' assigned to register 'RW45'
                        :>#else
                        :> void send_incomming_reset_TCP(uint dlen,unsigned long ipl){
                        :>#endif
                        :> unsigned long ack;
                        :> uint sport;
                        :> sport=hframe.tcp_hdr.dport;
                        :> hframe.tcp_hdr.dport=hframe.tcp_hdr.sport; // Bounce port
co:3efd: 90 01 d0       :  mov DPTR,#_hframe
co:3f00: 12 35 4c       :  lcall __ld_dptr_r67
co:3f03: 90 01 d2       :  mov DPTR,#_hframe+2
co:3f06: 12 35 40       :  lcall __st_dptr_r67
                        :> hframe.tcp_hdr.sport=sport;
co:3f09: 90 01 d0       :  mov DPTR,#_hframe
co:3f0c: 12 34 e0       :  lcall __st_dptr_r45
                        :>
                        :> // Window, Flags and Set ACK and SEQU in the response, rest will be completed by send_tcp
                        :> hframe.tcp_hdr.window=0;  // No reply!
co:3f0f: 90 01 de       :  mov DPTR,#_hframe+14
co:3f12: e4             :  clr A
co:3f13: f0             :  movx @DPTR,A
co:3f14: a3             :  inc DPTR
co:3f15: f0             :  movx @DPTR,A
                        :> ack=hframe.tcp_hdr.seq.u+dlen;
co:3f16: e4             :  clr A
co:3f17: f9             :  mov R1,A
co:3f18: f8             :  mov R0,A
co:3f19: 90 01 d4       :  mov DPTR,#_hframe+4
co:3f1c: 12 34 f2       :  lcall __ld_dptr_r47
co:3f1f: 12 35 9e       :  lcall __add_i4
                        :  ; variable 'ack' assigned to register 'B1_RL891011'
co:3f22: 12 35 52       :  lcall __movel_4_8
                        :> if(hframe.tcp_hdr.flags & (TSYN | TFIN)) ack++;
co:3f25: 90 01 dd       :  mov DPTR,#_hframe+13
co:3f28: e0             :  movx A,@DPTR
co:3f29: ff             :  mov R7,A
co:3f2a: 54 03          :  anl A,#3
co:3f2c: ff             :  mov R7,A
co:3f2d: 60 14          :  jz ?81
                        : 
co:3f2f: 05 0b          :  inc AR11
co:3f31: e5 0b          :  mov A,AR11
co:3f33: 70 0e          :  jnz ?_34
co:3f35: 05 0a          :  inc AR10
co:3f37: e5 0a          :  mov A,AR10
co:3f39: 70 08          :  jnz ?_34
co:3f3b: 05 09          :  inc AR9
co:3f3d: e5 09          :  mov A,AR9
co:3f3f: 70 02          :  jnz ?_34
co:3f41: 05 08          :  inc AR8
                        : ?_34:
                        : ?81:
                        :> hframe.tcp_hdr.seq.u=hframe.tcp_hdr.ack.u;
co:3f43: 90 01 d8       :  mov DPTR,#_hframe+8
co:3f46: 12 34 f2       :  lcall __ld_dptr_r47
co:3f49: 90 01 d4       :  mov DPTR,#_hframe+4
co:3f4c: 12 34 bc       :  lcall __st_dptr_r47
                        :> hframe.tcp_hdr.ack.u=ack;
co:3f4f: 12 33 ff       :  lcall __movel_8_4
co:3f52: 90 01 d8       :  mov DPTR,#_hframe+8
co:3f55: 12 34 bc       :  lcall __st_dptr_r47
                        :> hframe.tcp_hdr.flags=TRST+TACK;
co:3f58: 90 01 dd       :  mov DPTR,#_hframe+13
co:3f5b: 74 14          :  mov A,#20
co:3f5d: f0             :  movx @DPTR,A
                        :>#ifdef PHY_ETH
                        :> send_TCP(0,0,pmac,ipl); // Replay (Ethernet)
co:3f5e: 85 0c 43       :  mov _send_TCP_formal_near,AR12
co:3f61: 85 0d 44       :  mov _send_TCP_formal_near+1,AR13
co:3f64: 85 0e 45       :  mov _send_TCP_formal_near+2,AR14
co:3f67: 85 0f 46       :  mov _send_TCP_formal_near+3,AR15
co:3f6a: aa 41          :  mov R2,?send_incomming_reset_TCP_pmac
co:3f6c: ab 42          :  mov R3,?send_incomming_reset_TCP_pmac+1
co:3f6e: e4             :  clr A
co:3f6f: fc             :  mov R4,A
co:3f70: fd             :  mov R5,A
co:3f71: e4             :  clr A
co:3f72: fe             :  mov R6,A
co:3f73: ff             :  mov R7,A
co:3f74: 12 40 b7       :  lcall _send_TCP
co:3f77: 22             :  ret
                        : ; end of function send_incomming_reset_TCP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .export _send_match_ok_TCP ; void send_match_ok_TCP(xdata unsigned char *, unsigned int, unsigned cha
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_match_ok_TCP
                        : _send_match_ok_TCP: ; void send_match_ok_TCP(xdata unsigned char *, unsigned int, unsigned char)
                        :  ; parameter 'flags' in 'R3'
                        :  ; parameter 'dlen' in 'RW45' assigned to 'RW01'
                        :  ; parameter 'pdata' in 'RW67' assigned to 'B1_RW1213'
co:41f1: a8 04          :  mov R0,AR4
co:41f3: a9 05          :  mov R1,AR5
co:41f5: 8e 0c          :  mov AR12,R6
co:41f7: 8f 0d          :  mov AR13,R7
                        :>#else
                        :> send_TCP(0,0,ipl); // Replay (PPP)
                        :>#endif
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* void send_match_ok_TCP();
                        :>*
                        :>* Build Segment header and send it as regular Header, Data are in *pdata, size alen
                        :>* match_socket must fit! hframe used as a temporary variable
                        :>**********************************************************************************/
                        :>void send_match_ok_TCP(xdata uchar *pdata, uint dlen, uchar flags){
co:41f9: 90 00 18       :  mov DPTR,#_match_socket+14
co:41fc: 12 35 4c       :  lcall __ld_dptr_r67
co:41ff: 90 01 d0       :  mov DPTR,#_hframe
co:4202: 12 35 40       :  lcall __st_dptr_r67
                        :> unsigned long seq;
                        :>
                        :> hframe.tcp_hdr.sport=match_socket.local_port; // Our Port
                        :> hframe.tcp_hdr.dport=match_socket.sremote_port; // Remote
co:4205: 90 00 16       :  mov DPTR,#_match_socket+12
co:4208: 12 35 4c       :  lcall __ld_dptr_r67
co:420b: 90 01 d2       :  mov DPTR,#_hframe+2
co:420e: 12 35 40       :  lcall __st_dptr_r67
                        :>
                        :> // Window, Flags and Set ACK and SEQU in the response, rest will be completed by send_tcp
                        :> hframe.tcp_hdr.window=MAX_RX;  // Sender: Do not send more the MAX_RX
co:4211: 90 01 de       :  mov DPTR,#_hframe+14
co:4214: 74 05          :  mov A,#5
co:4216: f0             :  movx @DPTR,A
co:4217: a3             :  inc DPTR
co:4218: 74 78          :  mov A,#120
co:421a: f0             :  movx @DPTR,A
                        :  ; variable 'seq' assigned to register 'B1_RL891011'
                        :>
                        :> seq=match_socket.sseq.u;
co:421b: 90 00 1e       :  mov DPTR,#_match_socket+20
co:421e: e0             :  movx A,@DPTR
co:421f: f5 08          :  mov AR8,A
co:4221: a3             :  inc DPTR
co:4222: e0             :  movx A,@DPTR
co:4223: f5 09          :  mov AR9,A
co:4225: a3             :  inc DPTR
co:4226: e0             :  movx A,@DPTR
co:4227: f5 0a          :  mov AR10,A
co:4229: a3             :  inc DPTR
co:422a: e0             :  movx A,@DPTR
co:422b: f5 0b          :  mov AR11,A
                        :> if(flags & (TSYN)) seq--;  // If a SYN is sent, count this as 1
co:422d: eb             :  mov A,R3
co:422e: 54 02          :  anl A,#2
co:4230: ff             :  mov R7,A
co:4231: 60 14          :  jz ?84
                        : 
co:4233: e5 0b          :  mov A,AR11
co:4235: 15 0b          :  dec AR11
co:4237: 70 0e          :  jnz ?_36
co:4239: e5 0a          :  mov A,AR10
co:423b: 15 0a          :  dec AR10
co:423d: 70 08          :  jnz ?_36
co:423f: e5 09          :  mov A,AR9
co:4241: 15 09          :  dec AR9
co:4243: 70 02          :  jnz ?_36
co:4245: 15 08          :  dec AR8
                        : ?_36:
                        : ?84:
                        :> hframe.tcp_hdr.seq.u=seq;
co:4247: 12 33 ff       :  lcall __movel_8_4
co:424a: 90 01 d4       :  mov DPTR,#_hframe+4
co:424d: 12 34 bc       :  lcall __st_dptr_r47
                        :>
                        :> hframe.tcp_hdr.ack.u=match_socket.sack.u; // This was received from the Sender
co:4250: 90 00 1a       :  mov DPTR,#_match_socket+16
co:4253: 12 34 f2       :  lcall __ld_dptr_r47
co:4256: 90 01 d8       :  mov DPTR,#_hframe+8
co:4259: 12 34 bc       :  lcall __st_dptr_r47
                        :> hframe.tcp_hdr.flags=flags;
co:425c: 90 01 dd       :  mov DPTR,#_hframe+13
co:425f: eb             :  mov A,R3
co:4260: f0             :  movx @DPTR,A
                        :>
                        :> // Send empty
                        :>#ifdef PHY_ETH
                        :> send_TCP(pdata,dlen,match_socket.sremote_mac, match_socket.sremote_ip );
co:4261: 90 00 12       :  mov DPTR,#_match_socket+8
co:4264: 12 34 f2       :  lcall __ld_dptr_r47
co:4267: 74 43          :  mov A,#_send_TCP_formal_near
co:4269: 12 32 9c       :  lcall __st_a_r47
co:426c: 7a 00          :  mov R2,#((_match_socket+2)>>8)&255
co:426e: 7b 0c          :  mov R3,#(_match_socket+2)&255
co:4270: ac 00          :  mov R4,AR0
co:4272: ad 01          :  mov R5,AR1
co:4274: ae 0c          :  mov R6,AR12
co:4276: af 0d          :  mov R7,AR13
co:4278: 12 40 b7       :  lcall _send_TCP
co:427b: 22             :  ret
                        : ; end of function send_match_ok_TCP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _state_machine_TCP ; unsigned int state_machine_TCP(unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __state_machine_TCP
                        : _state_machine_TCP: ; unsigned int state_machine_TCP(unsigned int)
                        :  ; parameter 'dlen' in 'RW67' moved and assigned to local '?state_machine_TCP_dlen'
co:369e: 8e 41          :  mov ?state_machine_TCP_dlen,R6
co:36a0: 8f 42          :  mov ?state_machine_TCP_dlen+1,R7
                        :>#else
                        :> send_TCP(pdata,dlen, match_socket.sremote_ip );
                        :>#endif
                        :>
                        :> // printf("<TX P:%u A:%x S:%x F:%u, T:%u> ", hframe.tcp_hdr.dport, hframe.tcp_hdr.ack.w.l_word,hframe
                        :>
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uint state_machine_TCP(uint dlen);
                        :>*
                        :>* 4.rd-Level-Multiplexer
                        :>*
                        :>* Process one step in the TCP-state-Machine. The 'match_socket' follows the 
                        :>* TCP-State-Machine if its type is SOCKET_HTTP or SOCKET_TCP.
                        :>* The low_word of the sequence-number is the offset for SOCKET_HTTP. May wrap 
                        :>* for SOCKET_TCP! So resending the sequence-number $zzzz0000 for SOCKET_HTTP implies
                        :>* resending the SYN!
                        :>* if this routine is called, destination/source port match already checked and
                        :>* 'match_socket' copied...
                        :>**********************************************************************************/
                        :>uint state_machine_TCP(uint dlen){
co:36a2: 90 01 dd       :  mov DPTR,#_hframe+13
co:36a5: e0             :  movx A,@DPTR
co:36a6: ff             :  mov R7,A
co:36a7: 54 04          :  anl A,#4
co:36a9: ff             :  mov R7,A
co:36aa: 60 0f          :  jz ?87
                        :>
                        :> if(hframe.tcp_hdr.flags&TRST){
co:36ac: 12 3b ee       :  lcall _free_match_socket
                        :>  free_match_socket();   // Free Buffers if allocated... 
                        :>  match_socket.state=TCP_CLOSED;  // Connection ends immediatelly
co:36af: 90 00 0b       :  mov DPTR,#_match_socket+1
co:36b2: e4             :  clr A
co:36b3: f0             :  movx @DPTR,A
                        :>  return EVENT_TCP_RESETRECEIVED;
co:36b4: 7e f9          :  mov R6,#249
co:36b6: 7f 00          :  mov R7,#0
co:36b8: 02 3a 4a       :  ljmp ?86
                        : ?87:
                        :> }
                        :>
                        :> // printf("<rx P:%u A:%x S:%x F:%u, T:%u> ", hframe.tcp_hdr.sport,hframe.tcp_hdr.ack.w.l_word,hframe.
                        :>
                        :> match_socket.timer=BASIC_RETRY_TIMER;
co:36bb: 90 00 23       :  mov DPTR,#_match_socket+25
co:36be: 74 06          :  mov A,#6
co:36c0: f0             :  movx @DPTR,A
                        :>
                        :> switch(match_socket.state){
co:36c1: 90 00 0b       :  mov DPTR,#_match_socket+1
co:36c4: e0             :  movx A,@DPTR
co:36c5: fd             :  mov R5,A
co:36c6: 7f 04          :  mov R7,#4
co:36c8: d3             :  setb C
co:36c9: ed             :  mov A,R5
co:36ca: 9f             :  subb A,R7
co:36cb: 40 03          :  jc ?_38
co:36cd: 02 3a 2d       :  ljmp ?89
                        : ?_38:
co:36d0: 90 3a 4b       :  mov DPTR,#?i129
co:36d3: ed             :  mov A,R5
co:36d4: 2d             :  add A,R5
co:36d5: 50 02          :  jnc ?_39
co:36d7: 05 83          :  inc DPH
                        : ?_39:
co:36d9: 25 82          :  add A,DPL
co:36db: f5 82          :  mov DPL,A
co:36dd: 50 02          :  jnc ?_40
co:36df: 05 83          :  inc DPH
                        : ?_40:
co:36e1: 74 01          :  mov A,#1
co:36e3: 93             :  movc A,@A+DPTR
co:36e4: c0 e0          :  push ACC
co:36e6: e4             :  clr A
co:36e7: 93             :  movc A,@A+DPTR
co:36e8: c0 e0          :  push ACC
co:36ea: 22             :  ret
                        : 
                        : ?92:
                        :>
                        :> // Socket was listening. Only a SYN could change this
                        :> case TCP_CLOSED:  // Passive open!
                        :>  if(!(hframe.tcp_hdr.flags&TSYN)) break;
co:36eb: 90 01 dd       :  mov DPTR,#_hframe+13
co:36ee: e0             :  movx A,@DPTR
co:36ef: ff             :  mov R7,A
co:36f0: 54 02          :  anl A,#2
co:36f2: ff             :  mov R7,A
co:36f3: 70 03          :  jnz ?93
                        : 
co:36f5: 02 3a 2d       :  ljmp ?90
                        : ?93:
                        :>  // puts("<SYN RECEIVED>");
                        :>
                        :>#ifdef USE_TCP_CLIENT
                        :>  if(match_socket.tcp_client_flag!=FLAG_PASSIVE_OPEN) break; // Passove open not allowed.
                        :>#endif
                        :>
                        :>#ifdef PHY_ETH
                        :>  // Fast XDATA copy by two casts... (6 Bytes)
                        :>  *(xdata unsigned long*)match_socket.sremote_mac=*(xdata unsigned long*)remote_mac;
co:36f8: 90 02 0a       :  mov DPTR,#_remote_mac
co:36fb: 12 34 f2       :  lcall __ld_dptr_r47
co:36fe: 90 00 0c       :  mov DPTR,#_match_socket+2
co:3701: 12 34 bc       :  lcall __st_dptr_r47
                        :>  *(xdata uint*)(match_socket.sremote_mac+4)=*(xdata uint*)(remote_mac+4);
co:3704: 90 02 0e       :  mov DPTR,#_remote_mac+4
co:3707: 12 35 4c       :  lcall __ld_dptr_r67
co:370a: 90 00 10       :  mov DPTR,#_match_socket+2+4
co:370d: 12 35 40       :  lcall __st_dptr_r67
                        :>#endif
                        :>
                        :>  // Save remote's IP, set by process_IP() and other data
                        :>  match_socket.sremote_ip=remote_ip.ipl;
co:3710: 90 07 f6       :  mov DPTR,#_remote_ip
co:3713: 12 34 f2       :  lcall __ld_dptr_r47
co:3716: 90 00 12       :  mov DPTR,#_match_socket+8
co:3719: 12 34 bc       :  lcall __st_dptr_r47
                        :>  match_socket.sremote_port=hframe.tcp_hdr.sport; // Remote Port match already matching!
co:371c: 90 01 d0       :  mov DPTR,#_hframe
co:371f: 12 35 4c       :  lcall __ld_dptr_r67
co:3722: 90 00 16       :  mov DPTR,#_match_socket+12
co:3725: 12 35 40       :  lcall __st_dptr_r67
                        :>  // Our Ack is sender's Sequence!
                        :>  match_socket.sack.u=hframe.tcp_hdr.seq.u+dlen+1; // +1: Bec. SYN rcvd.
co:3728: ae 41          :  mov R6,?state_machine_TCP_dlen
co:372a: af 42          :  mov R7,?state_machine_TCP_dlen+1
co:372c: ab 07          :  mov R3,AR7
co:372e: aa 06          :  mov R2,AR6
co:3730: e4             :  clr A
co:3731: f9             :  mov R1,A
co:3732: f8             :  mov R0,A
co:3733: 90 01 d4       :  mov DPTR,#_hframe+4
co:3736: 12 34 f2       :  lcall __ld_dptr_r47
co:3739: 12 35 9e       :  lcall __add_i4
co:373c: e4             :  clr A
co:373d: f8             :  mov R0,A
co:373e: f9             :  mov R1,A
co:373f: fa             :  mov R2,A
co:3740: 7b 01          :  mov R3,#1
co:3742: 12 35 9e       :  lcall __add_i4
co:3745: 90 00 1a       :  mov DPTR,#_match_socket+16
co:3748: 12 34 bc       :  lcall __st_dptr_r47
                        :>  match_socket.sseq.w.h_word=net_service_cnt;   // Time ascending...
co:374b: af 26          :  mov R7,_net_service_cnt
co:374d: 7e 00          :  mov R6,#0
co:374f: 90 00 1e       :  mov DPTR,#_match_socket+20
co:3752: 12 35 40       :  lcall __st_dptr_r67
                        :>  match_socket.sseq.w.l_word=0;    // Our relative Pointer (for HTTP)
co:3755: 90 00 20       :  mov DPTR,#_match_socket+20+2
co:3758: e4             :  clr A
co:3759: f0             :  movx @DPTR,A
co:375a: a3             :  inc DPTR
co:375b: f0             :  movx @DPTR,A
                        :>
                        :>  send_match_ok_TCP(0,0,TSYN+TACK); // Reply with a single SYN+ACK
co:375c: 7b 12          :  mov R3,#18
co:375e: e4             :  clr A
co:375f: fc             :  mov R4,A
co:3760: fd             :  mov R5,A
co:3761: e4             :  clr A
co:3762: fe             :  mov R6,A
co:3763: ff             :  mov R7,A
co:3764: 12 41 f1       :  lcall _send_match_ok_TCP
                        :>  // puts("<SYN+ACK SENT>");
                        :>
                        :>  match_socket.state=TCP_SYNCON;  // SYN confirmed with SYN+ACK
co:3767: 90 00 0b       :  mov DPTR,#_match_socket+1
co:376a: 74 01          :  mov A,#1
co:376c: f0             :  movx @DPTR,A
                        :>  match_socket.retry_cnt=0;
co:376d: 90 00 22       :  mov DPTR,#_match_socket+24
co:3770: e4             :  clr A
co:3771: f0             :  movx @DPTR,A
                        :>  return EVENT_TCP_SYNRECEIVED; // Low-Byte added by caller!
co:3772: 7e f2          :  mov R6,#242
co:3774: 7f 00          :  mov R7,#0
co:3776: 02 3a 4a       :  ljmp ?86
                        : ?95:
                        :>
                        :>#ifdef USE_TCP_CLIENT
                        :> case TCP_SYNSENT:
                        :>  // puts("<ACTIVE OPEN SYN-RECEIVED>");
                        :>  if(!(hframe.tcp_hdr.flags&TSYN)) break;
                        :>  hframe.tcp_hdr.seq.u++;    // Count remote SYN
                        :>  match_socket.sack.u=hframe.tcp_hdr.seq.u; // +1: Bec. SYN rcvd.
                        :>#endif
                        :>
                        :> case TCP_SYNCON:
                        :> case TCP_EST:
                        :>  if(!(hframe.tcp_hdr.flags&TACK)) break;
co:3779: 90 01 dd       :  mov DPTR,#_hframe+13
co:377c: e0             :  movx A,@DPTR
co:377d: ff             :  mov R7,A
co:377e: 54 10          :  anl A,#16
co:3780: ff             :  mov R7,A
co:3781: 70 03          :  jnz ?96
                        : 
co:3783: 02 3a 2d       :  ljmp ?90
                        : ?96:
                        :>  if(dlen>MAX_RX) dlen=MAX_RX;  // IDIOTA! Clip data in size (don't know if this is safe?)
co:3786: 7c 05          :  mov R4,#5
co:3788: 7d 78          :  mov R5,#120
co:378a: ae 41          :  mov R6,?state_machine_TCP_dlen
co:378c: af 42          :  mov R7,?state_machine_TCP_dlen+1
co:378e: d3             :  setb C
co:378f: ef             :  mov A,R7
co:3790: 9d             :  subb A,R5
co:3791: ee             :  mov A,R6
co:3792: 9c             :  subb A,R4
co:3793: 40 06          :  jc ?98
                        : 
co:3795: 75 41 05       :  mov ?state_machine_TCP_dlen,#5
co:3798: 75 42 78       :  mov ?state_machine_TCP_dlen+1,#120
                        : ?98:
                        :>
                        :>  // Here a small problem is silently ignored: A not acknowled Segment which is restransmitted larger
                        :>  // could contain old data as a part (maybe for TELNET...)
                        :>  // Silently assume all Segments have valid ACK
                        :>
                        :>  if(match_socket.sack.u!=hframe.tcp_hdr.seq.u) return EVENT_TCP_OUTOFBOUNDS; // Ignore-out-of-bounds 
co:379b: 90 01 d4       :  mov DPTR,#_hframe+4
co:379e: 12 34 e6       :  lcall __ld_dptr_r03
co:37a1: 90 00 1a       :  mov DPTR,#_match_socket+16
co:37a4: 12 34 f2       :  lcall __ld_dptr_r47
co:37a7: c3             :  clr C
co:37a8: 12 34 08       :  lcall __cmp_i4
co:37ab: 60 07          :  jz ?100
                        : 
co:37ad: 7e f3          :  mov R6,#243
co:37af: 7f 00          :  mov R7,#0
co:37b1: 02 3a 4a       :  ljmp ?86
                        : ?100:
                        :>
                        :>  match_socket.state=TCP_EST;  // Connection now established
co:37b4: 90 00 0b       :  mov DPTR,#_match_socket+1
co:37b7: 74 02          :  mov A,#2
co:37b9: f0             :  movx @DPTR,A
                        :>
                        :>  match_socket.sack.u+=dlen;
co:37ba: ae 41          :  mov R6,?state_machine_TCP_dlen
co:37bc: af 42          :  mov R7,?state_machine_TCP_dlen+1
co:37be: ab 07          :  mov R3,AR7
co:37c0: aa 06          :  mov R2,AR6
co:37c2: e4             :  clr A
co:37c3: f9             :  mov R1,A
co:37c4: f8             :  mov R0,A
co:37c5: 90 00 1a       :  mov DPTR,#_match_socket+16
co:37c8: 12 34 f2       :  lcall __ld_dptr_r47
co:37cb: 12 35 9e       :  lcall __add_i4
co:37ce: 90 00 1a       :  mov DPTR,#_match_socket+16
co:37d1: 12 34 bc       :  lcall __st_dptr_r47
                        :>#ifdef PHY_ETH
                        :>  Read_Frame_xdata_Phy(rcv_buf,dlen);  // Read Sender's Data, if any as Physical copy
co:37d4: ac 41          :  mov R4,?state_machine_TCP_dlen
co:37d6: ad 42          :  mov R5,?state_machine_TCP_dlen+1
co:37d8: 7e 02          :  mov R6,#((_rcv_buf)>>8)&255
co:37da: 7f 12          :  mov R7,#(_rcv_buf)&255
co:37dc: 12 3c 3d       :  lcall _Read_Frame_xdata_Phy
                        :>#else
                        :>  rcv_buf=Get_Frame_xdata_pointer();  // Why copy, if it is already there...
                        :>#endif
                        :>
                        :>
                        :>  rcv_len=dlen;    // remember size of read data...
co:37df: ae 41          :  mov R6,?state_machine_TCP_dlen
co:37e1: af 42          :  mov R7,?state_machine_TCP_dlen+1
co:37e3: 90 02 10       :  mov DPTR,#_rcv_len
co:37e6: 12 35 40       :  lcall __st_dptr_r67
                        :>
                        :>  // Matching 3 Sockets? -> Clear ALL
                        :>  if(match_socket.buf_outsize3 && hframe.tcp_hdr.ack.u==match_socket.sseq_3){
co:37e9: 90 00 24       :  mov DPTR,#_match_socket+26
co:37ec: 12 35 4c       :  lcall __ld_dptr_r67
co:37ef: ee             :  mov A,R6
co:37f0: 4f             :  orl A,R7
co:37f1: 60 45          :  jz ?102
co:37f3: 90 00 26       :  mov DPTR,#_match_socket+28
co:37f6: 12 34 e6       :  lcall __ld_dptr_r03
co:37f9: 90 01 d8       :  mov DPTR,#_hframe+8
co:37fc: 12 34 f2       :  lcall __ld_dptr_r47
co:37ff: c3             :  clr C
co:3800: 12 34 08       :  lcall __cmp_i4
co:3803: 70 33          :  jnz ?102
                        : 
co:3805: 90 00 2a       :  mov DPTR,#_match_socket+32
co:3808: 12 35 4c       :  lcall __ld_dptr_r67
co:380b: 12 36 34       :  lcall _free_tx_buf
                        :>   //putsl("<M123>");
                        :>   free_tx_buf(match_socket.p_outbuf3);   
                        :>   free_tx_buf(match_socket.p_outbuf2);   
co:380e: 90 00 32       :  mov DPTR,#_match_socket+40
co:3811: 12 35 4c       :  lcall __ld_dptr_r67
co:3814: 12 36 34       :  lcall _free_tx_buf
                        :>   free_tx_buf(match_socket.p_outbuf1);   
co:3817: 90 00 3a       :  mov DPTR,#_match_socket+48
co:381a: 12 35 4c       :  lcall __ld_dptr_r67
co:381d: 12 36 34       :  lcall _free_tx_buf
                        :>   match_socket.buf_outsize3=0;
co:3820: 90 00 24       :  mov DPTR,#_match_socket+26
co:3823: e4             :  clr A
co:3824: f0             :  movx @DPTR,A
co:3825: a3             :  inc DPTR
co:3826: f0             :  movx @DPTR,A
                        :>   match_socket.buf_outsize2=0;
co:3827: 90 00 2c       :  mov DPTR,#_match_socket+34
co:382a: e4             :  clr A
co:382b: f0             :  movx @DPTR,A
co:382c: a3             :  inc DPTR
co:382d: f0             :  movx @DPTR,A
                        :>   match_socket.buf_outsize1=0;
co:382e: 90 00 34       :  mov DPTR,#_match_socket+42
co:3831: e4             :  clr A
co:3832: f0             :  movx @DPTR,A
co:3833: a3             :  inc DPTR
co:3834: f0             :  movx @DPTR,A
                        :>
                        :>  // Matching Sockets 2 and 1: Free 1,2, Shift 3 to 1
                        :>  }else if(match_socket.buf_outsize2 && hframe.tcp_hdr.ack.u==match_socket.sseq_2){
co:3835: 02 39 0f       :  ljmp ?103
                        : ?102:
                        : 
co:3838: 90 00 2c       :  mov DPTR,#_match_socket+34
co:383b: 12 35 4c       :  lcall __ld_dptr_r67
co:383e: ee             :  mov A,R6
co:383f: 4f             :  orl A,R7
co:3840: 60 59          :  jz ?104
co:3842: 90 00 2e       :  mov DPTR,#_match_socket+36
co:3845: 12 34 e6       :  lcall __ld_dptr_r03
co:3848: 90 01 d8       :  mov DPTR,#_hframe+8
co:384b: 12 34 f2       :  lcall __ld_dptr_r47
co:384e: c3             :  clr C
co:384f: 12 34 08       :  lcall __cmp_i4
co:3852: 70 47          :  jnz ?104
                        : 
co:3854: 90 00 32       :  mov DPTR,#_match_socket+40
co:3857: 12 35 4c       :  lcall __ld_dptr_r67
co:385a: 12 36 34       :  lcall _free_tx_buf
                        :>   //putsl("<M12>");
                        :>   free_tx_buf(match_socket.p_outbuf2);   
                        :>   free_tx_buf(match_socket.p_outbuf1);   
co:385d: 90 00 3a       :  mov DPTR,#_match_socket+48
co:3860: 12 35 4c       :  lcall __ld_dptr_r67
co:3863: 12 36 34       :  lcall _free_tx_buf
                        :>
                        :>   match_socket.sseq_1=match_socket.sseq_3;
co:3866: 90 00 26       :  mov DPTR,#_match_socket+28
co:3869: 12 34 f2       :  lcall __ld_dptr_r47
co:386c: 90 00 36       :  mov DPTR,#_match_socket+44
co:386f: 12 34 bc       :  lcall __st_dptr_r47
                        :>   match_socket.p_outbuf1=match_socket.p_outbuf3;
co:3872: 90 00 2a       :  mov DPTR,#_match_socket+32
co:3875: 12 35 4c       :  lcall __ld_dptr_r67
co:3878: 90 00 3a       :  mov DPTR,#_match_socket+48
co:387b: 12 35 40       :  lcall __st_dptr_r67
                        :>   match_socket.buf_outsize1=match_socket.buf_outsize3;
co:387e: 90 00 24       :  mov DPTR,#_match_socket+26
co:3881: 12 35 4c       :  lcall __ld_dptr_r67
co:3884: 90 00 34       :  mov DPTR,#_match_socket+42
co:3887: 12 35 40       :  lcall __st_dptr_r67
                        :>   
                        :>   match_socket.buf_outsize2=0;
co:388a: 90 00 2c       :  mov DPTR,#_match_socket+34
co:388d: e4             :  clr A
co:388e: f0             :  movx @DPTR,A
co:388f: a3             :  inc DPTR
co:3890: f0             :  movx @DPTR,A
                        :>   match_socket.buf_outsize3=0;
co:3891: 90 00 24       :  mov DPTR,#_match_socket+26
co:3894: e4             :  clr A
co:3895: f0             :  movx @DPTR,A
co:3896: a3             :  inc DPTR
co:3897: f0             :  movx @DPTR,A
                        :>   
                        :>  // Matching Sockets 1 Free 1, Shift 2 to 1, 3 to 2
                        :>  }else if(match_socket.buf_outsize1 && hframe.tcp_hdr.ack.u==match_socket.sseq_1){
co:3898: 02 39 0f       :  ljmp ?105
                        : ?104:
                        : 
co:389b: 90 00 34       :  mov DPTR,#_match_socket+42
co:389e: 12 35 4c       :  lcall __ld_dptr_r67
co:38a1: ee             :  mov A,R6
co:38a2: 4f             :  orl A,R7
co:38a3: 60 6a          :  jz ?106
co:38a5: 90 00 36       :  mov DPTR,#_match_socket+44
co:38a8: 12 34 e6       :  lcall __ld_dptr_r03
co:38ab: 90 01 d8       :  mov DPTR,#_hframe+8
co:38ae: 12 34 f2       :  lcall __ld_dptr_r47
co:38b1: c3             :  clr C
co:38b2: 12 34 08       :  lcall __cmp_i4
co:38b5: 70 58          :  jnz ?106
                        : 
co:38b7: 90 00 3a       :  mov DPTR,#_match_socket+48
co:38ba: 12 35 4c       :  lcall __ld_dptr_r67
co:38bd: 12 36 34       :  lcall _free_tx_buf
                        :>   //putsl("<M1>");
                        :>   free_tx_buf(match_socket.p_outbuf1);   
                        :>
                        :>   match_socket.sseq_1=match_socket.sseq_2;
co:38c0: 90 00 2e       :  mov DPTR,#_match_socket+36
co:38c3: 12 34 f2       :  lcall __ld_dptr_r47
co:38c6: 90 00 36       :  mov DPTR,#_match_socket+44
co:38c9: 12 34 bc       :  lcall __st_dptr_r47
                        :>   match_socket.p_outbuf1=match_socket.p_outbuf2;
co:38cc: 90 00 32       :  mov DPTR,#_match_socket+40
co:38cf: 12 35 4c       :  lcall __ld_dptr_r67
co:38d2: 90 00 3a       :  mov DPTR,#_match_socket+48
co:38d5: 12 35 40       :  lcall __st_dptr_r67
                        :>   match_socket.buf_outsize1=match_socket.buf_outsize2;
co:38d8: 90 00 2c       :  mov DPTR,#_match_socket+34
co:38db: 12 35 4c       :  lcall __ld_dptr_r67
co:38de: 90 00 34       :  mov DPTR,#_match_socket+42
co:38e1: 12 35 40       :  lcall __st_dptr_r67
                        :>
                        :>   match_socket.sseq_2=match_socket.sseq_3;
co:38e4: 90 00 26       :  mov DPTR,#_match_socket+28
co:38e7: 12 34 f2       :  lcall __ld_dptr_r47
co:38ea: 90 00 2e       :  mov DPTR,#_match_socket+36
co:38ed: 12 34 bc       :  lcall __st_dptr_r47
                        :>   match_socket.p_outbuf2=match_socket.p_outbuf3;
co:38f0: 90 00 2a       :  mov DPTR,#_match_socket+32
co:38f3: 12 35 4c       :  lcall __ld_dptr_r67
co:38f6: 90 00 32       :  mov DPTR,#_match_socket+40
co:38f9: 12 35 40       :  lcall __st_dptr_r67
                        :>   match_socket.buf_outsize2=match_socket.buf_outsize3;
co:38fc: 90 00 24       :  mov DPTR,#_match_socket+26
co:38ff: 12 35 4c       :  lcall __ld_dptr_r67
co:3902: 90 00 2c       :  mov DPTR,#_match_socket+34
co:3905: 12 35 40       :  lcall __st_dptr_r67
                        :>   
                        :>   match_socket.buf_outsize3=0;
co:3908: 90 00 24       :  mov DPTR,#_match_socket+26
co:390b: e4             :  clr A
co:390c: f0             :  movx @DPTR,A
co:390d: a3             :  inc DPTR
co:390e: f0             :  movx @DPTR,A
                        :>   
                        :>  }
                        : ?106:
                        : ?105:
                        : ?103:
                        :>
                        :>
                        :>  // Frame does not contain a TFIN so simply acknowledge it, if data od SYN received
                        :>  if(!(hframe.tcp_hdr.flags&TFIN)){
co:390f: 90 01 dd       :  mov DPTR,#_hframe+13
co:3912: e0             :  movx A,@DPTR
co:3913: ff             :  mov R7,A
co:3914: 54 01          :  anl A,#1
co:3916: ff             :  mov R7,A
co:3917: 70 20          :  jnz ?108
                        : 
co:3919: e5 41          :  mov A,?state_machine_TCP_dlen
co:391b: 45 42          :  orl A,?state_machine_TCP_dlen+1
co:391d: 70 0d          :  jnz ?112
co:391f: 90 01 dd       :  mov DPTR,#_hframe+13
co:3922: e0             :  movx A,@DPTR
co:3923: ff             :  mov R7,A
co:3924: 54 02          :  anl A,#2
co:3926: ff             :  mov R7,A
co:3927: 70 03          :  jnz ?_53
co:3929: 02 39 7e       :  ljmp ?109
                        : ?_53:
                        : ?112:
                        :>   if(dlen || (hframe.tcp_hdr.flags&TSYN)) send_match_ok_TCP(0,0,TACK); // Frame OK: Acknowledge immed
co:392c: 7b 10          :  mov R3,#16
co:392e: e4             :  clr A
co:392f: fc             :  mov R4,A
co:3930: fd             :  mov R5,A
co:3931: e4             :  clr A
co:3932: fe             :  mov R6,A
co:3933: ff             :  mov R7,A
co:3934: 12 41 f1       :  lcall _send_match_ok_TCP
                        :>  }else if(hframe.tcp_hdr.flags&TFIN){ // Come to here if RST and/or received
co:3937: 80 45          :  sjmp ?109
                        : ?108:
                        : 
co:3939: 90 01 dd       :  mov DPTR,#_hframe+13
co:393c: e0             :  movx A,@DPTR
co:393d: ff             :  mov R7,A
co:393e: 54 01          :  anl A,#1
co:3940: ff             :  mov R7,A
co:3941: 60 3b          :  jz ?113
                        : 
co:3943: e4             :  clr A
co:3944: f8             :  mov R0,A
co:3945: f9             :  mov R1,A
co:3946: fa             :  mov R2,A
co:3947: 7b 01          :  mov R3,#1
co:3949: 90 00 1a       :  mov DPTR,#_match_socket+16
co:394c: 12 34 f2       :  lcall __ld_dptr_r47
co:394f: 12 35 9e       :  lcall __add_i4
co:3952: 90 00 1a       :  mov DPTR,#_match_socket+16
co:3955: 12 34 bc       :  lcall __st_dptr_r47
                        :>   match_socket.sack.u++;  // Count remote FIN
                        :>   send_match_ok_TCP(0,0,TACK+TFIN+TPUSH); // Acknowledge + FIN
co:3958: 7b 19          :  mov R3,#25
co:395a: e4             :  clr A
co:395b: fc             :  mov R4,A
co:395c: fd             :  mov R5,A
co:395d: e4             :  clr A
co:395e: fe             :  mov R6,A
co:395f: ff             :  mov R7,A
co:3960: 12 41 f1       :  lcall _send_match_ok_TCP
                        :>   match_socket.sseq.u++;  // Count our FIN after sending!...
co:3963: e4             :  clr A
co:3964: f8             :  mov R0,A
co:3965: f9             :  mov R1,A
co:3966: fa             :  mov R2,A
co:3967: 7b 01          :  mov R3,#1
co:3969: 90 00 1e       :  mov DPTR,#_match_socket+20
co:396c: 12 34 f2       :  lcall __ld_dptr_r47
co:396f: 12 35 9e       :  lcall __add_i4
co:3972: 90 00 1e       :  mov DPTR,#_match_socket+20
co:3975: 12 34 bc       :  lcall __st_dptr_r47
                        :>   match_socket.state=TCP_FINCON; // FIN Confirmed
co:3978: 90 00 0b       :  mov DPTR,#_match_socket+1
co:397b: 74 04          :  mov A,#4
co:397d: f0             :  movx @DPTR,A
                        :>  }  
                        : ?113:
                        : ?109:
                        :>
                        :>  // Only if nothing available reset retry_counter...
                        :>  if(!match_socket.buf_outsize1) match_socket.retry_cnt=0;
co:397e: 90 00 34       :  mov DPTR,#_match_socket+42
co:3981: 12 35 4c       :  lcall __ld_dptr_r67
co:3984: ee             :  mov A,R6
co:3985: 4f             :  orl A,R7
co:3986: 70 05          :  jnz ?115
                        : 
co:3988: 90 00 22       :  mov DPTR,#_match_socket+24
co:398b: e4             :  clr A
co:398c: f0             :  movx @DPTR,A
                        : ?115:
                        :>  return EVENT_TCP_DATARECEIVED;
co:398d: 7e f5          :  mov R6,#245
co:398f: 7f 00          :  mov R7,#0
co:3991: 02 3a 4a       :  ljmp ?86
                        : ?117:
                        :>
                        :> case TCP_FINSENT:
                        :>  //puts("<FINSENT>");
                        :>  if(!(hframe.tcp_hdr.flags&TACK)) break;
co:3994: 90 01 dd       :  mov DPTR,#_hframe+13
co:3997: e0             :  movx A,@DPTR
co:3998: ff             :  mov R7,A
co:3999: 54 10          :  anl A,#16
co:399b: ff             :  mov R7,A
co:399c: 70 03          :  jnz ?118
                        : 
co:399e: 02 3a 2d       :  ljmp ?90
                        : ?118:
                        :>  // printf("Flags: %u\n",hframe.tcp_hdr.flags);
                        :>  // printf("<<M:%ld H:%lx >>",match_socket.sack.u,hframe.tcp_hdr.seq.u);
                        :>  if(match_socket.sack.u!=hframe.tcp_hdr.seq.u) return EVENT_TCP_OUTOFBOUNDS; // Ignore-out-of-bounds 
co:39a1: 90 01 d4       :  mov DPTR,#_hframe+4
co:39a4: 12 34 e6       :  lcall __ld_dptr_r03
co:39a7: 90 00 1a       :  mov DPTR,#_match_socket+16
co:39aa: 12 34 f2       :  lcall __ld_dptr_r47
co:39ad: c3             :  clr C
co:39ae: 12 34 08       :  lcall __cmp_i4
co:39b1: 60 07          :  jz ?120
                        : 
co:39b3: 7e f3          :  mov R6,#243
co:39b5: 7f 00          :  mov R7,#0
co:39b7: 02 3a 4a       :  ljmp ?86
                        : ?120:
                        :>  //puts("<Wait3LASTACK>");
                        :>  if(hframe.tcp_hdr.flags&TFIN){    // Fin accepted by Remote!
co:39ba: 90 01 dd       :  mov DPTR,#_hframe+13
co:39bd: e0             :  movx A,@DPTR
co:39be: ff             :  mov R7,A
co:39bf: 54 01          :  anl A,#1
co:39c1: ff             :  mov R7,A
co:39c2: 60 28          :  jz ?122
                        : 
co:39c4: e4             :  clr A
co:39c5: f8             :  mov R0,A
co:39c6: f9             :  mov R1,A
co:39c7: fa             :  mov R2,A
co:39c8: 7b 01          :  mov R3,#1
co:39ca: 90 00 1a       :  mov DPTR,#_match_socket+16
co:39cd: 12 34 f2       :  lcall __ld_dptr_r47
co:39d0: 12 35 9e       :  lcall __add_i4
co:39d3: 90 00 1a       :  mov DPTR,#_match_socket+16
co:39d6: 12 34 bc       :  lcall __st_dptr_r47
                        :>   match_socket.sack.u++;    // Count remote FIN
                        :>   send_match_ok_TCP(0,0,TACK);   // Frame OK: Acknowledge immediatelly!
co:39d9: 7b 10          :  mov R3,#16
co:39db: e4             :  clr A
co:39dc: fc             :  mov R4,A
co:39dd: fd             :  mov R5,A
co:39de: e4             :  clr A
co:39df: fe             :  mov R6,A
co:39e0: ff             :  mov R7,A
co:39e1: 12 41 f1       :  lcall _send_match_ok_TCP
                        :>   free_match_socket(); // Free Buffers if allocated... 
co:39e4: 12 3b ee       :  lcall _free_match_socket
                        :>   match_socket.state=TCP_CLOSED;  // Connection ends NOW
co:39e7: 90 00 0b       :  mov DPTR,#_match_socket+1
co:39ea: e4             :  clr A
co:39eb: f0             :  movx @DPTR,A
                        :>   //puts("<FINAL ACK SENT CLOSED>");
                        :>  }
                        : ?122:
                        :>  match_socket.retry_cnt=0;
co:39ec: 90 00 22       :  mov DPTR,#_match_socket+24
co:39ef: e4             :  clr A
co:39f0: f0             :  movx @DPTR,A
                        :>  return EVENT_TCP_WAITLASTACK;
co:39f1: 7e fb          :  mov R6,#251
co:39f3: 7f 00          :  mov R7,#0
co:39f5: 02 3a 4a       :  ljmp ?86
                        : ?124:
                        :>    
                        :> case TCP_FINCON: // Accept one last ACK
                        :>  if(!(hframe.tcp_hdr.flags&TACK)) break;
co:39f8: 90 01 dd       :  mov DPTR,#_hframe+13
co:39fb: e0             :  movx A,@DPTR
co:39fc: ff             :  mov R7,A
co:39fd: 54 10          :  anl A,#16
co:39ff: ff             :  mov R7,A
                        : 
co:3a00: 60 2b          :  jz ?90
                        :>  if(match_socket.sack.u!=hframe.tcp_hdr.seq.u) return EVENT_TCP_OUTOFBOUNDS; // Ignore-out-of-bounds 
co:3a02: 90 01 d4       :  mov DPTR,#_hframe+4
co:3a05: 12 34 e6       :  lcall __ld_dptr_r03
co:3a08: 90 00 1a       :  mov DPTR,#_match_socket+16
co:3a0b: 12 34 f2       :  lcall __ld_dptr_r47
co:3a0e: c3             :  clr C
co:3a0f: 12 34 08       :  lcall __cmp_i4
co:3a12: 60 06          :  jz ?127
                        : 
co:3a14: 7e f3          :  mov R6,#243
co:3a16: 7f 00          :  mov R7,#0
co:3a18: 80 30          :  sjmp ?86
                        : ?127:
                        :> 
                        :>  match_socket.state=TCP_CLOSED;  // Connection ends NOW
co:3a1a: 90 00 0b       :  mov DPTR,#_match_socket+1
co:3a1d: e4             :  clr A
co:3a1e: f0             :  movx @DPTR,A
                        :>  free_match_socket(); // Free Buffers if allocated... 
co:3a1f: 12 3b ee       :  lcall _free_match_socket
                        :>  // puts("<LAST FIN ACKNOWLEDGED>");
                        :>  match_socket.retry_cnt=0;
co:3a22: 90 00 22       :  mov DPTR,#_match_socket+24
co:3a25: e4             :  clr A
co:3a26: f0             :  movx @DPTR,A
                        :>  return EVENT_TCP_CLOSED;      
co:3a27: 7e fc          :  mov R6,#252
co:3a29: 7f 00          :  mov R7,#0
co:3a2b: 80 1d          :  sjmp ?86
                        : ?89:
                        : ?90:
                        :> }
                        :>
                        :> free_match_socket(); // Free Buffers if allocated... 
co:3a2d: 12 3b ee       :  lcall _free_match_socket
                        :> match_socket.state=TCP_CLOSED;
co:3a30: 90 00 0b       :  mov DPTR,#_match_socket+1
co:3a33: e4             :  clr A
co:3a34: f0             :  movx @DPTR,A
                        :>#ifdef PHY_ETH
                        :> send_incomming_reset_TCP(dlen,&remote_mac,remote_ip.ipl);  // Denie further request!
co:3a35: 90 07 f6       :  mov DPTR,#_remote_ip
co:3a38: 12 34 e6       :  lcall __ld_dptr_r03
co:3a3b: 7c 02          :  mov R4,#((_remote_mac)>>8)&255
co:3a3d: 7d 0a          :  mov R5,#(_remote_mac)&255
co:3a3f: ae 41          :  mov R6,?state_machine_TCP_dlen
co:3a41: af 42          :  mov R7,?state_machine_TCP_dlen+1
co:3a43: 12 3e ec       :  lcall _send_incomming_reset_TCP
                        :>#else
                        :> send_incomming_reset_TCP(dlen,remote_ip.ipl);  // Denie further request!
                        :>#endif
                        :>
                        :> return EVENT_TCP_ILLEGALFRAME; // Denie illegal frames;
co:3a46: 7e f8          :  mov R6,#248
co:3a48: 7f 00          :  mov R7,#0
                        : ?86:
co:3a4a: 22             :  ret
                        : ?i129: ; void (*code [5])()
co:3a4b: 36 eb          :  .dc.w ?92
co:3a4d: 37 79          :  .dc.w ?95
co:3a4f: 37 79          :  .dc.w ?95
co:3a51: 39 94          :  .dc.w ?117
co:3a53: 39 f8          :  .dc.w ?124
                        : ; end of function state_machine_TCP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .export _final_timeout_socket ; unsigned int final_timeout_socket(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __final_timeout_socket
                        : _final_timeout_socket: ; unsigned int final_timeout_socket(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uint final_timeout_socket();
                        :>*
                        :>* Socket has definitely timed out. Free it for other users...
                        :>**********************************************************************************/
                        :>uint final_timeout_socket(void){
co:3ec1: 90 00 0a       :  mov DPTR,#_match_socket
co:3ec4: e0             :  movx A,@DPTR
co:3ec5: ff             :  mov R7,A
co:3ec6: bf 02 19       :  cjne R7,#2,?131
                        :>
                        :> //printf("TIMEOUT match_socket_type: %u\n",match_socket.socket_type);
                        :> if(match_socket.socket_type==SOCKET_TCP){
co:3ec9: 7b 04          :  mov R3,#4
co:3ecb: e4             :  clr A
co:3ecc: fc             :  mov R4,A
co:3ecd: fd             :  mov R5,A
co:3ece: e4             :  clr A
co:3ecf: fe             :  mov R6,A
co:3ed0: ff             :  mov R7,A
co:3ed1: 12 41 f1       :  lcall _send_match_ok_TCP
                        :>#ifdef USE_TCP_CLIENT
                        :>     if(match_socket.state<ARPSENT) 
                        :>#endif
                        :>  send_match_ok_TCP(0,0,TRST); // Reset this socket!
                        :>  free_match_socket(); // Free Buffers if allocated... 
co:3ed4: 12 3b ee       :  lcall _free_match_socket
                        :>  //puts("<TIMEOUT RESET>");
                        :>  match_socket.state=TCP_CLOSED;  // ==0 (for UDP as well)
co:3ed7: 90 00 0b       :  mov DPTR,#_match_socket+1
co:3eda: e4             :  clr A
co:3edb: f0             :  movx @DPTR,A
                        :>  return EVENT_TCP_TIMEOUT;
co:3edc: 7e fa          :  mov R6,#250
co:3ede: 7f 00          :  mov R7,#0
co:3ee0: 80 09          :  sjmp ?130
                        : ?131:
                        :> }
                        :> match_socket.state=0;  // ==0 (for UDP as well, but no action required)
co:3ee2: 90 00 0b       :  mov DPTR,#_match_socket+1
co:3ee5: e4             :  clr A
co:3ee6: f0             :  movx @DPTR,A
                        :> return EVENT_SOCKET_TIMEOUT;
co:3ee7: 7e d0          :  mov R6,#208
co:3ee9: 7f 00          :  mov R7,#0
                        : ?130:
co:3eeb: 22             :  ret
                        : ; end of function final_timeout_socket
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _retransmit_socket ; unsigned int retransmit_socket(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __retransmit_socket
                        : _retransmit_socket: ; unsigned int retransmit_socket(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uint retransmit_socket();
                        :>*
                        :>* Socket requires a retransmition
                        :>**********************************************************************************/
                        :>uint retransmit_socket(void){
co:3f78: 90 00 0a       :  mov DPTR,#_match_socket
co:3f7b: e0             :  movx A,@DPTR
co:3f7c: ff             :  mov R7,A
co:3f7d: bf 02 02       :  cjne R7,#2,?_63
co:3f80: 80 03          :  sjmp ?_64
                        : ?_63:
co:3f82: 02 40 43       :  ljmp ?134
                        : ?_64:
                        :> unsigned long hseq;
                        :>
                        :> // printf(" >>--RE-TX:%u>>",match_socket.sremote_port);
                        :>
                        :> if(match_socket.socket_type==SOCKET_TCP){
co:3f85: 90 00 0b       :  mov DPTR,#_match_socket+1
co:3f88: e0             :  movx A,@DPTR
co:3f89: fd             :  mov R5,A
co:3f8a: 7f 01          :  mov R7,#1
co:3f8c: c3             :  clr C
co:3f8d: ed             :  mov A,R5
co:3f8e: 9f             :  subb A,R7
co:3f8f: 50 03          :  jnc ?_65
co:3f91: 02 40 73       :  ljmp ?135
                        : ?_65:
co:3f94: 7f 04          :  mov R7,#4
co:3f96: d3             :  setb C
co:3f97: ed             :  mov A,R5
co:3f98: 9f             :  subb A,R7
co:3f99: 40 03          :  jc ?_66
co:3f9b: 02 40 73       :  ljmp ?135
                        : ?_66:
co:3f9e: 90 40 76       :  mov DPTR,#?i144-2
co:3fa1: ed             :  mov A,R5
co:3fa2: 2d             :  add A,R5
co:3fa3: 50 02          :  jnc ?_67
co:3fa5: 05 83          :  inc DPH
                        : ?_67:
co:3fa7: 25 82          :  add A,DPL
co:3fa9: f5 82          :  mov DPL,A
co:3fab: 50 02          :  jnc ?_68
co:3fad: 05 83          :  inc DPH
                        : ?_68:
co:3faf: 74 01          :  mov A,#1
co:3fb1: 93             :  movc A,@A+DPTR
co:3fb2: c0 e0          :  push ACC
co:3fb4: e4             :  clr A
co:3fb5: 93             :  movc A,@A+DPTR
co:3fb6: c0 e0          :  push ACC
co:3fb8: 22             :  ret
                        :>  switch(match_socket.state){
                        : ?139:
                        :>  case TCP_SYNCON:    // Timeout after SYN-confirmed->Transmit Confirmation again
                        :>   send_match_ok_TCP(0,0,TSYN+TACK); // Transmit Again
co:3fb9: 7b 12          :  mov R3,#18
co:3fbb: e4             :  clr A
co:3fbc: fc             :  mov R4,A
co:3fbd: fd             :  mov R5,A
co:3fbe: e4             :  clr A
co:3fbf: fe             :  mov R6,A
co:3fc0: ff             :  mov R7,A
co:3fc1: 12 41 f1       :  lcall _send_match_ok_TCP
                        :>   // puts("<TCP RETRANSMIT TSYN+TACK>");
                        :>   return EVENT_TCP_RETRANS;
co:3fc4: 7e f1          :  mov R6,#241
co:3fc6: 7f 00          :  mov R7,#0
co:3fc8: 02 40 77       :  ljmp ?133
                        : ?140:
                        :>
                        :>  case TCP_EST:     // Timeout in an established Connection
                        :>
                        :>   if(match_socket.buf_outsize1){  // Something un-acknowledged?
co:3fcb: 90 00 34       :  mov DPTR,#_match_socket+42
co:3fce: 12 35 4c       :  lcall __ld_dptr_r67
co:3fd1: ee             :  mov A,R6
co:3fd2: 4f             :  orl A,R7
co:3fd3: 60 51          :  jz ?141
                        :  ; variable 'hseq' allocated as 'auto'
                        : 
co:3fd5: 90 00 1e       :  mov DPTR,#_match_socket+20
co:3fd8: e0             :  movx A,@DPTR
co:3fd9: f5 36          :  mov ?retransmit_socket_hseq,A
co:3fdb: a3             :  inc DPTR
co:3fdc: e0             :  movx A,@DPTR
co:3fdd: f5 37          :  mov ?retransmit_socket_hseq+1,A
co:3fdf: a3             :  inc DPTR
co:3fe0: e0             :  movx A,@DPTR
co:3fe1: f5 38          :  mov ?retransmit_socket_hseq+2,A
co:3fe3: a3             :  inc DPTR
co:3fe4: e0             :  movx A,@DPTR
co:3fe5: f5 39          :  mov ?retransmit_socket_hseq+3,A
                        :>    //puts("<TCP RETRANSMIT EST>");
                        :>    // Seq. represents the sent data, so for resend subtract the block from seq, afterwards ad it...
                        :>    hseq=match_socket.sseq.u; // Save current Sequ (Pos.)
                        :>    // Rewind to Pos. before BUF1 was sent
                        :>
                        :>    match_socket.sseq.u=match_socket.sseq_1-match_socket.buf_outsize1; // 32 Bit operation - This must
co:3fe7: 90 00 34       :  mov DPTR,#_match_socket+42
co:3fea: 12 35 4c       :  lcall __ld_dptr_r67
co:3fed: ab 07          :  mov R3,AR7
co:3fef: aa 06          :  mov R2,AR6
co:3ff1: e4             :  clr A
co:3ff2: f9             :  mov R1,A
co:3ff3: f8             :  mov R0,A
co:3ff4: 90 00 36       :  mov DPTR,#_match_socket+44
co:3ff7: 12 34 f2       :  lcall __ld_dptr_r47
co:3ffa: 12 33 87       :  lcall __sub_i4
co:3ffd: 90 00 1e       :  mov DPTR,#_match_socket+20
co:4000: 12 34 bc       :  lcall __st_dptr_r47
                        :>    send_match_ok_TCP(match_socket.p_outbuf1,match_socket.buf_outsize1,TACK+TPUSH);
co:4003: 7b 18          :  mov R3,#24
co:4005: 90 00 34       :  mov DPTR,#_match_socket+42
co:4008: 12 35 46       :  lcall __ld_dptr_r45
co:400b: 90 00 3a       :  mov DPTR,#_match_socket+48
co:400e: 12 35 4c       :  lcall __ld_dptr_r67
co:4011: 12 41 f1       :  lcall _send_match_ok_TCP
                        :>    match_socket.sseq.u=hseq;  // Restore old Pointer
co:4014: 74 36          :  mov A,#?retransmit_socket_hseq
co:4016: 12 33 44       :  lcall __ld_a_r47
co:4019: 90 00 1e       :  mov DPTR,#_match_socket+20
co:401c: 12 34 bc       :  lcall __st_dptr_r47
                        :>    return EVENT_TCP_RETRANS;
co:401f: 7e f1          :  mov R6,#241
co:4021: 7f 00          :  mov R7,#0
co:4023: 02 40 77       :  ljmp ?133
                        : ?141:
                        :>   }
                        :>
                        :>   // For an active socket, send *live signal'
                        :>#ifdef USE_TCP_CLIENT
                        :>   if(match_socket.tcp_client_flag){
                        :>        send_match_ok_TCP(0,0,TACK+TPUSH);
                        :>putsl("<IR>");
                        :>   }
                        :>#endif
                        :>
                        :>   // puts("<TCP RT IDLE IDLE>"); 
                        :>   // Stack is idle: All ok
                        :>   match_socket.timer=TCP_IDLE_RETRIES;  // Socket OK, LONG TIMEOUT!!!
co:4026: 90 00 23       :  mov DPTR,#_match_socket+25
co:4029: 74 28          :  mov A,#40
co:402b: f0             :  movx @DPTR,A
                        :>
                        :>   return 0;
co:402c: e4             :  clr A
co:402d: fe             :  mov R6,A
co:402e: ff             :  mov R7,A
co:402f: 02 40 77       :  ljmp ?133
                        : ?143:
                        :>
                        :>  case TCP_FINCON:
                        :>  case TCP_FINSENT:
                        :>   send_match_ok_TCP(0,0,TFIN+TACK+TPUSH); // Transmit, without any data after FIN_CON...
co:4032: 7b 19          :  mov R3,#25
co:4034: e4             :  clr A
co:4035: fc             :  mov R4,A
co:4036: fd             :  mov R5,A
co:4037: e4             :  clr A
co:4038: fe             :  mov R6,A
co:4039: ff             :  mov R7,A
co:403a: 12 41 f1       :  lcall _send_match_ok_TCP
                        :>   // puts("<TCP FIN RETRANSMIT>");
                        :>   return EVENT_TCP_RETRANS;
co:403d: 7e f1          :  mov R6,#241
co:403f: 7f 00          :  mov R7,#0
co:4041: 80 34          :  sjmp ?133
                        :>   
                        :>#ifdef USE_TCP_CLIENT
                        :>#ifdef PHY_ETH
                        :>  case ARPSENT:
                        :>   send_request_ARP(match_socket.sremote_ip);
                        :>   // puts("<(TCP) ARP RETRANSMIT>");
                        :>   return EVENT_TCP_RETRANS;
                        :>
                        :>  case ARPREC:
                        :>   // puts("<(TCP) ARP-REQUEST RECEIVED!!!>");
                        :>
                        :>   // Ports already setup!
                        :>   match_socket.sseq.w.h_word=net_service_cnt;   // Time ascending...
                        :>   match_socket.sseq.w.l_word=0;    // Our relative Pointer (for HTTP, -1 due to SYNC)
                        :>   match_socket.state=TCP_SYNSENT;  // SYN confirmed with SYN+ACK
                        :>#endif // PHY_ETH
                        :>
                        :>  case TCP_SYNSENT:
                        :>   send_match_ok_TCP(0,0,TSYN); // Initiate Connection with a SYN
                        :>   // puts("<ACTIVE SYN SENT>");
                        :>   return 0; // Only 1 Try, No Retransmition!
                        :>#endif   
                        :>  }
                        :> }
                        : ?134:
                        :>
                        :>#ifdef USE_UDP_CLIENT
                        :>#ifdef PHY_ETH
                        :>     else if(match_socket.socket_type==SOCKET_UDP){
co:4043: 90 00 0a       :  mov DPTR,#_match_socket
co:4046: e0             :  movx A,@DPTR
co:4047: ff             :  mov R7,A
co:4048: bf 01 28       :  cjne R7,#1,?145
                        : 
co:404b: 90 00 0b       :  mov DPTR,#_match_socket+1
co:404e: e0             :  movx A,@DPTR
co:404f: ff             :  mov R7,A
co:4050: 64 06          :  xrl A,#6
                        :>         switch(match_socket.state){
co:4052: 70 0f          :  jnz ?147
                        :>        case ARPSENT:
                        :>            send_request_ARP(match_socket.sremote_ip);
co:4054: 90 00 12       :  mov DPTR,#_match_socket+8
co:4057: 12 34 f2       :  lcall __ld_dptr_r47
co:405a: 12 3d 05       :  lcall _send_request_ARP
                        :>            // puts("<(UDP) ARP RETRANSMIT>");
                        :>            return EVENT_UDP_ARPRETRANS;
co:405d: 7e e3          :  mov R6,#227
co:405f: 7f 00          :  mov R7,#0
co:4061: 80 14          :  sjmp ?133
                        : ?147:
                        :>
                        :>        default:
                        :>            // puts("<(UDP) TIMEOUT with ARP-REQUEST RECEIVED!!!>");
                        :>
                        :>            match_socket.retry_cnt=0;                   // MUST be UDP_EST ( == ARPREC) Never close an
co:4063: 90 00 22       :  mov DPTR,#_match_socket+24
co:4066: e4             :  clr A
co:4067: f0             :  movx @DPTR,A
                        :>            match_socket.timer=UDP_IDLE_RETRIES;        // Socket OK, LONG TIMEOUT!!! No change in sta
co:4068: 90 00 23       :  mov DPTR,#_match_socket+25
co:406b: 74 28          :  mov A,#40
co:406d: f0             :  movx @DPTR,A
                        :>            return 0;
co:406e: e4             :  clr A
co:406f: fe             :  mov R6,A
co:4070: ff             :  mov R7,A
co:4071: 80 04          :  sjmp ?133
                        : ?145:
                        : ?135:
                        :>         }
                        :>    }
                        :>#endif
                        :>#endif
                        :>
                        :>
                        :> return EVENT_SOCKET_RETRANS;
co:4073: 7e d1          :  mov R6,#209
co:4075: 7f 00          :  mov R7,#0
                        : ?133:
co:4077: 22             :  ret
                        : ?i144: ; void (*code [4])()
co:4078: 3f b9          :  .dc.w ?139
co:407a: 3f cb          :  .dc.w ?140
co:407c: 40 32          :  .dc.w ?143
co:407e: 40 32          :  .dc.w ?143
                        : ; end of function retransmit_socket
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:4 bytes
                        : 
                        :  .export _periodical_socket ; unsigned int periodical_socket(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __periodical_socket
                        : _periodical_socket: ; unsigned int periodical_socket(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uint periodical_socket();
                        :>*
                        :>* Watch non-0-state sockets periodically every 0.5 secs...
                        :>**********************************************************************************/
                        :>uint periodical_socket(void){
co:4080: 90 00 23       :  mov DPTR,#_match_socket+25
co:4083: e0             :  movx A,@DPTR
co:4084: ff             :  mov R7,A
co:4085: 1f             :  dec R7
                        :  ; variable 'h' assigned to register 'R7'
                        :> uchar h;
                        :> // First decrement sub-timer. If no 0: No Action required
                        :>
                        :> h=match_socket.timer-1;
                        :> if(h){
co:4086: ef             :  mov A,R7
co:4087: 60 0a          :  jz ?152
                        : 
co:4089: 90 00 23       :  mov DPTR,#_match_socket+25
co:408c: ef             :  mov A,R7
co:408d: f0             :  movx @DPTR,A
                        :>  match_socket.timer=h;
                        :>  return 0;
co:408e: e4             :  clr A
co:408f: fe             :  mov R6,A
co:4090: ff             :  mov R7,A
co:4091: 80 23          :  sjmp ?151
                        : ?152:
                        :> }
                        :>
                        :>
                        :> match_socket.timer=BASIC_RETRY_TIMER;
co:4093: 90 00 23       :  mov DPTR,#_match_socket+25
co:4096: 74 06          :  mov A,#6
co:4098: f0             :  movx @DPTR,A
                        :> h=match_socket.retry_cnt+1;
co:4099: 90 00 22       :  mov DPTR,#_match_socket+24
co:409c: e0             :  movx A,@DPTR
co:409d: ff             :  mov R7,A
co:409e: 0f             :  inc R7
                        :  ; variable 'h' allocated as 'auto'
co:409f: 8f 36          :  mov ?i156,R7
                        :> if(h==MAX_RETRIES){
co:40a1: 74 04          :  mov A,#4
co:40a3: 65 36          :  xrl A,?i156
co:40a5: 70 05          :  jnz ?154
                        : 
co:40a7: 12 3e c1       :  lcall _final_timeout_socket
co:40aa: 80 0a          :  sjmp ?151
                        : ?154:
                        :>  return final_timeout_socket();
                        :> }else{
co:40ac: af 36          :  mov R7,?i156
co:40ae: 90 00 22       :  mov DPTR,#_match_socket+24
co:40b1: ef             :  mov A,R7
co:40b2: f0             :  movx @DPTR,A
                        :>  match_socket.retry_cnt=h; // Retry again...
                        :>  return retransmit_socket();
co:40b3: 12 3f 78       :  lcall _retransmit_socket
                        : ?151:
co:40b6: 22             :  ret
                        : ; end of function periodical_socket
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:1 bytes
                        : 
                        :  .export _process_TCP ; unsigned int process_TCP(unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __process_TCP
                        : _process_TCP: ; unsigned int process_TCP(unsigned int)
                        :  ; parameter 'dlen' in 'RW67' moved and assigned to local '?process_TCP_dlen'
co:4399: 8e 3c          :  mov ?process_TCP_dlen,R6
co:439b: 8f 3d          :  mov ?process_TCP_dlen+1,R7
                        :> }
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* void process_TCP(void)
                        :>* 
                        :>* 3.rd-Level-Multiplexer
                        :>* A note for reading UDP-Datagrams: if Size is odd, last byte is in the
                        :>* HBYTE of the last Read_Frame_word_Phy()...
                        :>* Usually a TCP-frame will never come as broadcast, so treat each as more
                        :>* important than other types...
                        :>**********************************************************************************/
                        :>uint process_TCP(uint dlen){
co:439d: 7c 00          :  mov R4,#0
co:439f: 7d 14          :  mov R5,#20
co:43a1: 7e 01          :  mov R6,#((_hframe)>>8)&255
co:43a3: 7f d0          :  mov R7,#(_hframe)&255
co:43a5: 12 3c 3d       :  lcall _Read_Frame_xdata_Phy
                        :  ; variable 'dlen' allocated as 'auto'
                        :>     xdata UC_SOCKET *psock;
                        :>     uchar ui;
                        :> uchar ohlen;
                        :>     uint res;
                        :>
                        :> Read_Frame_xdata_Phy(hframe.bytes,20); // Read informative part of TCP header to HFRAME
                        :>
                        :>
                        :> dlen-=20;    // 
co:43a8: 74 ec          :  mov A,#236
co:43aa: 25 3d          :  add A,?process_TCP_dlen+1
co:43ac: f5 3d          :  mov ?i185+1,A
co:43ae: 74 ff          :  mov A,#255
co:43b0: 35 3c          :  addc A,?process_TCP_dlen
co:43b2: f5 3c          :  mov ?i185,A
                        :>
                        :> ohlen=hframe.tcp_hdr.hlen-80;
co:43b4: 90 01 dc       :  mov DPTR,#_hframe+12
co:43b7: e0             :  movx A,@DPTR
co:43b8: ff             :  mov R7,A
co:43b9: 74 b0          :  mov A,#176
co:43bb: 2f             :  add A,R7
co:43bc: ff             :  mov R7,A
                        :  ; variable 'ohlen' allocated as 'auto'
co:43bd: 8f 3e          :  mov ?process_TCP_ohlen,R7
co:43bf: 80 15          :  sjmp ?159
                        : ?158:
                        :> while(ohlen){  // Eat TCP-option, if MSS: ignore silently...
co:43c1: 74 f0          :  mov A,#-16
co:43c3: 25 3e          :  add A,?process_TCP_ohlen
co:43c5: f5 3e          :  mov ?process_TCP_ohlen,A
                        :>  ohlen-=16; // ohlen = size in 32-bit-word<<4
                        :>  dlen-=4;
co:43c7: 74 fc          :  mov A,#252
co:43c9: 25 3d          :  add A,?i185+1
co:43cb: f5 3d          :  mov ?i185+1,A
co:43cd: 74 ff          :  mov A,#255
co:43cf: 35 3c          :  addc A,?i185
co:43d1: f5 3c          :  mov ?i185,A
                        :>  Read_Frame_long_Phy(); 
co:43d3: 12 3e aa       :  lcall _Read_Frame_long_Phy
                        :> }
                        : ?159:
                        : 
co:43d6: e5 3e          :  mov A,?process_TCP_ohlen
co:43d8: 70 e7          :  jnz ?158
                        :  ; variable 'psock' allocated as 'auto'
                        :>
                        :>#ifdef DEBUG_REC
                        :>    // Record Data of received Frame
                        :>    record_frame('R',hframe.tcp_hdr.sport,hframe.tcp_hdr.seq.u,hframe.tcp_hdr.ack.u, hframe.tcp_hdr.fl
                        :>#endif
                        :>
                        :> // First try: Find any MATCHING socket. If one found, copy and process it...
                        :>     // This will also find a closed socket for a ACK-FIN->ACK-retransmition...
                        :>     psock=uc_socket;
co:43da: 75 3e 07       :  mov ?process_TCP_psock,#((_uc_socket)>>8)&255
co:43dd: 75 3f 8a       :  mov ?process_TCP_psock+1,#(_uc_socket)&255
                        :  ; variable 'ui' allocated as 'auto'
                        :>     for(ui=0;ui<MAX_SOCK;ui++,psock++){
co:43e0: e4             :  clr A
co:43e1: f5 40          :  mov ?process_TCP_ui,A
                        : ?161:
                        : 
co:43e3: 85 3e 83       :  mov DPH,?process_TCP_psock
co:43e6: 85 3f 82       :  mov DPL,?process_TCP_psock+1
co:43e9: e0             :  movx A,@DPTR
co:43ea: ff             :  mov R7,A
co:43eb: bf 02 02       :  cjne R7,#2,?_76
co:43ee: 80 03          :  sjmp ?_77
                        : ?_76:
co:43f0: 02 44 95       :  ljmp ?165
                        : ?_77:
                        :>         if(psock->socket_type==SOCKET_TCP){  // Only TCP-Sockets are of interest
co:43f3: ae 3e          :  mov R6,?process_TCP_psock
co:43f5: af 3f          :  mov R7,?process_TCP_psock+1
co:43f7: 74 08          :  mov A,#8
co:43f9: 2f             :  add A,R7
co:43fa: ff             :  mov R7,A
co:43fb: e4             :  clr A
co:43fc: 3e             :  addc A,R6
co:43fd: fe             :  mov R6,A
co:43fe: 8e 83          :  mov DPH,R6
co:4400: 8f 82          :  mov DPL,R7
co:4402: 12 34 f2       :  lcall __ld_dptr_r47
co:4405: 90 07 f6       :  mov DPTR,#_remote_ip
co:4408: 12 34 e6       :  lcall __ld_dptr_r03
co:440b: c3             :  clr C
co:440c: 12 34 08       :  lcall __cmp_i4
co:440f: 60 03          :  jz ?_78
co:4411: 02 44 95       :  ljmp ?167
                        : ?_78:
                        :>              // Test Remote IP-Match-Match,remote port and local port
                        :>              if(psock->sremote_ip==remote_ip.ipl){
co:4414: ae 3e          :  mov R6,?process_TCP_psock
co:4416: af 3f          :  mov R7,?process_TCP_psock+1
co:4418: 74 0c          :  mov A,#12
co:441a: 2f             :  add A,R7
co:441b: ff             :  mov R7,A
co:441c: e4             :  clr A
co:441d: 3e             :  addc A,R6
co:441e: fe             :  mov R6,A
co:441f: 8e 83          :  mov DPH,R6
co:4421: 8f 82          :  mov DPL,R7
co:4423: 12 35 46       :  lcall __ld_dptr_r45
co:4426: 90 01 d0       :  mov DPTR,#_hframe
co:4429: 12 35 4c       :  lcall __ld_dptr_r67
co:442c: ed             :  mov A,R5
co:442d: 6f             :  xrl A,R7
co:442e: 70 04          :  jnz ?_79
co:4430: ec             :  mov A,R4
co:4431: 6e             :  xrl A,R6
co:4432: 60 03          :  jz ?_80
                        : ?_79:
co:4434: 02 44 95       :  ljmp ?169
                        : ?_80:
                        :>                  if(psock->sremote_port==hframe.tcp_hdr.sport){
co:4437: ae 3e          :  mov R6,?process_TCP_psock
co:4439: af 3f          :  mov R7,?process_TCP_psock+1
co:443b: 74 0e          :  mov A,#14
co:443d: 2f             :  add A,R7
co:443e: ff             :  mov R7,A
co:443f: e4             :  clr A
co:4440: 3e             :  addc A,R6
co:4441: fe             :  mov R6,A
co:4442: 8e 83          :  mov DPH,R6
co:4444: 8f 82          :  mov DPL,R7
co:4446: 12 35 46       :  lcall __ld_dptr_r45
co:4449: 90 01 d2       :  mov DPTR,#_hframe+2
co:444c: 12 35 4c       :  lcall __ld_dptr_r67
co:444f: ed             :  mov A,R5
co:4450: 6f             :  xrl A,R7
co:4451: 70 04          :  jnz ?_81
co:4453: ec             :  mov A,R4
co:4454: 6e             :  xrl A,R6
co:4455: 60 02          :  jz ?_82
                        : ?_81:
co:4457: 80 3c          :  sjmp ?171
                        : ?_82:
                        :>                       if(psock->local_port==hframe.tcp_hdr.dport){
co:4459: 7a 00          :  mov R2,#0
co:445b: 7b 32          :  mov R3,#50
co:445d: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:445f: 7d 0a          :  mov R5,#(_match_socket)&255
co:4461: ae 3e          :  mov R6,?process_TCP_psock
co:4463: af 3f          :  mov R7,?process_TCP_psock+1
co:4465: 12 23 e5       :  lcall _xram_fast_copy
                        :>         // First copy to MATCH_SOCKET
                        :>      xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
                        :>                           res=state_machine_TCP(dlen);     // Now Header read, ready to read data
co:4468: ae 3c          :  mov R6,?i185
co:446a: af 3d          :  mov R7,?i185+1
co:446c: 12 36 9e       :  lcall _state_machine_TCP
                        :  ; variable 'res' allocated as 'auto'
co:446f: 8e 41          :  mov ?process_TCP_res,R6
co:4471: 8f 42          :  mov ?process_TCP_res+1,R7
                        :>         // Copy back from MATCH_SOCKET and return
                        :>      xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:4473: 7a 00          :  mov R2,#0
co:4475: 7b 32          :  mov R3,#50
co:4477: ac 3e          :  mov R4,?process_TCP_psock
co:4479: ad 3f          :  mov R5,?process_TCP_psock+1
co:447b: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:447d: 7f 0a          :  mov R7,#(_match_socket)&255
co:447f: 12 23 e5       :  lcall _xram_fast_copy
                        :>                           return res+ui;
co:4482: af 40          :  mov R7,?process_TCP_ui
co:4484: ad 07          :  mov R5,AR7
co:4486: 7c 00          :  mov R4,#0
co:4488: ae 41          :  mov R6,?process_TCP_res
co:448a: af 42          :  mov R7,?process_TCP_res+1
co:448c: ed             :  mov A,R5
co:448d: 2f             :  add A,R7
co:448e: ff             :  mov R7,A
co:448f: ec             :  mov A,R4
co:4490: 3e             :  addc A,R6
co:4491: fe             :  mov R6,A
co:4492: 02 45 7f       :  ljmp ?157
                        : ?171:
                        :>                          }
                        :>                  }
                        : ?169:
                        :>              }
                        : ?167:
                        :>         }
                        : ?165:
                        :>     }
co:4495: 05 40          :  inc ?process_TCP_ui
co:4497: 74 32          :  mov A,#50
co:4499: 25 3f          :  add A,?process_TCP_psock+1
co:449b: f5 3f          :  mov ?process_TCP_psock+1,A
co:449d: e4             :  clr A
co:449e: 35 3e          :  addc A,?process_TCP_psock
co:44a0: f5 3e          :  mov ?process_TCP_psock,A
                        : 
co:44a2: 7d 02          :  mov R5,#2
co:44a4: af 40          :  mov R7,?process_TCP_ui
co:44a6: c3             :  clr C
co:44a7: ef             :  mov A,R7
co:44a8: 9d             :  subb A,R5
co:44a9: 50 03          :  jnc ?_83
co:44ab: 02 43 e3       :  ljmp ?161
                        : ?_83:
                        :>
                        :>     // Now: No matching Socket found: Then only frames with SYN are allowed!
                        :>     if(!(hframe.tcp_hdr.flags&TSYN)) return EVENT_TCP_ILLEGALFRAME;
co:44ae: 90 01 dd       :  mov DPTR,#_hframe+13
co:44b1: e0             :  movx A,@DPTR
co:44b2: ff             :  mov R7,A
co:44b3: 54 02          :  anl A,#2
co:44b5: ff             :  mov R7,A
co:44b6: 70 07          :  jnz ?173
                        : 
co:44b8: 7e f8          :  mov R6,#248
co:44ba: 7f 00          :  mov R7,#0
co:44bc: 02 45 7f       :  ljmp ?157
                        : ?173:
                        :  ; variable 'psock' allocated as 'auto'
                        :>        // No matching socket has been found, so find one with TCP_CLOSED and matching local port to o
                        :>     psock=uc_socket;
co:44bf: 75 3e 07       :  mov ?i186,#((_uc_socket)>>8)&255
co:44c2: 75 3f 8a       :  mov ?i186+1,#(_uc_socket)&255
                        :  ; variable 'ui' allocated as 'auto'
                        :>     for(ui=0;ui<MAX_SOCK;ui++,psock++){
co:44c5: e4             :  clr A
co:44c6: f5 40          :  mov ?i187,A
                        : ?175:
                        : 
co:44c8: 85 3e 83       :  mov DPH,?i186
co:44cb: 85 3f 82       :  mov DPL,?i186+1
co:44ce: e0             :  movx A,@DPTR
co:44cf: ff             :  mov R7,A
co:44d0: bf 02 02       :  cjne R7,#2,?_85
co:44d3: 80 03          :  sjmp ?_86
                        : ?_85:
co:44d5: 02 45 51       :  ljmp ?179
                        : ?_86:
                        :>         if(psock->socket_type==SOCKET_TCP){  // Only TCP-Sockets are of interest if an offered local 
co:44d8: ae 3e          :  mov R6,?i186
co:44da: af 3f          :  mov R7,?i186+1
co:44dc: 0f             :  inc R7
co:44dd: ef             :  mov A,R7
co:44de: 70 01          :  jnz ?__4
co:44e0: 0e             :  inc R6
                        : ?__4:
co:44e1: 85 06 83       :  mov DPH,AR6
co:44e4: 85 07 82       :  mov DPL,AR7
co:44e7: e0             :  movx A,@DPTR
co:44e8: ff             :  mov R7,A
co:44e9: 60 03          :  jz ?_87
co:44eb: 02 45 51       :  ljmp ?181
                        : ?_87:
co:44ee: ae 3e          :  mov R6,?i186
co:44f0: af 3f          :  mov R7,?i186+1
co:44f2: 74 0e          :  mov A,#14
co:44f4: 2f             :  add A,R7
co:44f5: ff             :  mov R7,A
co:44f6: e4             :  clr A
co:44f7: 3e             :  addc A,R6
co:44f8: fe             :  mov R6,A
co:44f9: 8e 83          :  mov DPH,R6
co:44fb: 8f 82          :  mov DPL,R7
co:44fd: 12 35 46       :  lcall __ld_dptr_r45
co:4500: 90 01 d2       :  mov DPTR,#_hframe+2
co:4503: 12 35 4c       :  lcall __ld_dptr_r67
co:4506: ed             :  mov A,R5
co:4507: 6f             :  xrl A,R7
co:4508: 70 04          :  jnz ?_88
co:450a: ec             :  mov A,R4
co:450b: 6e             :  xrl A,R6
co:450c: 60 02          :  jz ?_89
                        : ?_88:
co:450e: 80 41          :  sjmp ?181
                        : ?_89:
                        :>              if(psock->state==TCP_CLOSED && psock->local_port==hframe.tcp_hdr.dport){
co:4510: 7a 00          :  mov R2,#0
co:4512: 7b 32          :  mov R3,#50
co:4514: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:4516: 7d 0a          :  mov R5,#(_match_socket)&255
co:4518: ae 3e          :  mov R6,?i186
co:451a: af 3f          :  mov R7,?i186+1
co:451c: 12 23 e5       :  lcall _xram_fast_copy
                        :>    // First copy to MATCH_SOCKET
                        :>    xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
                        :>                  res=state_machine_TCP(dlen);     // Now Header read, ready to read data
co:451f: ae 3c          :  mov R6,?i185
co:4521: af 3d          :  mov R7,?i185+1
co:4523: 12 36 9e       :  lcall _state_machine_TCP
                        :  ; variable 'res' allocated as 'auto'
co:4526: 8e 41          :  mov ?i188,R6
co:4528: 8f 42          :  mov ?i188+1,R7
                        :>        // Copy back from MATCH_SOCKET and return
                        :>    xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:452a: 7a 00          :  mov R2,#0
co:452c: 7b 32          :  mov R3,#50
co:452e: ac 3e          :  mov R4,?i186
co:4530: ad 3f          :  mov R5,?i186+1
co:4532: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:4534: 7f 0a          :  mov R7,#(_match_socket)&255
co:4536: 12 23 e5       :  lcall _xram_fast_copy
                        :>                  if (res) return res+ui;
co:4539: e5 41          :  mov A,?i188
co:453b: 45 42          :  orl A,?i188+1
co:453d: 60 12          :  jz ?183
                        : 
co:453f: af 40          :  mov R7,?i187
co:4541: ad 07          :  mov R5,AR7
co:4543: 7c 00          :  mov R4,#0
co:4545: ae 41          :  mov R6,?i188
co:4547: af 42          :  mov R7,?i188+1
co:4549: ed             :  mov A,R5
co:454a: 2f             :  add A,R7
co:454b: ff             :  mov R7,A
co:454c: ec             :  mov A,R4
co:454d: 3e             :  addc A,R6
co:454e: fe             :  mov R6,A
co:454f: 80 2e          :  sjmp ?157
                        : ?183:
                        :>              }
                        : ?181:
                        :>         }
                        : ?179:
                        :>     }
co:4551: 05 40          :  inc ?i187
co:4553: 74 32          :  mov A,#50
co:4555: 25 3f          :  add A,?i186+1
co:4557: f5 3f          :  mov ?i186+1,A
co:4559: e4             :  clr A
co:455a: 35 3e          :  addc A,?i186
co:455c: f5 3e          :  mov ?i186,A
                        : 
co:455e: 7d 02          :  mov R5,#2
co:4560: af 40          :  mov R7,?i187
co:4562: c3             :  clr C
co:4563: ef             :  mov A,R7
co:4564: 9d             :  subb A,R5
co:4565: 50 03          :  jnc ?_91
co:4567: 02 44 c8       :  ljmp ?175
                        : ?_91:
                        :>
                        :>     // Nothing found and nothing free! Deny request by replying with a TCP-RESET (not replying may be
                        :>#ifdef PHY_ETH
                        :>     send_incomming_reset_TCP(dlen,&remote_mac,remote_ip.ipl);
co:456a: 90 07 f6       :  mov DPTR,#_remote_ip
co:456d: 12 34 e6       :  lcall __ld_dptr_r03
co:4570: 7c 02          :  mov R4,#((_remote_mac)>>8)&255
co:4572: 7d 0a          :  mov R5,#(_remote_mac)&255
co:4574: ae 3c          :  mov R6,?i185
co:4576: af 3d          :  mov R7,?i185+1
co:4578: 12 3e ec       :  lcall _send_incomming_reset_TCP
                        :>#else
                        :>     send_incomming_reset_TCP(dlen,remote_ip.ipl);
                        :>#endif
                        :>     return EVENT_TCP_DENIED;
co:457b: 7e f0          :  mov R6,#240
co:457d: 7f 00          :  mov R7,#0
                        : ?157:
co:457f: 22             :  ret
                        : ; end of function process_TCP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:7 bytes
                        : 
                        :  .export _process_IP ; unsigned int process_IP(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __process_IP
                        : _process_IP: ; unsigned int process_IP(void)
                        :>
                        :>}
                        :>
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* void process_IP(void)
                        :>* 
                        :>*
                        :>* 2.nd-Level-Multiplexer
                        :>**********************************************************************************/
                        :>uint process_IP(void){
co:3da5: 12 47 50       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'hdr' allocated as 'auto'
                        :> uint hdr;
                        :> uint dlen;
                        :> uchar pcol;
                        :> 
                        :> hdr=Read_Frame_word_Phy();  // Read Header
                        :> if((hdr&0xF000)!=0x4000) return EVENT_IP_NOIP4; // Not IP4!
co:3da8: 8e 37          :  mov ?process_IP_hdr,R6
co:3daa: 8f 38          :  mov ?process_IP_hdr+1,R7
co:3dac: 7f 00          :  mov R7,#0
co:3dae: 53 06 f0       :  anl AR6,#240
co:3db1: ef             :  mov A,R7
co:3db2: 70 05          :  jnz ?_92
co:3db4: ee             :  mov A,R6
co:3db5: 64 40          :  xrl A,#64
co:3db7: 60 07          :  jz ?190
                        : ?_92:
                        : 
co:3db9: 7e c0          :  mov R6,#192
co:3dbb: 7f 00          :  mov R7,#0
co:3dbd: 02 3e 7b       :  ljmp ?189
                        : ?190:
                        :> dlen=Read_Frame_word_Phy();  // Read total length of datagram
co:3dc0: 12 47 50       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'dlen' allocated as 'auto'
co:3dc3: 8e 39          :  mov ?process_IP_dlen,R6
co:3dc5: 8f 3a          :  mov ?process_IP_dlen+1,R7
                        :> Read_Frame_word_Phy();   // Ignore Ident
co:3dc7: 12 47 50       :  lcall _Read_Frame_word_Phy
                        :>
                        :> if(Read_Frame_word_Phy()&0x3FFF) return EVENT_IP_WONTFRAG; // Reject fragemnts!
co:3dca: 12 47 50       :  lcall _Read_Frame_word_Phy
co:3dcd: 53 06 3f       :  anl AR6,#63
co:3dd0: ee             :  mov A,R6
co:3dd1: 4f             :  orl A,R7
co:3dd2: 60 07          :  jz ?192
                        : 
co:3dd4: 7e c1          :  mov R6,#193
co:3dd6: 7f 00          :  mov R7,#0
co:3dd8: 02 3e 7b       :  ljmp ?189
                        : ?192:
                        :>
                        :> pcol=(uchar)Read_Frame_word_Phy(); // Protocol (1: ICMP 6 TCP 17: UDP)
co:3ddb: 12 47 50       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'pcol' allocated as 'auto'
co:3dde: 8f 3b          :  mov ?process_IP_pcol,R7
                        :> Read_Frame_word_Phy();   // Ignore IP Checksum (already secured by Ethernet)
co:3de0: 12 47 50       :  lcall _Read_Frame_word_Phy
                        :>
                        :> remote_ip.ipl=Read_Frame_long_Phy(); // Destination IP (should be US)
co:3de3: 12 3e aa       :  lcall _Read_Frame_long_Phy
co:3de6: 90 07 f6       :  mov DPTR,#_remote_ip
co:3de9: 12 34 bc       :  lcall __st_dptr_r47
                        :> Read_Frame_long_Phy();   // Destination IP (should be US)
co:3dec: 12 3e aa       :  lcall _Read_Frame_long_Phy
                        :  ; variable 'dlen' allocated as 'auto'
                        :>
                        :> dlen-=20;    // Adjust header
co:3def: 74 ec          :  mov A,#236
co:3df1: 25 3a          :  add A,?process_IP_dlen+1
co:3df3: f5 3a          :  mov ?i203+1,A
co:3df5: 74 ff          :  mov A,#255
co:3df7: 35 39          :  addc A,?process_IP_dlen
co:3df9: f5 39          :  mov ?i203,A
                        :> hdr&=0xF00;
co:3dfb: ae 37          :  mov R6,?process_IP_hdr
co:3dfd: af 38          :  mov R7,?process_IP_hdr+1
co:3dff: 7d 00          :  mov R5,#0
co:3e01: ee             :  mov A,R6
co:3e02: 54 0f          :  anl A,#15
co:3e04: fc             :  mov R4,A
                        :  ; variable 'hdr' assigned to register 'RW45'
                        :> hdr>>=8;
co:3e05: 7f 08          :  mov R7,#8
co:3e07: ae 04          :  mov R6,AR4
co:3e09: ed             :  mov A,R5
co:3e0a: 8f f0          :  mov B,R7
co:3e0c: 05 f0          :  inc B
co:3e0e: 80 05          :  sjmp ?_95
                        : ?_96:
co:3e10: ce             :  xch A,R6
co:3e11: c3             :  clr C
co:3e12: 13             :  rrc A
co:3e13: ce             :  xch A,R6
co:3e14: 13             :  rrc A
                        : ?_95:
co:3e15: d5 f0 f8       :  djnz B,?_96
co:3e18: ff             :  mov R7,A
                        :  ; variable 'hdr' assigned to register 'RW67'
                        :> hdr-=5;
co:3e19: 74 fb          :  mov A,#251
co:3e1b: 2f             :  add A,R7
co:3e1c: ff             :  mov R7,A
co:3e1d: 74 ff          :  mov A,#255
co:3e1f: 3e             :  addc A,R6
co:3e20: fe             :  mov R6,A
                        :  ; variable 'hdr' allocated as 'auto'
co:3e21: 8e 37          :  mov ?i206,R6
co:3e23: 8f 38          :  mov ?i206+1,R7
co:3e25: 80 0f          :  sjmp ?195
                        : ?194:
                        :> while(hdr--){    
co:3e27: 12 3e aa       :  lcall _Read_Frame_long_Phy
                        :>  Read_Frame_long_Phy();  // Ignore IP options
                        :>  dlen-=4;
co:3e2a: 74 fc          :  mov A,#252
co:3e2c: 25 3a          :  add A,?i203+1
co:3e2e: f5 3a          :  mov ?i203+1,A
co:3e30: 74 ff          :  mov A,#255
co:3e32: 35 39          :  addc A,?i203
co:3e34: f5 39          :  mov ?i203,A
                        :> }
                        : ?195:
                        : 
co:3e36: ac 37          :  mov R4,?i206
co:3e38: ad 38          :  mov R5,?i206+1
co:3e3a: 74 ff          :  mov A,#255
co:3e3c: 2d             :  add A,R5
co:3e3d: ff             :  mov R7,A
co:3e3e: 74 ff          :  mov A,#255
co:3e40: 3c             :  addc A,R4
co:3e41: fe             :  mov R6,A
co:3e42: 8e 37          :  mov ?i206,R6
co:3e44: 8f 38          :  mov ?i206+1,R7
co:3e46: ec             :  mov A,R4
co:3e47: 4d             :  orl A,R5
co:3e48: 70 dd          :  jnz ?194
                        :> if(pcol==1){
co:3e4a: 74 01          :  mov A,#1
co:3e4c: 65 3b          :  xrl A,?process_IP_pcol
co:3e4e: 70 09          :  jnz ?197
                        : 
co:3e50: ae 39          :  mov R6,?i203
co:3e52: af 3a          :  mov R7,?i203+1
co:3e54: 12 42 7c       :  lcall _process_ICMP
co:3e57: 80 22          :  sjmp ?189
                        : ?197:
                        :>  return process_ICMP(dlen);
                        :> }else if(pcol==6){ // TCP
co:3e59: 74 06          :  mov A,#6
co:3e5b: 65 3b          :  xrl A,?process_IP_pcol
co:3e5d: 70 09          :  jnz ?199
                        : 
co:3e5f: ae 39          :  mov R6,?i203
co:3e61: af 3a          :  mov R7,?i203+1
co:3e63: 12 43 99       :  lcall _process_TCP
co:3e66: 80 13          :  sjmp ?189
                        : ?199:
                        :>  return process_TCP(dlen);
                        :>#ifdef USE_UDP
                        :> }else if(pcol==17){ // UDP
co:3e68: 74 11          :  mov A,#17
co:3e6a: 65 3b          :  xrl A,?process_IP_pcol
co:3e6c: 70 09          :  jnz ?201
                        : 
co:3e6e: ae 39          :  mov R6,?i203
co:3e70: af 3a          :  mov R7,?i203+1
co:3e72: 12 48 45       :  lcall _process_UDP
co:3e75: 80 04          :  sjmp ?189
                        : ?201:
                        :>  return process_UDP(dlen);
                        :>#endif
                        :> }
                        :> return EVENT_IP_UNKNOWN;  // Don't unterstand this
co:3e77: 7e c2          :  mov R6,#194
co:3e79: 7f 00          :  mov R7,#0
                        : ?189:
co:3e7b: 22             :  ret
                        : ; end of function process_IP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:5 bytes
                        : 
                        :  .export _send_socket_udp ; unsigned int send_socket_udp(unsigned char, xdata unsigned char *, unsigne
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_socket_udp
                        : _send_socket_udp: ; unsigned int send_socket_udp(unsigned char, xdata unsigned char *, unsigned int)
                        :  ; parameter 'pbuf' in 'RW45' assigned to 'RW01'
                        :  ; parameter 'datalen' in 'RW23' assigned to 'B1_RW89'
                        :  ; parameter 'sock' in 'R7'
co:4952: a8 04          :  mov R0,AR4
co:4954: a9 05          :  mov R1,AR5
co:4956: 8a 08          :  mov AR8,R2
co:4958: 8b 09          :  mov AR9,R3
                        :>}
                        :>
                        :>
                        :>#ifdef USE_UDP
                        :>/**********************************************************************************
                        :>* uint send_socket_udp(uchar sock, xdata uchar* pdata, uint datalen)
                        :>* 
                        :>* Send data without any buffering
                        :>**********************************************************************************/
                        :>uint send_socket_udp(uchar sock, xdata uchar* pbuf, uint datalen){
co:495a: e4             :  clr A
co:495b: fe             :  mov R6,A
co:495c: fc             :  mov R4,A
co:495d: 7d 32          :  mov R5,#50
co:495f: 12 34 21       :  lcall __mul_i2
co:4962: 7c 07          :  mov R4,#((_uc_socket)>>8)&255
co:4964: 7d 8a          :  mov R5,#(_uc_socket)&255
co:4966: ed             :  mov A,R5
co:4967: 2f             :  add A,R7
co:4968: fb             :  mov R3,A
co:4969: ec             :  mov A,R4
co:496a: 3e             :  addc A,R6
co:496b: fa             :  mov R2,A
                        :  ; variable 'psock' assigned to register 'RW23'
                        :>     xdata UC_SOCKET *psock;
                        :>     psock=&uc_socket[sock];
                        :> if(psock->socket_type!=SOCKET_UDP) return EVENT_UDP_ERROR;
co:496c: 85 02 83       :  mov DPH,AR2
co:496f: 85 03 82       :  mov DPL,AR3
co:4972: e0             :  movx A,@DPTR
co:4973: ff             :  mov R7,A
co:4974: 64 01          :  xrl A,#1
co:4976: 60 06          :  jz ?208
                        : 
co:4978: 7e e1          :  mov R6,#225
co:497a: 7f 00          :  mov R7,#0
co:497c: 80 4c          :  sjmp ?207
                        : ?208:
                        :>#ifdef PHY_ETH
                        :> send_upd(pbuf,datalen,psock->sremote_mac,psock->sremote_ip,psock->local_port,psock->sremote_port);
co:497e: 74 0c          :  mov A,#12
co:4980: 2b             :  add A,R3
co:4981: ff             :  mov R7,A
co:4982: e4             :  clr A
co:4983: 3a             :  addc A,R2
co:4984: fe             :  mov R6,A
co:4985: 8e 83          :  mov DPH,R6
co:4987: 8f 82          :  mov DPL,R7
co:4989: 12 35 4c       :  lcall __ld_dptr_r67
co:498c: 8e 38          :  mov _send_upd_formal_near+6,R6
co:498e: 8f 39          :  mov _send_upd_formal_near+7,R7
co:4990: 74 0e          :  mov A,#14
co:4992: 2b             :  add A,R3
co:4993: ff             :  mov R7,A
co:4994: e4             :  clr A
co:4995: 3a             :  addc A,R2
co:4996: fe             :  mov R6,A
co:4997: 8e 83          :  mov DPH,R6
co:4999: 8f 82          :  mov DPL,R7
co:499b: 12 35 4c       :  lcall __ld_dptr_r67
co:499e: 8e 36          :  mov _send_upd_formal_near+4,R6
co:49a0: 8f 37          :  mov _send_upd_formal_near+5,R7
co:49a2: 74 08          :  mov A,#8
co:49a4: 2b             :  add A,R3
co:49a5: ff             :  mov R7,A
co:49a6: e4             :  clr A
co:49a7: 3a             :  addc A,R2
co:49a8: fe             :  mov R6,A
co:49a9: 8e 83          :  mov DPH,R6
co:49ab: 8f 82          :  mov DPL,R7
co:49ad: 12 34 f2       :  lcall __ld_dptr_r47
co:49b0: 74 32          :  mov A,#_send_upd_formal_near
co:49b2: 12 32 9c       :  lcall __st_a_r47
co:49b5: 74 02          :  mov A,#2
co:49b7: 2b             :  add A,R3
co:49b8: fb             :  mov R3,A
co:49b9: e4             :  clr A
co:49ba: 3a             :  addc A,R2
co:49bb: fa             :  mov R2,A
co:49bc: ac 08          :  mov R4,AR8
co:49be: ad 09          :  mov R5,AR9
co:49c0: ae 00          :  mov R6,AR0
co:49c2: af 01          :  mov R7,AR1
co:49c4: 12 47 67       :  lcall _send_upd
                        :>#else
                        :> send_upd(pbuf,datalen,psock->sremote_ip,psock->local_port,psock->sremote_port);
                        :>#endif
                        :> return 0;
co:49c7: e4             :  clr A
co:49c8: fe             :  mov R6,A
co:49c9: ff             :  mov R7,A
                        : ?207:
co:49ca: 22             :  ret
                        : ; end of function send_socket_udp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _send_socket_tcp ; unsigned int send_socket_tcp(unsigned char, xdata unsigned char *, unsigne
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_socket_tcp
                        : _send_socket_tcp: ; unsigned int send_socket_tcp(unsigned char, xdata unsigned char *, unsigned int)
                        :  ; parameter 'datalen' in 'RW23' moved and assigned to local '?send_socket_tcp_datalen'
                        :  ; parameter 'pbuf' in 'RW45' moved and assigned to local '?send_socket_tcp_pbuf'
                        :  ; parameter 'sock' in 'R7'
co:3a55: 8a 33          :  mov ?send_socket_tcp_datalen,R2
co:3a57: 8b 34          :  mov ?send_socket_tcp_datalen+1,R3
co:3a59: 8c 35          :  mov ?send_socket_tcp_pbuf,R4
co:3a5b: 8d 36          :  mov ?send_socket_tcp_pbuf+1,R5
                        :>}
                        :>#endif
                        :>
                        :>/**********************************************************************************
                        :>* uint send_socket_tcp(uchar sock, xdata uchar* pdata, uint datalen)
                        :>* 
                        :>* Bind an (allocated and filled xdata) buffer to a socket and send it. After Success,
                        :>* the buffer is freed by the stack (check with ready4tx_socket()
                        :>* The buffer must be allocated with allocate_tx_buf().
                        :>* For return values!=0 the buffer must be freed by the caller!
                        :>*
                        :>* Remark for least ressouces: 
                        :>* ---------------------------
                        :>* If Space is very low on the used System, this function might be  called directly, 
                        :>* see stringsend_socket().
                        :>* 
                        :>**********************************************************************************/
                        :>uint send_socket_tcp(uchar sock, xdata uchar* pbuf, uint datalen){
co:3a5d: e4             :  clr A
co:3a5e: fe             :  mov R6,A
co:3a5f: fc             :  mov R4,A
co:3a60: 7d 32          :  mov R5,#50
co:3a62: 12 34 21       :  lcall __mul_i2
co:3a65: 7c 07          :  mov R4,#((_uc_socket)>>8)&255
co:3a67: 7d 8a          :  mov R5,#(_uc_socket)&255
co:3a69: ed             :  mov A,R5
co:3a6a: 2f             :  add A,R7
co:3a6b: ff             :  mov R7,A
co:3a6c: ec             :  mov A,R4
co:3a6d: 3e             :  addc A,R6
co:3a6e: fe             :  mov R6,A
                        :  ; variable 'psock' allocated as 'auto'
co:3a6f: 8e 37          :  mov ?send_socket_tcp_psock,R6
co:3a71: 8f 38          :  mov ?send_socket_tcp_psock+1,R7
                        :>     xdata UC_SOCKET *psock;
                        :>     psock=&uc_socket[sock];
                        :> // Copy Socket to Working Socket
                        :> xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
co:3a73: 7a 00          :  mov R2,#0
co:3a75: 7b 32          :  mov R3,#50
co:3a77: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:3a79: 7d 0a          :  mov R5,#(_match_socket)&255
co:3a7b: ae 37          :  mov R6,?send_socket_tcp_psock
co:3a7d: af 38          :  mov R7,?send_socket_tcp_psock+1
co:3a7f: 12 23 e5       :  lcall _xram_fast_copy
                        :> if(match_socket.socket_type!=SOCKET_TCP || match_socket.state!=TCP_EST) return EVENT_TCP_DENIED;
co:3a82: 90 00 0a       :  mov DPTR,#_match_socket
co:3a85: e0             :  movx A,@DPTR
co:3a86: ff             :  mov R7,A
co:3a87: bf 02 09       :  cjne R7,#2,?213
co:3a8a: 90 00 0b       :  mov DPTR,#_match_socket+1
co:3a8d: e0             :  movx A,@DPTR
co:3a8e: ff             :  mov R7,A
co:3a8f: 64 02          :  xrl A,#2
co:3a91: 60 07          :  jz ?211
                        : ?213:
                        : 
co:3a93: 7e f0          :  mov R6,#240
co:3a95: 7f 00          :  mov R7,#0
co:3a97: 02 3b a6       :  ljmp ?210
                        : ?211:
                        :> if(!datalen) {
co:3a9a: e5 33          :  mov A,?send_socket_tcp_datalen
co:3a9c: 45 34          :  orl A,?send_socket_tcp_datalen+1
co:3a9e: 70 0d          :  jnz ?214
                        : 
co:3aa0: ae 35          :  mov R6,?send_socket_tcp_pbuf
co:3aa2: af 36          :  mov R7,?send_socket_tcp_pbuf+1
co:3aa4: 12 36 34       :  lcall _free_tx_buf
                        :>  free_tx_buf(pbuf); // Free Buffer
                        :>  return 0;  // IDIOTA!
co:3aa7: e4             :  clr A
co:3aa8: fe             :  mov R6,A
co:3aa9: ff             :  mov R7,A
co:3aaa: 02 3b a6       :  ljmp ?210
                        : ?214:
                        :> }
                        :>
                        :> // Bind Buffer try to allocate B1 first, then B2m then B3 else error
                        :> if(!match_socket.buf_outsize1){
co:3aad: 90 00 34       :  mov DPTR,#_match_socket+42
co:3ab0: 12 35 4c       :  lcall __ld_dptr_r67
co:3ab3: ee             :  mov A,R6
co:3ab4: 4f             :  orl A,R7
co:3ab5: 70 31          :  jnz ?216
                        : 
co:3ab7: ae 35          :  mov R6,?send_socket_tcp_pbuf
co:3ab9: af 36          :  mov R7,?send_socket_tcp_pbuf+1
co:3abb: 90 00 3a       :  mov DPTR,#_match_socket+48
co:3abe: 12 35 40       :  lcall __st_dptr_r67
                        :>  match_socket.p_outbuf1=pbuf;
                        :>  match_socket.buf_outsize1=datalen;
co:3ac1: ae 33          :  mov R6,?send_socket_tcp_datalen
co:3ac3: af 34          :  mov R7,?send_socket_tcp_datalen+1
co:3ac5: 90 00 34       :  mov DPTR,#_match_socket+42
co:3ac8: 12 35 40       :  lcall __st_dptr_r67
                        :>  match_socket.sseq_1=match_socket.sseq.u+datalen;
co:3acb: ae 33          :  mov R6,?send_socket_tcp_datalen
co:3acd: af 34          :  mov R7,?send_socket_tcp_datalen+1
co:3acf: ab 07          :  mov R3,AR7
co:3ad1: aa 06          :  mov R2,AR6
co:3ad3: e4             :  clr A
co:3ad4: f9             :  mov R1,A
co:3ad5: f8             :  mov R0,A
co:3ad6: 90 00 1e       :  mov DPTR,#_match_socket+20
co:3ad9: 12 34 f2       :  lcall __ld_dptr_r47
co:3adc: 12 35 9e       :  lcall __add_i4
co:3adf: 90 00 36       :  mov DPTR,#_match_socket+44
co:3ae2: 12 34 bc       :  lcall __st_dptr_r47
                        :>  // puts("<SB1>");
                        :> }else if(!match_socket.buf_outsize2){
co:3ae5: 02 3b 62       :  ljmp ?217
                        : ?216:
                        : 
co:3ae8: 90 00 2c       :  mov DPTR,#_match_socket+34
co:3aeb: 12 35 4c       :  lcall __ld_dptr_r67
co:3aee: ee             :  mov A,R6
co:3aef: 4f             :  orl A,R7
co:3af0: 70 30          :  jnz ?218
                        : 
co:3af2: ae 35          :  mov R6,?send_socket_tcp_pbuf
co:3af4: af 36          :  mov R7,?send_socket_tcp_pbuf+1
co:3af6: 90 00 32       :  mov DPTR,#_match_socket+40
co:3af9: 12 35 40       :  lcall __st_dptr_r67
                        :>  match_socket.p_outbuf2=pbuf;
                        :>  match_socket.buf_outsize2=datalen;
co:3afc: ae 33          :  mov R6,?send_socket_tcp_datalen
co:3afe: af 34          :  mov R7,?send_socket_tcp_datalen+1
co:3b00: 90 00 2c       :  mov DPTR,#_match_socket+34
co:3b03: 12 35 40       :  lcall __st_dptr_r67
                        :>  match_socket.sseq_2=match_socket.sseq.u+datalen;
co:3b06: ae 33          :  mov R6,?send_socket_tcp_datalen
co:3b08: af 34          :  mov R7,?send_socket_tcp_datalen+1
co:3b0a: ab 07          :  mov R3,AR7
co:3b0c: aa 06          :  mov R2,AR6
co:3b0e: e4             :  clr A
co:3b0f: f9             :  mov R1,A
co:3b10: f8             :  mov R0,A
co:3b11: 90 00 1e       :  mov DPTR,#_match_socket+20
co:3b14: 12 34 f2       :  lcall __ld_dptr_r47
co:3b17: 12 35 9e       :  lcall __add_i4
co:3b1a: 90 00 2e       :  mov DPTR,#_match_socket+36
co:3b1d: 12 34 bc       :  lcall __st_dptr_r47
                        :>  // puts("<SB2>");
                        :> }else if(!match_socket.buf_outsize3){
co:3b20: 80 40          :  sjmp ?219
                        : ?218:
                        : 
co:3b22: 90 00 24       :  mov DPTR,#_match_socket+26
co:3b25: 12 35 4c       :  lcall __ld_dptr_r67
co:3b28: ee             :  mov A,R6
co:3b29: 4f             :  orl A,R7
co:3b2a: 70 30          :  jnz ?220
                        : 
co:3b2c: ae 35          :  mov R6,?send_socket_tcp_pbuf
co:3b2e: af 36          :  mov R7,?send_socket_tcp_pbuf+1
co:3b30: 90 00 2a       :  mov DPTR,#_match_socket+32
co:3b33: 12 35 40       :  lcall __st_dptr_r67
                        :>  match_socket.p_outbuf3=pbuf;
                        :>  match_socket.buf_outsize3=datalen;
co:3b36: ae 33          :  mov R6,?send_socket_tcp_datalen
co:3b38: af 34          :  mov R7,?send_socket_tcp_datalen+1
co:3b3a: 90 00 24       :  mov DPTR,#_match_socket+26
co:3b3d: 12 35 40       :  lcall __st_dptr_r67
                        :>  match_socket.sseq_3=match_socket.sseq.u+datalen;
co:3b40: ae 33          :  mov R6,?send_socket_tcp_datalen
co:3b42: af 34          :  mov R7,?send_socket_tcp_datalen+1
co:3b44: ab 07          :  mov R3,AR7
co:3b46: aa 06          :  mov R2,AR6
co:3b48: e4             :  clr A
co:3b49: f9             :  mov R1,A
co:3b4a: f8             :  mov R0,A
co:3b4b: 90 00 1e       :  mov DPTR,#_match_socket+20
co:3b4e: 12 34 f2       :  lcall __ld_dptr_r47
co:3b51: 12 35 9e       :  lcall __add_i4
co:3b54: 90 00 26       :  mov DPTR,#_match_socket+28
co:3b57: 12 34 bc       :  lcall __st_dptr_r47
                        :>  // puts("<SB3>");
                        :> }else{
co:3b5a: 80 06          :  sjmp ?221
                        : ?220:
                        : 
co:3b5c: 7e f4          :  mov R6,#244
co:3b5e: 7f 00          :  mov R7,#0
co:3b60: 80 44          :  sjmp ?210
                        : ?221:
                        : ?219:
                        : ?217:
                        :>  // If data still pending: Error, Important: BUFFER NOT FREED!
                        :>  return EVENT_TCP_TXPENDING; // Can't send, old data still waiting...
                        :> }
                        :> send_match_ok_TCP(pbuf,datalen,TACK+TPUSH);
co:3b62: 7b 18          :  mov R3,#24
co:3b64: ac 33          :  mov R4,?send_socket_tcp_datalen
co:3b66: ad 34          :  mov R5,?send_socket_tcp_datalen+1
co:3b68: ae 35          :  mov R6,?send_socket_tcp_pbuf
co:3b6a: af 36          :  mov R7,?send_socket_tcp_pbuf+1
co:3b6c: 12 41 f1       :  lcall _send_match_ok_TCP
                        :> match_socket.sseq.u+=datalen; // 32 Bit operation - This must be acknowledged to free the buffer.
co:3b6f: ae 33          :  mov R6,?send_socket_tcp_datalen
co:3b71: af 34          :  mov R7,?send_socket_tcp_datalen+1
co:3b73: ab 07          :  mov R3,AR7
co:3b75: aa 06          :  mov R2,AR6
co:3b77: e4             :  clr A
co:3b78: f9             :  mov R1,A
co:3b79: f8             :  mov R0,A
co:3b7a: 90 00 1e       :  mov DPTR,#_match_socket+20
co:3b7d: 12 34 f2       :  lcall __ld_dptr_r47
co:3b80: 12 35 9e       :  lcall __add_i4
co:3b83: 90 00 1e       :  mov DPTR,#_match_socket+20
co:3b86: 12 34 bc       :  lcall __st_dptr_r47
                        :>
                        :> // New TIMEOUT
                        :> match_socket.retry_cnt=0;
co:3b89: 90 00 22       :  mov DPTR,#_match_socket+24
co:3b8c: e4             :  clr A
co:3b8d: f0             :  movx @DPTR,A
                        :> match_socket.timer=BASIC_RETRY_TIMER;
co:3b8e: 90 00 23       :  mov DPTR,#_match_socket+25
co:3b91: 74 06          :  mov A,#6
co:3b93: f0             :  movx @DPTR,A
                        :>
                        :>  // Copy back from MATCH_SOCKET and return
                        :> xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:3b94: 7a 00          :  mov R2,#0
co:3b96: 7b 32          :  mov R3,#50
co:3b98: ac 37          :  mov R4,?send_socket_tcp_psock
co:3b9a: ad 38          :  mov R5,?send_socket_tcp_psock+1
co:3b9c: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:3b9e: 7f 0a          :  mov R7,#(_match_socket)&255
co:3ba0: 12 23 e5       :  lcall _xram_fast_copy
                        :> return 0; // All OK
co:3ba3: e4             :  clr A
co:3ba4: fe             :  mov R6,A
co:3ba5: ff             :  mov R7,A
                        : ?210:
co:3ba6: 22             :  ret
                        : ; end of function send_socket_tcp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:6 bytes
                        : 
                        :  .export _notready_socket_tcp ; unsigned int notready_socket_tcp(unsigned char, unsigned char)
                        :  .segment _notready_socket_tcp_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _notready_socket_tcp_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _notready_socket_tcp_formal_near, _notready_socket_tcp_local_near, __notready_socket_tcp
                        : 
                        :  .segment __notready_socket_tcp
                        : _notready_socket_tcp: ; (leaf function) unsigned int notready_socket_tcp(unsigned char, unsigned char)
                        :  ; parameter 'sock' in 'R7'
                        :  ; parameter 'flag' in 'R5' assigned to 'R1'
co:3c86: a9 05          :  mov R1,AR5
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uint notready4tx_socket_tcp(uchar sock)
                        :>* 
                        :>* Querries if a TCP socket is ready for Transmition, ok if 0.
                        :>* Checks if a Buffer is available for transmition to!)
                        :>* 
                        :>* Flag: RDY_4_TX (>0) or RDY_4_CLOSE (0)
                        :>**********************************************************************************/
                        :>uint notready_socket_tcp(uchar sock, uchar flag){
co:3c88: ad 07          :  mov R5,AR7
co:3c8a: e4             :  clr A
co:3c8b: fc             :  mov R4,A
co:3c8c: fe             :  mov R6,A
co:3c8d: 7f 32          :  mov R7,#50
co:3c8f: 12 34 21       :  lcall __mul_i2
co:3c92: 7a 07          :  mov R2,#((_uc_socket)>>8)&255
co:3c94: 7b 8a          :  mov R3,#(_uc_socket)&255
co:3c96: eb             :  mov A,R3
co:3c97: 2f             :  add A,R7
co:3c98: fd             :  mov R5,A
co:3c99: ea             :  mov A,R2
co:3c9a: 3e             :  addc A,R6
co:3c9b: fc             :  mov R4,A
                        :  ; variable 'psock' assigned to register 'RW45'
                        :>     xdata UC_SOCKET *psock;
                        :>     psock=&uc_socket[sock];
                        :> if(psock->socket_type!=SOCKET_TCP || psock->state!=TCP_EST) return EVENT_TCP_DENIED;
co:3c9c: 85 04 83       :  mov DPH,AR4
co:3c9f: 85 05 82       :  mov DPL,AR5
co:3ca2: e0             :  movx A,@DPTR
co:3ca3: ff             :  mov R7,A
co:3ca4: bf 02 13       :  cjne R7,#2,?225
co:3ca7: 74 01          :  mov A,#1
co:3ca9: 2d             :  add A,R5
co:3caa: ff             :  mov R7,A
co:3cab: e4             :  clr A
co:3cac: 3c             :  addc A,R4
co:3cad: fe             :  mov R6,A
co:3cae: 85 06 83       :  mov DPH,AR6
co:3cb1: 85 07 82       :  mov DPL,AR7
co:3cb4: e0             :  movx A,@DPTR
co:3cb5: ff             :  mov R7,A
co:3cb6: 64 02          :  xrl A,#2
co:3cb8: 60 07          :  jz ?223
                        : ?225:
                        : 
co:3cba: 7e f0          :  mov R6,#240
co:3cbc: 7f 00          :  mov R7,#0
co:3cbe: 02 3d 04       :  ljmp ?222
                        : ?223:
                        :> if(!tx_bufleft) return EVENT_SOCKET_NOBUFFER;  // Stack may be ready, but no buffer available...
co:3cc1: 90 00 06       :  mov DPTR,#_tx_bufleft
co:3cc4: e0             :  movx A,@DPTR
co:3cc5: ff             :  mov R7,A
co:3cc6: 70 06          :  jnz ?226
                        : 
co:3cc8: 7e d2          :  mov R6,#210
co:3cca: 7f 00          :  mov R7,#0
co:3ccc: 80 36          :  sjmp ?222
                        : ?226:
                        :>#ifndef PHY_ETH
                        :> if(!Phy_rdy4tx()) return EVENT_PHY_TXPEND;     // Still TX pending (PHY!)
                        :>#endif
                        :> if(flag){ // Check Ready for TX: BUF3 must be empty
co:3cce: e9             :  mov A,R1
co:3ccf: 60 18          :  jz ?228
                        : 
co:3cd1: 74 1a          :  mov A,#26
co:3cd3: 2d             :  add A,R5
co:3cd4: ff             :  mov R7,A
co:3cd5: e4             :  clr A
co:3cd6: 3c             :  addc A,R4
co:3cd7: fe             :  mov R6,A
co:3cd8: 8e 83          :  mov DPH,R6
co:3cda: 8f 82          :  mov DPL,R7
co:3cdc: 12 35 4c       :  lcall __ld_dptr_r67
co:3cdf: ee             :  mov A,R6
co:3ce0: 4f             :  orl A,R7
co:3ce1: 60 1e          :  jz ?229
                        :>  // If data still pending (Output Buffer full): Error
                        :>  if(psock->buf_outsize3) return EVENT_TCP_TXPENDING; // Can't send, old data still pending
co:3ce3: 7e f4          :  mov R6,#244
co:3ce5: 7f 00          :  mov R7,#0
co:3ce7: 80 1b          :  sjmp ?222
                        :> }else{  // Check Read for Close: BUF1 must be empty
                        : ?228:
                        : 
co:3ce9: 74 2a          :  mov A,#42
co:3ceb: 2d             :  add A,R5
co:3cec: ff             :  mov R7,A
co:3ced: e4             :  clr A
co:3cee: 3c             :  addc A,R4
co:3cef: fe             :  mov R6,A
co:3cf0: 8e 83          :  mov DPH,R6
co:3cf2: 8f 82          :  mov DPL,R7
co:3cf4: 12 35 4c       :  lcall __ld_dptr_r67
co:3cf7: ee             :  mov A,R6
co:3cf8: 4f             :  orl A,R7
co:3cf9: 60 06          :  jz ?232
                        :>  if(psock->buf_outsize1) return EVENT_TCP_TXPENDING; // Can't send, old data still pending
co:3cfb: 7e f4          :  mov R6,#244
co:3cfd: 7f 00          :  mov R7,#0
co:3cff: 80 03          :  sjmp ?222
                        : ?232:
                        :>
                        :> }
                        : ?229:
                        :> return 0; // SOCKEt IS READY!
co:3d01: e4             :  clr A
co:3d02: fe             :  mov R6,A
co:3d03: ff             :  mov R7,A
                        : ?222:
co:3d04: 22             :  ret
                        : ; end of function notready_socket_tcp
                        : ; used: R-1234567 BR-------- DPTR ACC PSW B
                        : 
                        :  .export _stringsend_socket_tcp ; unsigned int stringsend_socket_tcp(unsigned char, far char *)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __stringsend_socket_tcp
                        : _stringsend_socket_tcp: ; unsigned int stringsend_socket_tcp(unsigned char, far char *)
                        :  ; parameter 'pdata' in 'RL0123' moved and assigned to local '?stringsend_socket_tcp_pdata'
                        :  ; parameter 'sock' in 'R7' moved and assigned to local '?stringsend_socket_tcp_sock'
                        :  mov A,#?stringsend_socket_tcp_pdata
                        :  lcall __st_a_r03
                        :  mov ?stringsend_socket_tcp_sock,R7
                        :>}
                        :>
                        :>
                        :>/*********************************************************************************
                        :>* uint stringsend_socket_tcp(uchar sock, far char* pdata);
                        :>*
                        :>* Allocate a TCP-TX-Buffer and copy a string (far!) into it. 
                        :>* Returns 0 on success. Calls send_socket_tcp().
                        :>*********************************************************************************/
                        :>uint stringsend_socket_tcp(uchar sock, far char* pdata){
                        :  mov R5,#1
                        :  mov R7,?stringsend_socket_tcp_sock
                        :  lcall _notready_socket_tcp
                        :  mov A,R6
                        :  orl A,R7
                        :  jz ?235
                        :> xdata uchar* pbuf;
                        :> uint datalen;
                        :>
                        :> // Check if allowed
                        :> if(notready_socket_tcp(sock,RDY_4_TX)) return EVENT_TCP_DENIED;
                        :  mov R6,#240
                        :  mov R7,#0
                        :  ljmp ?234
                        : ?235:
                        :> datalen=strlen(pdata);
                        :  mov A,#?stringsend_socket_tcp_pdata
                        :  lcall __ld_a_r47
                        :  lcall _strlen
                        :  ; variable 'datalen' allocated as 'auto'
                        :  mov ?stringsend_socket_tcp_datalen,R6
                        :  mov ?stringsend_socket_tcp_datalen+1,R7
                        :> if(datalen>MAX_TX) return EVENT_SOCKET_BUF2SMALL; // Can't send as much...
                        :  mov R4,#0
                        :  mov R5,#100
                        :  mov R6,?stringsend_socket_tcp_datalen
                        :  mov R7,?stringsend_socket_tcp_datalen+1
                        :  setb C
                        :  mov A,R7
                        :  subb A,R5
                        :  mov A,R6
                        :  subb A,R4
                        :  jc ?237
                        : 
                        :  mov R6,#211
                        :  mov R7,#0
                        :  sjmp ?234
                        : ?237:
                        :> // Allocate a buffer
                        :> pbuf=allocate_tx_buf();
                        :  lcall _allocate_tx_buf
                        :  ; variable 'pbuf' allocated as 'auto'
                        :  mov ?stringsend_socket_tcp_pbuf,R6
                        :  mov ?stringsend_socket_tcp_pbuf+1,R7
                        :> if(!pbuf) return EVENT_SOCKET_NOBUFFER;   // No Buffer free?? -> Memory corrupt!
                        :  mov A,?stringsend_socket_tcp_pbuf
                        :  orl A,?stringsend_socket_tcp_pbuf+1
                        :  jnz ?239
                        : 
                        :  mov R6,#210
                        :  mov R7,#0
                        :  sjmp ?234
                        : ?239:
                        :> bmove(pdata,pbuf,datalen);
                        :  mov _bmove_formal_near,?stringsend_socket_tcp_datalen
                        :  mov _bmove_formal_near+1,?stringsend_socket_tcp_datalen+1
                        :  mov R6,?stringsend_socket_tcp_pbuf
                        :  mov R7,?stringsend_socket_tcp_pbuf+1
                        :  mov R3,AR7
                        :  mov R2,AR6
                        :  mov R0,#XDS
                        :  mov A,#?stringsend_socket_tcp_pdata
                        :  lcall __ld_a_r47
                        :  lcall _bmove
                        :> return send_socket_tcp(sock,pbuf,datalen);
                        :  mov R2,?stringsend_socket_tcp_datalen
                        :  mov R3,?stringsend_socket_tcp_datalen+1
                        :  mov R4,?stringsend_socket_tcp_pbuf
                        :  mov R5,?stringsend_socket_tcp_pbuf+1
                        :  mov R7,?stringsend_socket_tcp_sock
                        :  lcall _send_socket_tcp
                        : ?234:
                        :  ret
                        : ; end of function stringsend_socket_tcp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:9 bytes
                        : 
                        :  .export _close_socket_tcp ; unsigned int close_socket_tcp(unsigned char)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __close_socket_tcp
                        : _close_socket_tcp: ; unsigned int close_socket_tcp(unsigned char)
                        :  ; parameter 'sock' in 'R7'
                        :>}
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* uint close_socket_tcp(sock)
                        :>* 
                        :>* Close an open socket (regular mode)
                        :>* 
                        :>**********************************************************************************/
                        :>uint close_socket_tcp(uchar sock){
co:4ab9: e4             :  clr A
co:4aba: fe             :  mov R6,A
co:4abb: fc             :  mov R4,A
co:4abc: 7d 32          :  mov R5,#50
co:4abe: 12 34 21       :  lcall __mul_i2
co:4ac1: 7c 07          :  mov R4,#((_uc_socket)>>8)&255
co:4ac3: 7d 8a          :  mov R5,#(_uc_socket)&255
co:4ac5: ed             :  mov A,R5
co:4ac6: 2f             :  add A,R7
co:4ac7: ff             :  mov R7,A
co:4ac8: ec             :  mov A,R4
co:4ac9: 3e             :  addc A,R6
co:4aca: fe             :  mov R6,A
                        :  ; variable 'psock' allocated as 'auto'
co:4acb: 8e 33          :  mov ?close_socket_tcp_psock,R6
co:4acd: 8f 34          :  mov ?close_socket_tcp_psock+1,R7
                        :>     xdata UC_SOCKET *psock;
                        :>     psock=&uc_socket[sock];
                        :> // Copy Socket to Working Socket
                        :> xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
co:4acf: 7a 00          :  mov R2,#0
co:4ad1: 7b 32          :  mov R3,#50
co:4ad3: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:4ad5: 7d 0a          :  mov R5,#(_match_socket)&255
co:4ad7: ae 33          :  mov R6,?close_socket_tcp_psock
co:4ad9: af 34          :  mov R7,?close_socket_tcp_psock+1
co:4adb: 12 23 e5       :  lcall _xram_fast_copy
                        :> if(match_socket.socket_type!=SOCKET_TCP || !match_socket.state) return EVENT_TCP_DENIED; // Closing a
co:4ade: 90 00 0a       :  mov DPTR,#_match_socket
co:4ae1: e0             :  movx A,@DPTR
co:4ae2: ff             :  mov R7,A
co:4ae3: bf 02 07       :  cjne R7,#2,?244
co:4ae6: 90 00 0b       :  mov DPTR,#_match_socket+1
co:4ae9: e0             :  movx A,@DPTR
co:4aea: ff             :  mov R7,A
co:4aeb: 70 07          :  jnz ?242
                        : ?244:
                        : 
co:4aed: 7e f0          :  mov R6,#240
co:4aef: 7f 00          :  mov R7,#0
co:4af1: 02 4b 47       :  ljmp ?241
                        : ?242:
                        :>
                        :> // If data still pending: Error
                        :> if(match_socket.buf_outsize1) return EVENT_TCP_TXPENDING; // Can't send, old data still waiting...
co:4af4: 90 00 34       :  mov DPTR,#_match_socket+42
co:4af7: 12 35 4c       :  lcall __ld_dptr_r67
co:4afa: ee             :  mov A,R6
co:4afb: 4f             :  orl A,R7
co:4afc: 60 06          :  jz ?245
                        : 
co:4afe: 7e f4          :  mov R6,#244
co:4b00: 7f 00          :  mov R7,#0
co:4b02: 80 43          :  sjmp ?241
                        : ?245:
                        :>
                        :> send_match_ok_TCP(0,0,TACK+TFIN+TPUSH);
co:4b04: 7b 19          :  mov R3,#25
co:4b06: e4             :  clr A
co:4b07: fc             :  mov R4,A
co:4b08: fd             :  mov R5,A
co:4b09: e4             :  clr A
co:4b0a: fe             :  mov R6,A
co:4b0b: ff             :  mov R7,A
co:4b0c: 12 41 f1       :  lcall _send_match_ok_TCP
                        :> match_socket.sseq.u++; // 32 Bit operation - This must be acknowledged
co:4b0f: e4             :  clr A
co:4b10: f8             :  mov R0,A
co:4b11: f9             :  mov R1,A
co:4b12: fa             :  mov R2,A
co:4b13: 7b 01          :  mov R3,#1
co:4b15: 90 00 1e       :  mov DPTR,#_match_socket+20
co:4b18: 12 34 f2       :  lcall __ld_dptr_r47
co:4b1b: 12 35 9e       :  lcall __add_i4
co:4b1e: 90 00 1e       :  mov DPTR,#_match_socket+20
co:4b21: 12 34 bc       :  lcall __st_dptr_r47
                        :> match_socket.state=TCP_FINSENT;
co:4b24: 90 00 0b       :  mov DPTR,#_match_socket+1
co:4b27: 74 03          :  mov A,#3
co:4b29: f0             :  movx @DPTR,A
                        :>
                        :> // New TIMEOUT
                        :> match_socket.retry_cnt=0;
co:4b2a: 90 00 22       :  mov DPTR,#_match_socket+24
co:4b2d: e4             :  clr A
co:4b2e: f0             :  movx @DPTR,A
                        :> match_socket.timer=BASIC_RETRY_TIMER;
co:4b2f: 90 00 23       :  mov DPTR,#_match_socket+25
co:4b32: 74 06          :  mov A,#6
co:4b34: f0             :  movx @DPTR,A
                        :>
                        :>  // Copy back from MATCH_SOCKET and return
                        :> xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:4b35: 7a 00          :  mov R2,#0
co:4b37: 7b 32          :  mov R3,#50
co:4b39: ac 33          :  mov R4,?close_socket_tcp_psock
co:4b3b: ad 34          :  mov R5,?close_socket_tcp_psock+1
co:4b3d: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:4b3f: 7f 0a          :  mov R7,#(_match_socket)&255
co:4b41: 12 23 e5       :  lcall _xram_fast_copy
                        :>
                        :> // printf("<--CLOSE %u-->",match_socket.sremote_port);
                        :>
                        :> return 0; // All OK
co:4b44: e4             :  clr A
co:4b45: fe             :  mov R6,A
co:4b46: ff             :  mov R7,A
                        : ?241:
co:4b47: 22             :  ret
                        : ; end of function close_socket_tcp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .export _open_socket_udp ; unsigned int open_socket_udp(unsigned char, unsigned long, unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __open_socket_udp
                        : _open_socket_udp: ; unsigned int open_socket_udp(unsigned char, unsigned long, unsigned int)
                        :  ; parameter 'remote_ipl' in 'RL0123' moved and assigned to local '?open_socket_udp_remote_ipl'
                        :  ; parameter 'sock' in 'R7'
                        :  ; parameter 'remote_port' assigned to local '?open_socket_udp_0_remote_port'
co:49cb: 74 31          :  mov A,#?open_socket_udp_remote_ipl
co:49cd: 12 33 37       :  lcall __st_a_r03
                        :>}
                        :>
                        :>#ifdef USE_TCP_CLIENT
                        :>/**********************************************************************************
                        :>* uint open_socket_tcp(sock,ipl,port);
                        :>* 
                        :>* Initiate an active Open for a  given Socket
                        :>**********************************************************************************/
                        :>uint open_socket_tcp(uchar sock,unsigned long remote_ipl,unsigned int remote_port){
                        :>     xdata UC_SOCKET *psock;
                        :>     psock=&uc_socket[sock];
                        :> // Copy Socket to Working Socket
                        :> xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
                        :> if(match_socket.socket_type!=SOCKET_TCP || match_socket.state) return EVENT_TCP_DENIED; // No Access 
                        :>
                        :> match_socket.sremote_ip=remote_ipl;
                        :> match_socket.sremote_port=remote_port;
                        :>  
                        :>#ifdef PHY_ETH
                        :>   send_request_ARP(remote_ipl);
                        :>   match_socket.state=ARPSENT;
                        :>
                        :>#else
                        :>   // Ports already setup!
                        :>   match_socket.sseq.w.h_word=net_service_cnt;   // Time ascending...
                        :>   match_socket.sseq.w.l_word=0;    // Our relative Pointer (for HTTP, -1 due to SYNC)
                        :>   match_socket.state=TCP_SYNSENT;  // SYN confirmed with SYN+ACK
                        :>   send_match_ok_TCP(0,0,TSYN); // Initiate Connection with a SYN
                        :>#endif
                        :>   // New TIMEOUT
                        :>   match_socket.retry_cnt=0;
                        :>   match_socket.timer=BASIC_RETRY_TIMER;
                        :>
                        :>  // Copy back from MATCH_SOCKET and return
                        :> xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
                        :> return 0; // All OK
                        :>}
                        :>#endif
                        :>
                        :>#ifdef USE_UDP_CLIENT
                        :>/**********************************************************************************
                        :>* uint open_socket_udp(sock,ipl,port);
                        :>* 
                        :>* Initiate an active Open for a  given Socket in UDP-Mode
                        :>* 
                        :>**********************************************************************************/
                        :>uint open_socket_udp(uchar sock,unsigned long remote_ipl,unsigned int remote_port){
co:49d0: e4             :  clr A
co:49d1: fe             :  mov R6,A
co:49d2: fc             :  mov R4,A
co:49d3: 7d 32          :  mov R5,#50
co:49d5: 12 34 21       :  lcall __mul_i2
co:49d8: 7c 07          :  mov R4,#((_uc_socket)>>8)&255
co:49da: 7d 8a          :  mov R5,#(_uc_socket)&255
co:49dc: ed             :  mov A,R5
co:49dd: 2f             :  add A,R7
co:49de: ff             :  mov R7,A
co:49df: ec             :  mov A,R4
co:49e0: 3e             :  addc A,R6
co:49e1: fe             :  mov R6,A
                        :  ; variable 'psock' allocated as 'auto'
co:49e2: 8e 35          :  mov ?open_socket_udp_psock,R6
co:49e4: 8f 36          :  mov ?open_socket_udp_psock+1,R7
                        :>    xdata UC_SOCKET *psock;
                        :>    psock=&uc_socket[sock];
                        :>    
                        :>    // Copy Socket to Working Socket
                        :>    xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
co:49e6: 7a 00          :  mov R2,#0
co:49e8: 7b 32          :  mov R3,#50
co:49ea: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:49ec: 7d 0a          :  mov R5,#(_match_socket)&255
co:49ee: ae 35          :  mov R6,?open_socket_udp_psock
co:49f0: af 36          :  mov R7,?open_socket_udp_psock+1
co:49f2: 12 23 e5       :  lcall _xram_fast_copy
                        :>    if(match_socket.socket_type!=SOCKET_UDP || match_socket.state) return EVENT_UDP_DENIED; // No Acce
co:49f5: 90 00 0a       :  mov DPTR,#_match_socket
co:49f8: e0             :  movx A,@DPTR
co:49f9: ff             :  mov R7,A
co:49fa: bf 01 07       :  cjne R7,#1,?250
co:49fd: 90 00 0b       :  mov DPTR,#_match_socket+1
co:4a00: e0             :  movx A,@DPTR
co:4a01: ff             :  mov R7,A
co:4a02: 60 07          :  jz ?248
                        : ?250:
                        : 
co:4a04: 7e e4          :  mov R6,#228
co:4a06: 7f 00          :  mov R7,#0
co:4a08: 02 4a 7c       :  ljmp ?247
                        : ?248:
                        :>
                        :>    match_socket.sremote_ip=remote_ipl;
co:4a0b: 74 31          :  mov A,#?open_socket_udp_remote_ipl
co:4a0d: 12 33 44       :  lcall __ld_a_r47
co:4a10: 90 00 12       :  mov DPTR,#_match_socket+8
co:4a13: 12 34 bc       :  lcall __st_dptr_r47
                        :>    match_socket.sremote_port=remote_port;
co:4a16: ae 2f          :  mov R6,?open_socket_udp_0_remote_port
co:4a18: af 30          :  mov R7,?open_socket_udp_0_remote_port+1
co:4a1a: 90 00 16       :  mov DPTR,#_match_socket+12
co:4a1d: 12 35 40       :  lcall __st_dptr_r67
                        :>
                        :>    if(remote_ipl!=0xffffffff){        
co:4a20: 78 ff          :  mov R0,#255
co:4a22: 79 ff          :  mov R1,#255
co:4a24: 7a ff          :  mov R2,#255
co:4a26: 7b ff          :  mov R3,#255
co:4a28: 74 31          :  mov A,#?open_socket_udp_remote_ipl
co:4a2a: 12 33 44       :  lcall __ld_a_r47
co:4a2d: c3             :  clr C
co:4a2e: 12 34 08       :  lcall __cmp_i4
co:4a31: 60 1b          :  jz ?251
                        : 
co:4a33: 74 31          :  mov A,#?open_socket_udp_remote_ipl
co:4a35: 12 33 44       :  lcall __ld_a_r47
co:4a38: 12 3d 05       :  lcall _send_request_ARP
                        :>#ifdef PHY_ETH
                        :>      send_request_ARP(remote_ipl);
                        :>      match_socket.state=ARPSENT;
co:4a3b: 90 00 0b       :  mov DPTR,#_match_socket+1
co:4a3e: 74 06          :  mov A,#6
co:4a40: f0             :  movx @DPTR,A
                        :>#else
                        :>      match_socket.state=UDP_EST;
                        :>#endif
                        :>
                        :>      // New TIMEOUT
                        :>      match_socket.retry_cnt=0;
co:4a41: 90 00 22       :  mov DPTR,#_match_socket+24
co:4a44: e4             :  clr A
co:4a45: f0             :  movx @DPTR,A
                        :>      match_socket.timer=BASIC_RETRY_TIMER;
co:4a46: 90 00 23       :  mov DPTR,#_match_socket+25
co:4a49: 74 06          :  mov A,#6
co:4a4b: f0             :  movx @DPTR,A
                        :>    }else{
co:4a4c: 80 1c          :  sjmp ?252
                        : ?251:
                        : 
co:4a4e: 7f 06          :  mov R7,#6
co:4a50: 90 00 0c       :  mov DPTR,#_match_socket+2
                        : ?253:
                        :>      unsigned char i;
                        :>//      memset(match_socket.sremote_mac,0xff,6);
                        :>      for(i=0;i<6;i++) match_socket.sremote_mac[i]=0xff;
co:4a53: 74 ff          :  mov A,#255
co:4a55: f0             :  movx @DPTR,A
                        : 
co:4a56: a3             :  inc DPTR
                        : 
co:4a57: df fa          :  djnz R7,?253
                        :>                  match_socket.state=ARPREC;
co:4a59: 90 00 0b       :  mov DPTR,#_match_socket+1
co:4a5c: 74 07          :  mov A,#7
co:4a5e: f0             :  movx @DPTR,A
                        :>                  match_socket.retry_cnt=0;
co:4a5f: 90 00 22       :  mov DPTR,#_match_socket+24
co:4a62: e4             :  clr A
co:4a63: f0             :  movx @DPTR,A
                        :>        match_socket.timer=1;
co:4a64: 90 00 23       :  mov DPTR,#_match_socket+25
co:4a67: 74 01          :  mov A,#1
co:4a69: f0             :  movx @DPTR,A
                        :>    }
                        : ?252:
                        :>
                        :>    // Copy back from MATCH_SOCKET and return
                        :>    xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:4a6a: 7a 00          :  mov R2,#0
co:4a6c: 7b 32          :  mov R3,#50
co:4a6e: ac 35          :  mov R4,?open_socket_udp_psock
co:4a70: ad 36          :  mov R5,?open_socket_udp_psock+1
co:4a72: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:4a74: 7f 0a          :  mov R7,#(_match_socket)&255
co:4a76: 12 23 e5       :  lcall _xram_fast_copy
                        :>    return 0; // All OK
co:4a79: e4             :  clr A
co:4a7a: fe             :  mov R6,A
co:4a7b: ff             :  mov R7,A
                        : ?247:
co:4a7c: 22             :  ret
                        : ; end of function open_socket_udp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:6 bytes formals:2 bytes
                        : 
                        :  .export _close_socket_udp ; unsigned int close_socket_udp(unsigned char)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __close_socket_udp
                        : _close_socket_udp: ; unsigned int close_socket_udp(unsigned char)
                        :  ; parameter 'sock' in 'R7'
                        :>}
                        :>#endif
                        :>
                        :>#ifdef USE_UDP
                        :>/**********************************************************************************
                        :>* uint close_socket_udp(sock)
                        :>* 
                        :>* Close an open socket (regular mode)
                        :>* 
                        :>**********************************************************************************/
                        :>uint close_socket_udp(uchar sock){
co:4b88: e4             :  clr A
co:4b89: fe             :  mov R6,A
co:4b8a: fc             :  mov R4,A
co:4b8b: 7d 32          :  mov R5,#50
co:4b8d: 12 34 21       :  lcall __mul_i2
co:4b90: 7c 07          :  mov R4,#((_uc_socket)>>8)&255
co:4b92: 7d 8a          :  mov R5,#(_uc_socket)&255
co:4b94: ed             :  mov A,R5
co:4b95: 2f             :  add A,R7
co:4b96: ff             :  mov R7,A
co:4b97: ec             :  mov A,R4
co:4b98: 3e             :  addc A,R6
co:4b99: fe             :  mov R6,A
                        :  ; variable 'psock' allocated as 'auto'
co:4b9a: 8e 31          :  mov ?close_socket_udp_psock,R6
co:4b9c: 8f 32          :  mov ?close_socket_udp_psock+1,R7
                        :>        xdata UC_SOCKET *psock;
                        :>        psock=&uc_socket[sock];
                        :>    // Copy Socket to Working Socket
                        :>    xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
co:4b9e: 7a 00          :  mov R2,#0
co:4ba0: 7b 32          :  mov R3,#50
co:4ba2: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:4ba4: 7d 0a          :  mov R5,#(_match_socket)&255
co:4ba6: ae 31          :  mov R6,?close_socket_udp_psock
co:4ba8: af 32          :  mov R7,?close_socket_udp_psock+1
co:4baa: 12 23 e5       :  lcall _xram_fast_copy
                        :>    if(match_socket.socket_type!=SOCKET_UDP || !match_socket.state) return EVENT_UDP_DENIED; // Closin
co:4bad: 90 00 0a       :  mov DPTR,#_match_socket
co:4bb0: e0             :  movx A,@DPTR
co:4bb1: ff             :  mov R7,A
co:4bb2: bf 01 07       :  cjne R7,#1,?262
co:4bb5: 90 00 0b       :  mov DPTR,#_match_socket+1
co:4bb8: e0             :  movx A,@DPTR
co:4bb9: ff             :  mov R7,A
co:4bba: 70 06          :  jnz ?260
                        : ?262:
                        : 
co:4bbc: 7e e4          :  mov R6,#228
co:4bbe: 7f 00          :  mov R7,#0
co:4bc0: 80 17          :  sjmp ?259
                        : ?260:
                        :>    match_socket.state=0;   // That's all to close...
co:4bc2: 90 00 0b       :  mov DPTR,#_match_socket+1
co:4bc5: e4             :  clr A
co:4bc6: f0             :  movx @DPTR,A
                        :>    // Copy back from MATCH_SOCKET and return
                        :>    xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:4bc7: 7a 00          :  mov R2,#0
co:4bc9: 7b 32          :  mov R3,#50
co:4bcb: ac 31          :  mov R4,?close_socket_udp_psock
co:4bcd: ad 32          :  mov R5,?close_socket_udp_psock+1
co:4bcf: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:4bd1: 7f 0a          :  mov R7,#(_match_socket)&255
co:4bd3: 12 23 e5       :  lcall _xram_fast_copy
                        :>    return 0; // All OK
co:4bd6: e4             :  clr A
co:4bd7: fe             :  mov R6,A
co:4bd8: ff             :  mov R7,A
                        : ?259:
co:4bd9: 22             :  ret
                        : ; end of function close_socket_udp
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .segment neardata, sclass dram
                        :  .export _rx_bd ; xdata oeth_bd *near rx_bd
                        : _rx_bd: ; xdata oeth_bd *near rx_bd
dr:0022: 00 00          :  .dc.w 0
                        :  .export _poll_net ; unsigned int poll_net(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __poll_net
                        : _poll_net: ; unsigned int poll_net(void)
                        :>}
                        :>#endif
                        :>
                        :>
                        :>extern xdata uchar* near pRxPtr;
                        :>xdata oeth_bd* near rx_bd=0;
                        :>
                        :>/**********************************************************************************
                        :>* uint poll_net(void)
                        :>* 
                        :>* Top-Level-Multiplexer, should be happy with SNAP frames too...
                        :>* Will return !=0 if Event was encountered
                        :>**********************************************************************************/
                        :>uint poll_net(void){
co:29cf: 90 d0 07       :  mov DPTR,#53255
co:29d2: e0             :  movx A,@DPTR
co:29d3: ff             :  mov R7,A
co:29d4: 54 10          :  anl A,#16
co:29d6: ff             :  mov R7,A
co:29d7: 60 09          :  jz ?264
                        :>uint type;
                        :>
                        :>  if(*INT_SOURCE & OETH_INT_BUSY) {
co:29d9: 12 4c 32       :  lcall _Init_Mac
                        :>     Init_Mac();
                        :>     rx_bd=0;
co:29dc: 75 22 00       :  mov _rx_bd,#0
co:29df: 75 23 00       :  mov _rx_bd+1,#0
                        :>  } 
                        : ?264:
                        :>  if(*INT_SOURCE & (OETH_INT_TXB|OETH_INT_TXE))  {
co:29e2: 90 d0 07       :  mov DPTR,#53255
co:29e5: e0             :  movx A,@DPTR
co:29e6: ff             :  mov R7,A
co:29e7: 54 03          :  anl A,#3
co:29e9: ff             :  mov R7,A
co:29ea: 60 0d          :  jz ?266
                        : 
co:29ec: 90 d4 00       :  mov DPTR,#54272
co:29ef: e4             :  clr A
co:29f0: f0             :  movx @DPTR,A
co:29f1: a3             :  inc DPTR
co:29f2: f0             :  movx @DPTR,A
                        :>    xdata oeth_bd* tx_bd= OETH_BD_BASE;
                        :>    tx_bd->u.ls.len    = 0;
                        :>    *INT_SOURCE=(OETH_INT_TXB|OETH_INT_TXE); // Clear Interrupt Flag      
co:29f3: 90 d0 07       :  mov DPTR,#53255
co:29f6: 74 03          :  mov A,#3
co:29f8: f0             :  movx @DPTR,A
                        :>  }
                        : ?266:
                        :>  if(*INT_SOURCE & (OETH_INT_RXF | OETH_INT_RXE)) 
co:29f9: 90 d0 07       :  mov DPTR,#53255
co:29fc: e0             :  movx A,@DPTR
co:29fd: ff             :  mov R7,A
co:29fe: 54 0c          :  anl A,#12
co:2a00: ff             :  mov R7,A
co:2a01: 70 03          :  jnz ?_134
co:2a03: 02 2b c3       :  ljmp ?268
                        : ?_134:
                        :>  {
co:2a06: e5 22          :  mov A,_rx_bd
co:2a08: 45 23          :  orl A,_rx_bd+1
co:2a0a: 70 16          :  jnz ?270
                        :> 
                        :>    if(!rx_bd) {
co:2a0c: 12 4b 48       :  lcall _find_RX_Buffer
co:2a0f: 8e 22          :  mov _rx_bd,R6
co:2a11: 8f 23          :  mov _rx_bd+1,R7
                        :>      rx_bd=find_RX_Buffer();
                        :>      if(!rx_bd) return 0;
co:2a13: e5 22          :  mov A,_rx_bd
co:2a15: 45 23          :  orl A,_rx_bd+1
co:2a17: 60 03          :  jz ?_136
co:2a19: 02 2a 9f       :  ljmp ?271
                        : ?_136:
                        : 
co:2a1c: e4             :  clr A
co:2a1d: fe             :  mov R6,A
co:2a1e: ff             :  mov R7,A
co:2a1f: 02 2c 4a       :  ljmp ?263
                        :>    }else  {
                        : ?270:
                        : 
co:2a22: e4             :  clr A
co:2a23: fb             :  mov R3,A
                        :  ; variable 'i' assigned to register 'R3'
co:2a24: 80 2c          :  sjmp ?275
                        : ?274:
                        :>      unsigned char i=0;
                        :>      while(i++<OETH_RXBD_NUM && (rx_bd->u.ls.status & OETH_RX_BD_EMPTY)) {
co:2a26: ae 22          :  mov R6,_rx_bd
co:2a28: af 23          :  mov R7,_rx_bd+1
co:2a2a: 74 08          :  mov A,#8
co:2a2c: 2f             :  add A,R7
co:2a2d: fd             :  mov R5,A
co:2a2e: e4             :  clr A
co:2a2f: 3e             :  addc A,R6
co:2a30: fc             :  mov R4,A
co:2a31: 8c 22          :  mov _rx_bd,R4
co:2a33: 8d 23          :  mov _rx_bd+1,R5
co:2a35: 7e d4          :  mov R6,#212
co:2a37: 7f a0          :  mov R7,#160
co:2a39: ed             :  mov A,R5
co:2a3a: 6f             :  xrl A,R7
co:2a3b: 70 04          :  jnz ?_137
co:2a3d: ec             :  mov A,R4
co:2a3e: 6e             :  xrl A,R6
co:2a3f: 60 02          :  jz ?_138
                        : ?_137:
co:2a41: 80 0f          :  sjmp ?277
                        : ?_138:
                        :>        if(++rx_bd==(xdata oeth_bd*)(OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd)+OETH_RXBD_NUM*sizeof(o
co:2a43: 7e d4          :  mov R6,#212
co:2a45: 7f 00          :  mov R7,#0
co:2a47: 74 08          :  mov A,#8
co:2a49: 2f             :  add A,R7
co:2a4a: ff             :  mov R7,A
co:2a4b: e4             :  clr A
co:2a4c: 3e             :  addc A,R6
co:2a4d: fe             :  mov R6,A
co:2a4e: 8e 22          :  mov _rx_bd,R6
co:2a50: 8f 23          :  mov _rx_bd+1,R7
                        :>          rx_bd=(xdata oeth_bd*)((uint)OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd));
                        :>        }
                        : ?277:
                        :>      }
                        : ?275:
                        : 
co:2a52: ad 03          :  mov R5,AR3
co:2a54: ab 05          :  mov R3,AR5
co:2a56: 0b             :  inc R3
co:2a57: 7f 04          :  mov R7,#4
co:2a59: c3             :  clr C
co:2a5a: e5 05          :  mov A,AR5
co:2a5c: 95 07          :  subb A,AR7
co:2a5e: 50 1e          :  jnc ?279
co:2a60: ae 22          :  mov R6,_rx_bd
co:2a62: af 23          :  mov R7,_rx_bd+1
co:2a64: 74 02          :  mov A,#2
co:2a66: 2f             :  add A,R7
co:2a67: ff             :  mov R7,A
co:2a68: e4             :  clr A
co:2a69: 3e             :  addc A,R6
co:2a6a: fe             :  mov R6,A
co:2a6b: 8e 83          :  mov DPH,R6
co:2a6d: 8f 82          :  mov DPL,R7
co:2a6f: 12 35 4c       :  lcall __ld_dptr_r67
co:2a72: 7f 00          :  mov R7,#0
co:2a74: 53 06 80       :  anl AR6,#128
co:2a77: ee             :  mov A,R6
co:2a78: 4f             :  orl A,R7
co:2a79: 60 03          :  jz ?_140
co:2a7b: 02 2a 26       :  ljmp ?274
                        : ?_140:
                        : ?279:
                        :>      if(rx_bd->u.ls.status & OETH_RX_BD_EMPTY) return 0;
co:2a7e: ae 22          :  mov R6,_rx_bd
co:2a80: af 23          :  mov R7,_rx_bd+1
co:2a82: 74 02          :  mov A,#2
co:2a84: 2f             :  add A,R7
co:2a85: ff             :  mov R7,A
co:2a86: e4             :  clr A
co:2a87: 3e             :  addc A,R6
co:2a88: fe             :  mov R6,A
co:2a89: 8e 83          :  mov DPH,R6
co:2a8b: 8f 82          :  mov DPL,R7
co:2a8d: 12 35 4c       :  lcall __ld_dptr_r67
co:2a90: 7f 00          :  mov R7,#0
co:2a92: 53 06 80       :  anl AR6,#128
co:2a95: ee             :  mov A,R6
co:2a96: 4f             :  orl A,R7
co:2a97: 60 06          :  jz ?280
                        : 
co:2a99: e4             :  clr A
co:2a9a: fe             :  mov R6,A
co:2a9b: ff             :  mov R7,A
co:2a9c: 02 2c 4a       :  ljmp ?263
                        : ?280:
                        :>    }
                        : ?271:
                        :>//    sevseg_data1=(uint)rx_bd&0xff;
                        :>//    sevseg_data0=(uint)rx_bd>>8;
                        :>    init_rx();
co:2a9f: 12 4e 19       :  lcall _init_rx
                        :>//    pRxPtr=(*((uint xdata*)(&rx_bd->addr)+1))|((uint)ETH_BUFFER_BASE);
                        :>
                        :>    Read_Frame_word_Phy(); // Skip OUR MAC... (6 Bytes)
co:2aa2: 12 47 50       :  lcall _Read_Frame_word_Phy
                        :>    Read_Frame_long_Phy();
co:2aa5: 12 3e aa       :  lcall _Read_Frame_long_Phy
                        :>    Read_Frame_xdata_Phy(&remote_mac[0],6); // Read Sender's MAC
co:2aa8: 7c 00          :  mov R4,#0
co:2aaa: 7d 06          :  mov R5,#6
co:2aac: 7e 02          :  mov R6,#((_remote_mac)>>8)&255
co:2aae: 7f 0a          :  mov R7,#(_remote_mac)&255
co:2ab0: 12 3c 3d       :  lcall _Read_Frame_xdata_Phy
                        :>    type=Read_Frame_word_Phy();
co:2ab3: 12 47 50       :  lcall _Read_Frame_word_Phy
                        :  ; variable 'type' allocated as 'auto'
co:2ab6: 8e 33          :  mov ?poll_net_type,R6
co:2ab8: 8f 34          :  mov ?poll_net_type+1,R7
                        :>//    sevseg_data1=type&0xff;
                        :>//    sevseg_data0=type>>8;
                        :>    
                        :>    if(type<=0x5DC){ // SNAP Frame! Eat LSAP-Ctrl-OUI and retry...
co:2aba: 7c 05          :  mov R4,#5
co:2abc: 7d dc          :  mov R5,#220
co:2abe: ae 33          :  mov R6,?poll_net_type
co:2ac0: af 34          :  mov R7,?poll_net_type+1
co:2ac2: d3             :  setb C
co:2ac3: ef             :  mov A,R7
co:2ac4: 9d             :  subb A,R5
co:2ac5: ee             :  mov A,R6
co:2ac6: 9c             :  subb A,R4
co:2ac7: 50 29          :  jnc ?282
                        : 
co:2ac9: 7e aa          :  mov R6,#170
co:2acb: 7f aa          :  mov R7,#170
co:2acd: 12 27 f7       :  lcall _net_match_uint
co:2ad0: ef             :  mov A,R7
co:2ad1: 60 06          :  jz ?284
                        :>     if(net_match_uint(0xAAAA)) return 0;
co:2ad3: e4             :  clr A
co:2ad4: fe             :  mov R6,A
co:2ad5: ff             :  mov R7,A
co:2ad6: 02 2c 4a       :  ljmp ?263
                        : ?284:
                        :>     if(net_match_ulong(0x3000000)) return 0;
co:2ad9: 7c 03          :  mov R4,#3
co:2adb: e4             :  clr A
co:2adc: fd             :  mov R5,A
co:2add: fe             :  mov R6,A
co:2ade: ff             :  mov R7,A
co:2adf: 12 24 d2       :  lcall _net_match_ulong
co:2ae2: ef             :  mov A,R7
co:2ae3: 60 06          :  jz ?286
                        : 
co:2ae5: e4             :  clr A
co:2ae6: fe             :  mov R6,A
co:2ae7: ff             :  mov R7,A
co:2ae8: 02 2c 4a       :  ljmp ?263
                        : ?286:
                        :>     type=Read_Frame_word_Phy(); // Read NEW type...
co:2aeb: 12 47 50       :  lcall _Read_Frame_word_Phy
co:2aee: 8e 33          :  mov ?poll_net_type,R6
co:2af0: 8f 34          :  mov ?poll_net_type+1,R7
                        :>    }
                        : ?282:
                        :  ; variable 'event' allocated as 'auto'
                        :>    {
co:2af2: e4             :  clr A
co:2af3: f5 35          :  mov ?poll_net_2_event,A
co:2af5: f5 36          :  mov ?poll_net_2_event+1,A
                        :>      uint event=0;  // no event
                        :>      // *** First stage input filter/multiplexer for received frames ***
                        :>      if(type==0x0806){ // This is an ARP-Frame!
co:2af7: ae 33          :  mov R6,?poll_net_type
co:2af9: af 34          :  mov R7,?poll_net_type+1
co:2afb: bf 06 0c       :  cjne R7,#6,?288
co:2afe: be 08 09       :  cjne R6,#8,?288
                        : 
co:2b01: 12 45 80       :  lcall _process_ARP
co:2b04: 8e 35          :  mov ?poll_net_2_event,R6
co:2b06: 8f 36          :  mov ?poll_net_2_event+1,R7
                        :>        event= process_ARP();
                        :>      }else if(type==0x800){ // IP Header!
co:2b08: 80 11          :  sjmp ?289
                        : ?288:
                        : 
co:2b0a: ae 33          :  mov R6,?poll_net_type
co:2b0c: af 34          :  mov R7,?poll_net_type+1
co:2b0e: bf 00 0a       :  cjne R7,#0,?290
co:2b11: be 08 07       :  cjne R6,#8,?290
                        : 
co:2b14: 12 3d a5       :  lcall _process_IP
co:2b17: 8e 35          :  mov ?poll_net_2_event,R6
co:2b19: 8f 36          :  mov ?poll_net_2_event+1,R7
                        :>        event= process_IP();   
                        :>      } // ignore unknown frames
                        : ?290:
                        : ?289:
                        :>      rx_bd->u.ls.len =0;
co:2b1b: e4             :  clr A
co:2b1c: fc             :  mov R4,A
co:2b1d: fd             :  mov R5,A
co:2b1e: ae 22          :  mov R6,_rx_bd
co:2b20: af 23          :  mov R7,_rx_bd+1
co:2b22: 8e 83          :  mov DPH,R6
co:2b24: 8f 82          :  mov DPL,R7
co:2b26: 12 34 e0       :  lcall __st_dptr_r45
                        :>      rx_bd->u.ls.status = (rx_bd->u.ls.status & OETH_RX_BD_WRAP) | OETH_RX_BD_EMPTY | OETH_RX_BD_IRQ;
co:2b29: 74 02          :  mov A,#2
co:2b2b: 25 23          :  add A,_rx_bd+1
co:2b2d: f5 09          :  mov AR9,A
co:2b2f: e4             :  clr A
co:2b30: 35 22          :  addc A,_rx_bd
co:2b32: f5 08          :  mov AR8,A
co:2b34: ae 08          :  mov R6,AR8
co:2b36: af 09          :  mov R7,AR9
co:2b38: 8e 83          :  mov DPH,R6
co:2b3a: 8f 82          :  mov DPL,R7
co:2b3c: 12 35 4c       :  lcall __ld_dptr_r67
co:2b3f: 7f 00          :  mov R7,#0
co:2b41: 53 06 20       :  anl AR6,#32
co:2b44: 43 06 80       :  orl AR6,#128
co:2b47: ef             :  mov A,R7
co:2b48: fd             :  mov R5,A
co:2b49: ee             :  mov A,R6
co:2b4a: 44 40          :  orl A,#64
co:2b4c: fc             :  mov R4,A
co:2b4d: ae 08          :  mov R6,AR8
co:2b4f: af 09          :  mov R7,AR9
co:2b51: 8e 83          :  mov DPH,R6
co:2b53: 8f 82          :  mov DPL,R7
co:2b55: 12 34 e0       :  lcall __st_dptr_r45
                        :>      // search for other filled rx buffers (circular buffer)
                        :>      type=(uint)rx_bd;
co:2b58: aa 22          :  mov R2,_rx_bd
co:2b5a: ab 23          :  mov R3,_rx_bd+1
                        :  ; variable 'type' assigned to register 'RW23'
                        :>      if(++rx_bd==(xdata oeth_bd*)((uint)OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd)+OETH_RXBD_NUM*size
co:2b5c: ae 22          :  mov R6,_rx_bd
co:2b5e: af 23          :  mov R7,_rx_bd+1
co:2b60: 74 08          :  mov A,#8
co:2b62: 2f             :  add A,R7
co:2b63: fd             :  mov R5,A
co:2b64: e4             :  clr A
co:2b65: 3e             :  addc A,R6
co:2b66: fc             :  mov R4,A
co:2b67: 8c 22          :  mov _rx_bd,R4
co:2b69: 8d 23          :  mov _rx_bd+1,R5
co:2b6b: 7e d4          :  mov R6,#212
co:2b6d: 7f 00          :  mov R7,#0
co:2b6f: 74 28          :  mov A,#40
co:2b71: 2f             :  add A,R7
co:2b72: ff             :  mov R7,A
co:2b73: e4             :  clr A
co:2b74: 3e             :  addc A,R6
co:2b75: fe             :  mov R6,A
co:2b76: ed             :  mov A,R5
co:2b77: 6f             :  xrl A,R7
co:2b78: 70 04          :  jnz ?_149
co:2b7a: ec             :  mov A,R4
co:2b7b: 6e             :  xrl A,R6
co:2b7c: 60 02          :  jz ?_150
                        : ?_149:
co:2b7e: 80 0f          :  sjmp ?292
                        : ?_150:
                        : 
co:2b80: 7e d4          :  mov R6,#212
co:2b82: 7f 00          :  mov R7,#0
co:2b84: 74 08          :  mov A,#8
co:2b86: 2f             :  add A,R7
co:2b87: ff             :  mov R7,A
co:2b88: e4             :  clr A
co:2b89: 3e             :  addc A,R6
co:2b8a: fe             :  mov R6,A
co:2b8b: 8e 22          :  mov _rx_bd,R6
co:2b8d: 8f 23          :  mov _rx_bd+1,R7
                        :>           rx_bd=(xdata oeth_bd*)((uint)OETH_BD_BASE+OETH_TXBD_NUM*sizeof(oeth_bd));
                        :>      }
                        : ?292:
                        :>      // Search for next filled RX-Buffer
                        :>      if (type==(uint)rx_bd || (rx_bd->u.ls.status & OETH_RX_BD_EMPTY)){
co:2b8f: ae 22          :  mov R6,_rx_bd
co:2b91: af 23          :  mov R7,_rx_bd+1
co:2b93: eb             :  mov A,R3
co:2b94: 6f             :  xrl A,R7
co:2b95: 70 04          :  jnz ?_151
co:2b97: ea             :  mov A,R2
co:2b98: 6e             :  xrl A,R6
co:2b99: 60 1b          :  jz ?296
                        : ?_151:
co:2b9b: ae 22          :  mov R6,_rx_bd
co:2b9d: af 23          :  mov R7,_rx_bd+1
co:2b9f: 74 02          :  mov A,#2
co:2ba1: 2f             :  add A,R7
co:2ba2: ff             :  mov R7,A
co:2ba3: e4             :  clr A
co:2ba4: 3e             :  addc A,R6
co:2ba5: fe             :  mov R6,A
co:2ba6: 8e 83          :  mov DPH,R6
co:2ba8: 8f 82          :  mov DPL,R7
co:2baa: 12 35 4c       :  lcall __ld_dptr_r67
co:2bad: 7f 00          :  mov R7,#0
co:2baf: 53 06 80       :  anl AR6,#128
co:2bb2: ee             :  mov A,R6
co:2bb3: 4f             :  orl A,R7
co:2bb4: 60 06          :  jz ?294
                        : ?296:
                        : 
co:2bb6: 90 d0 07       :  mov DPTR,#53255
co:2bb9: 74 0c          :  mov A,#12
co:2bbb: f0             :  movx @DPTR,A
                        :>        // no more filled buffers. Clear interrupt flag
                        :>        *INT_SOURCE=(OETH_INT_RXF | OETH_INT_RXE); // Clear Interrupt Flag
                        :>      }
                        : ?294:
                        :>      return event;
co:2bbc: ae 35          :  mov R6,?poll_net_2_event
co:2bbe: af 36          :  mov R7,?poll_net_2_event+1
co:2bc0: 02 2c 4a       :  ljmp ?263
                        : ?268:
                        :>    }
                        :> }else{
co:2bc3: e5 27          :  mov A,_net_timer
co:2bc5: 60 03          :  jz ?_153
co:2bc7: 02 2c 47       :  ljmp ?297
                        : ?_153:
                        :>  // Do soemthing periodically net_timer decremented 2 times per Sec!... 
                        :>  if(!net_timer){
co:2bca: 05 26          :  inc _net_service_cnt
                        :>        xdata UC_SOCKET *psock;
                        :>        uchar ui;
                        :>        uint res;
                        :>        net_service_cnt++;  // Sequence-Timer Highbyte
                        :>        net_timer=TIMER_FRQ/2; // about 0.5 Hz ONLY after one complete IDLE-pass...
co:2bcc: 75 27 0f       :  mov _net_timer,#15
                        :  ; variable 'psock' allocated as 'auto'
                        :>        psock=uc_socket;
co:2bcf: 75 33 07       :  mov ?poll_net_2_psock,#((_uc_socket)>>8)&255
co:2bd2: 75 34 8a       :  mov ?poll_net_2_psock+1,#(_uc_socket)&255
                        :  ; variable 'ui' allocated as 'auto'
                        :>        for(ui=0;ui<MAX_SOCK;ui++,psock++){
co:2bd5: e4             :  clr A
co:2bd6: f5 35          :  mov ?poll_net_2_ui,A
                        : ?299:
                        : 
co:2bd8: ae 33          :  mov R6,?poll_net_2_psock
co:2bda: af 34          :  mov R7,?poll_net_2_psock+1
co:2bdc: 0f             :  inc R7
co:2bdd: ef             :  mov A,R7
co:2bde: 70 01          :  jnz ?__5
co:2be0: 0e             :  inc R6
                        : ?__5:
co:2be1: 85 06 83       :  mov DPH,AR6
co:2be4: 85 07 82       :  mov DPL,AR7
co:2be7: e0             :  movx A,@DPTR
co:2be8: ff             :  mov R7,A
co:2be9: 60 3d          :  jz ?303
                        :>           if(psock->state){  // Examine only non-0-state-Sockets
co:2beb: 7a 00          :  mov R2,#0
co:2bed: 7b 32          :  mov R3,#50
co:2bef: 7c 00          :  mov R4,#((_match_socket)>>8)&255
co:2bf1: 7d 0a          :  mov R5,#(_match_socket)&255
co:2bf3: ae 33          :  mov R6,?poll_net_2_psock
co:2bf5: af 34          :  mov R7,?poll_net_2_psock+1
co:2bf7: 12 23 e5       :  lcall _xram_fast_copy
                        :>                // First copy to MATCH_SOCKET
                        :>                  xram_fast_copy((xdata uchar*)psock,(xdata uchar*)&match_socket,sizeof(UC_SOCKET));
                        :>                res=periodical_socket();     // Retry transmition... (Could be UDP for ARP as well...)
co:2bfa: 12 40 80       :  lcall _periodical_socket
                        :  ; variable 'res' allocated as 'auto'
co:2bfd: 8e 36          :  mov ?poll_net_2_res,R6
co:2bff: 8f 37          :  mov ?poll_net_2_res+1,R7
                        :>                // Copy back from MATCH_SOCKET and return
                        :>                  xram_fast_copy((xdata uchar*)&match_socket,(xdata uchar*)psock,sizeof(UC_SOCKET));
co:2c01: 7a 00          :  mov R2,#0
co:2c03: 7b 32          :  mov R3,#50
co:2c05: ac 33          :  mov R4,?poll_net_2_psock
co:2c07: ad 34          :  mov R5,?poll_net_2_psock+1
co:2c09: 7e 00          :  mov R6,#((_match_socket)>>8)&255
co:2c0b: 7f 0a          :  mov R7,#(_match_socket)&255
co:2c0d: 12 23 e5       :  lcall _xram_fast_copy
                        :>                if(res) return res+ui; // Return immediatelly if necessary
co:2c10: e5 36          :  mov A,?poll_net_2_res
co:2c12: 45 37          :  orl A,?poll_net_2_res+1
co:2c14: 60 12          :  jz ?305
                        : 
co:2c16: af 35          :  mov R7,?poll_net_2_ui
co:2c18: ad 07          :  mov R5,AR7
co:2c1a: 7c 00          :  mov R4,#0
co:2c1c: ae 36          :  mov R6,?poll_net_2_res
co:2c1e: af 37          :  mov R7,?poll_net_2_res+1
co:2c20: ed             :  mov A,R5
co:2c21: 2f             :  add A,R7
co:2c22: ff             :  mov R7,A
co:2c23: ec             :  mov A,R4
co:2c24: 3e             :  addc A,R6
co:2c25: fe             :  mov R6,A
co:2c26: 80 22          :  sjmp ?263
                        : ?305:
                        :>    }
                        : ?303:
                        :>   }
co:2c28: 05 35          :  inc ?poll_net_2_ui
co:2c2a: 74 32          :  mov A,#50
co:2c2c: 25 34          :  add A,?poll_net_2_psock+1
co:2c2e: f5 34          :  mov ?poll_net_2_psock+1,A
co:2c30: e4             :  clr A
co:2c31: 35 33          :  addc A,?poll_net_2_psock
co:2c33: f5 33          :  mov ?poll_net_2_psock,A
                        : 
co:2c35: 7d 02          :  mov R5,#2
co:2c37: af 35          :  mov R7,?poll_net_2_ui
co:2c39: c3             :  clr C
co:2c3a: ef             :  mov A,R7
co:2c3b: 9d             :  subb A,R5
co:2c3c: 50 03          :  jnc ?_156
co:2c3e: 02 2b d8       :  ljmp ?299
                        : ?_156:
                        :>   return EVENT_SOCKET_IDLETIMER; // About twice/sec
co:2c41: 7e d4          :  mov R6,#212
co:2c43: 7f 00          :  mov R7,#0
co:2c45: 80 03          :  sjmp ?263
                        : ?297:
                        :>  }
                        :>
                        :> }
co:2c47: e4             :  clr A
co:2c48: fe             :  mov R6,A
co:2c49: ff             :  mov R7,A
                        : ?263:
co:2c4a: 22             :  ret
                        : ; end of function poll_net
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:5 bytes
                        : 
                        : _irq_vector _irq_timer0int ,0xB,_timer0int
                        :   .segment _irq_timer0int,org 0xB
co:000b: 02 2c 4b       :   ljmp _timer0int
                        :   .hide
                        :  .export _timer0int ; void timer0int(void) interrupt
                        :  .segment _timer0int_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _timer0int_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _timer0int_formal_near, _timer0int_local_near, __timer0int
                        : 
                        :  .segment __timer0int
                        : _timer0int: ; (leaf function) void timer0int(void) interrupt
co:2c4b: c0 07          :  push 7
co:2c4d: c0 e0          :  push ACC
co:2c4f: c0 d0          :  push PSW
co:2c51: 53 d0 e7       :  anl PSW,#231
co:2c54: af 27          :  mov R7,_net_timer
co:2c56: ef             :  mov A,R7
co:2c57: 60 03          :  jz ?309
co:2c59: 1f             :  dec R7
co:2c5a: 8f 27          :  mov _net_timer,R7
                        : ?309:
co:2c5c: d0 d0          :  pop PSW
co:2c5e: d0 e0          :  pop ACC
co:2c60: d0 07          :  pop 7
co:2c62: 32             :  reti
                        : ; end of function timer0int
                        : ; used: R-------7 BR-------- ACC
                        : 
                        :  .export _Init_net ; unsigned char Init_net(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __Init_net
                        : _Init_net: ; unsigned char Init_net(void)
                        :> return 0; // NO EVENT
                        :>}
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* IRQ: The system timer. Count down net_timer, leave it if 0!
                        :>**********************************************************************************/
                        :>#pragma option -g0  // We don't want to have debug info in the interrupt
                        :>IRQ_VECTOR(timer0int,TIMER0)
                        :>void timer0int (void) interrupt  {
                        :> uchar h;
                        :> h=net_timer;
                        :> if(h) net_timer=(--h);
                        :>}
                        :>#pragma option -g   // Restore debug info level to default
                        :>
                        :>/**********************************************************************************
                        :>* uchar Init_net()
                        :>*
                        :>* Initialise Network, return 0 if OK, else ERROR
                        :>**********************************************************************************/
                        :>uchar Init_net(void){
co:2815: 12 4c 32       :  lcall _Init_Mac
co:2818: ef             :  mov A,R7
co:2819: 60 04          :  jz ?312
                        :>
                        :>#ifdef PHY_ETH
                        :>// xram_fast_copy(my_ip.bytes,my_mac+2,4); // Lower 4 Bytes: IP of this node
                        :>#endif 
                        :>
                        :> if(Init_Mac()) return 1; // ERROR (MAC set as global!)
co:281b: 7f 01          :  mov R7,#1
co:281d: 80 17          :  sjmp ?311
                        : ?312:
                        :>
                        :> // Use Timer 0 as TCP-Timer
                        :> EA=0;  // Disable all IRQ
co:281f: c2 af          :  clr _EA
                        :>
                        :> TMOD &=0xF0;
co:2821: 53 89 f0       :  anl _TMOD,#240
                        :> TMOD |=0x01; // 16 bit Prescaler: 28.125 Hz 
co:2824: 43 89 01       :  orl _TMOD,#1
                        :> TR0=1;  // Timer 0 RUN
co:2827: d2 8c          :  setb _TR0
                        :> ET0=1;
co:2829: d2 a9          :  setb _ET0
                        :>
                        :> EA=1;  // Enable all IRQ
co:282b: d2 af          :  setb _EA
                        :>#ifdef PHY_ETH
                        :> _wait_ms(100); // May needs a few msec until ready
co:282d: 7e 00          :  mov R6,#0
co:282f: 7f 64          :  mov R7,#100
co:2831: 12 1b 07       :  lcall __wait_ms
                        :>#endif
                        :> return 0; 
co:2834: e4             :  clr A
co:2835: ff             :  mov R7,A
                        : ?311:
co:2836: 22             :  ret
                        : ; end of function Init_net
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .segment bss, sclass xram, notext
                        :  .export _match_socket ; xdata UC_SOCKET match_socket
                        : _match_socket: ; xdata UC_SOCKET match_socket
xr:000a: xx xx xx xx xx :  .ds.b 50
xr:000f: xx xx xx xx xx :
xr:0014: xx xx xx xx xx :
xr:0019: xx xx xx xx xx :
xr:001e: xx xx xx xx xx :
xr:0023: xx xx xx xx xx :
xr:0028: xx xx xx xx xx :
xr:002d: xx xx xx xx xx :
xr:0032: xx xx xx xx xx :
xr:0037: xx xx xx xx xx :
                        :  .export _tx_buffers ; xdata unsigned char tx_buffers[4][101]
                        : _tx_buffers: ; xdata unsigned char tx_buffers[4][101]
xr:003c: xx xx xx xx xx :  .ds.b 404
xr:0041: xx xx xx xx xx :
xr:0046: xx xx xx xx xx :
xr:004b: xx xx xx xx xx :
xr:0050: xx xx xx xx xx :
xr:0055: xx xx xx xx xx :
xr:005a: xx xx xx xx xx :
xr:005f: xx xx xx xx xx :
xr:0064: xx xx xx xx xx :
xr:0069: xx xx xx xx xx :
xr:006e: xx xx xx xx xx :
xr:0073: xx xx xx xx xx :
xr:0078: xx xx xx xx xx :
xr:007d: xx xx xx xx xx :
xr:0082: xx xx xx xx xx :
xr:0087: xx xx xx xx xx :
xr:008c: xx xx xx xx xx :
xr:0091: xx xx xx xx xx :
xr:0096: xx xx xx xx xx :
xr:009b: xx xx xx xx xx :
xr:00a0: xx xx xx xx xx :
xr:00a5: xx xx xx xx xx :
xr:00aa: xx xx xx xx xx :
xr:00af: xx xx xx xx xx :
xr:00b4: xx xx xx xx xx :
xr:00b9: xx xx xx xx xx :
xr:00be: xx xx xx xx xx :
xr:00c3: xx xx xx xx xx :
xr:00c8: xx xx xx xx xx :
xr:00cd: xx xx xx xx xx :
xr:00d2: xx xx xx xx xx :
xr:00d7: xx xx xx xx xx :
xr:00dc: xx xx xx xx xx :
xr:00e1: xx xx xx xx xx :
xr:00e6: xx xx xx xx xx :
xr:00eb: xx xx xx xx xx :
xr:00f0: xx xx xx xx xx :
xr:00f5: xx xx xx xx xx :
xr:00fa: xx xx xx xx xx :
xr:00ff: xx xx xx xx xx :
xr:0104: xx xx xx xx xx :
xr:0109: xx xx xx xx xx :
xr:010e: xx xx xx xx xx :
xr:0113: xx xx xx xx xx :
xr:0118: xx xx xx xx xx :
xr:011d: xx xx xx xx xx :
xr:0122: xx xx xx xx xx :
xr:0127: xx xx xx xx xx :
xr:012c: xx xx xx xx xx :
xr:0131: xx xx xx xx xx :
xr:0136: xx xx xx xx xx :
xr:013b: xx xx xx xx xx :
xr:0140: xx xx xx xx xx :
xr:0145: xx xx xx xx xx :
xr:014a: xx xx xx xx xx :
xr:014f: xx xx xx xx xx :
xr:0154: xx xx xx xx xx :
xr:0159: xx xx xx xx xx :
xr:015e: xx xx xx xx xx :
xr:0163: xx xx xx xx xx :
xr:0168: xx xx xx xx xx :
xr:016d: xx xx xx xx xx :
xr:0172: xx xx xx xx xx :
xr:0177: xx xx xx xx xx :
xr:017c: xx xx xx xx xx :
xr:0181: xx xx xx xx xx :
xr:0186: xx xx xx xx xx :
xr:018b: xx xx xx xx xx :
xr:0190: xx xx xx xx xx :
xr:0195: xx xx xx xx xx :
xr:019a: xx xx xx xx xx :
xr:019f: xx xx xx xx xx :
xr:01a4: xx xx xx xx xx :
xr:01a9: xx xx xx xx xx :
xr:01ae: xx xx xx xx xx :
xr:01b3: xx xx xx xx xx :
xr:01b8: xx xx xx xx xx :
xr:01bd: xx xx xx xx xx :
xr:01c2: xx xx xx xx xx :
xr:01c7: xx xx xx xx xx :
xr:01cc: xx xx xx xx    :
                        :  .segment nearbss, sclass dram, notext
                        :  .export _net_service_cnt ; near unsigned char net_service_cnt
                        : _net_service_cnt: ; near unsigned char net_service_cnt
dr:0026: xx             :  .ds.b 1
                        :  .export _net_timer ; near unsigned char net_timer
                        : _net_timer: ; near unsigned char net_timer
dr:0027: xx             :  .ds.b 1
                        :  .segment bss, sclass xram, notext
                        :  .export _hframe ; xdata HFRAME hframe
                        : _hframe: ; xdata HFRAME hframe
xr:01d0: xx xx xx xx xx :  .ds.b 20
xr:01d5: xx xx xx xx xx :
xr:01da: xx xx xx xx xx :
xr:01df: xx xx xx xx xx :
                        :  .export _pseudo_hdr ; xdata PSEUDO_HDR pseudo_hdr
                        : _pseudo_hdr: ; xdata PSEUDO_HDR pseudo_hdr
xr:01e4: xx xx xx xx xx :  .ds.b 12
xr:01e9: xx xx xx xx xx :
xr:01ee: xx xx          :
                        :  .export _hhdr ; xdata IP_HDR hhdr
                        : _hhdr: ; xdata IP_HDR hhdr
xr:01f0: xx xx xx xx xx :  .ds.b 20
xr:01f5: xx xx xx xx xx :
xr:01fa: xx xx xx xx xx :
xr:01ff: xx xx xx xx xx :
                        :  .export _gateway_mac ; xdata unsigned char gateway_mac[6]
                        : _gateway_mac: ; xdata unsigned char gateway_mac[6]
xr:0204: xx xx xx xx xx :  .ds.b 6
xr:0209: xx             :
                        :  .export _remote_mac ; xdata unsigned char remote_mac[6]
                        : _remote_mac: ; xdata unsigned char remote_mac[6]
xr:020a: xx xx xx xx xx :  .ds.b 6
xr:020f: xx             :
                        :  .import _xram_fast_copy ; void xram_fast_copy(xdata unsigned char *, xdata unsigned char *, unsigned 
                        :  .import _ip_check_more ; unsigned int ip_check_more(xdata unsigned char *, unsigned int, unsigned int
                        :  .import _ip_check ; unsigned int ip_check(xdata unsigned char *, unsigned int)
                        :  .import _net_match_uint ; unsigned char net_match_uint(unsigned int)
                        :  .import _net_match_ulong ; unsigned char net_match_ulong(unsigned long)
                        :  .import _init_rx ; void init_rx(void)
                        :  .import _find_RX_Buffer ; xdata oeth_bd *find_RX_Buffer(void)
                        :  .import _Init_Mac ; unsigned char Init_Mac(void)
                        :  .import _Read_Frame_xdata_Phy ; void Read_Frame_xdata_Phy(xdata unsigned char *, unsigned int)
                        :  .import _Read_Frame_long_Phy ; unsigned long Read_Frame_long_Phy(void)
                        :  .import _Read_Frame_word_Phy ; unsigned int Read_Frame_word_Phy(void)
                        :  .import _Write_Frame_xdata_Phy ; void Write_Frame_xdata_Phy(xdata unsigned char *, unsigned int)
                        :  .import _Write_Frame_long_Phy ; void Write_Frame_long_Phy(unsigned long)
                        :  .import _Write_Frame_word_Phy ; void Write_Frame_word_Phy(unsigned int)
                        :  .import _CommitSend_Phy ; void CommitSend_Phy(void)
                        :  .import _RequestSend_Phy ; void RequestSend_Phy(unsigned int)
                        :  .export _rcv_len ; xdata unsigned int rcv_len
                        : _rcv_len: ; xdata unsigned int rcv_len
xr:0210: xx xx          :  .ds.b 2
                        :  .export _rcv_buf ; xdata unsigned char rcv_buf[1400]
                        : _rcv_buf: ; xdata unsigned char rcv_buf[1400]
xr:0212: xx xx xx xx xx :  .ds.b 1400
xr:0217: xx xx xx xx xx :
xr:021c: xx xx xx xx xx :
xr:0221: xx xx xx xx xx :
xr:0226: xx xx xx xx xx :
xr:022b: xx xx xx xx xx :
xr:0230: xx xx xx xx xx :
xr:0235: xx xx xx xx xx :
xr:023a: xx xx xx xx xx :
xr:023f: xx xx xx xx xx :
xr:0244: xx xx xx xx xx :
xr:0249: xx xx xx xx xx :
xr:024e: xx xx xx xx xx :
xr:0253: xx xx xx xx xx :
xr:0258: xx xx xx xx xx :
xr:025d: xx xx xx xx xx :
xr:0262: xx xx xx xx xx :
xr:0267: xx xx xx xx xx :
xr:026c: xx xx xx xx xx :
xr:0271: xx xx xx xx xx :
xr:0276: xx xx xx xx xx :
xr:027b: xx xx xx xx xx :
xr:0280: xx xx xx xx xx :
xr:0285: xx xx xx xx xx :
xr:028a: xx xx xx xx xx :
xr:028f: xx xx xx xx xx :
xr:0294: xx xx xx xx xx :
xr:0299: xx xx xx xx xx :
xr:029e: xx xx xx xx xx :
xr:02a3: xx xx xx xx xx :
xr:02a8: xx xx xx xx xx :
xr:02ad: xx xx xx xx xx :
xr:02b2: xx xx xx xx xx :
xr:02b7: xx xx xx xx xx :
xr:02bc: xx xx xx xx xx :
xr:02c1: xx xx xx xx xx :
xr:02c6: xx xx xx xx xx :
xr:02cb: xx xx xx xx xx :
xr:02d0: xx xx xx xx xx :
xr:02d5: xx xx xx xx xx :
xr:02da: xx xx xx xx xx :
xr:02df: xx xx xx xx xx :
xr:02e4: xx xx xx xx xx :
xr:02e9: xx xx xx xx xx :
xr:02ee: xx xx xx xx xx :
xr:02f3: xx xx xx xx xx :
xr:02f8: xx xx xx xx xx :
xr:02fd: xx xx xx xx xx :
xr:0302: xx xx xx xx xx :
xr:0307: xx xx xx xx xx :
xr:030c: xx xx xx xx xx :
xr:0311: xx xx xx xx xx :
xr:0316: xx xx xx xx xx :
xr:031b: xx xx xx xx xx :
xr:0320: xx xx xx xx xx :
xr:0325: xx xx xx xx xx :
xr:032a: xx xx xx xx xx :
xr:032f: xx xx xx xx xx :
xr:0334: xx xx xx xx xx :
xr:0339: xx xx xx xx xx :
xr:033e: xx xx xx xx xx :
xr:0343: xx xx xx xx xx :
xr:0348: xx xx xx xx xx :
xr:034d: xx xx xx xx xx :
xr:0352: xx xx xx xx xx :
xr:0357: xx xx xx xx xx :
xr:035c: xx xx xx xx xx :
xr:0361: xx xx xx xx xx :
xr:0366: xx xx xx xx xx :
xr:036b: xx xx xx xx xx :
xr:0370: xx xx xx xx xx :
xr:0375: xx xx xx xx xx :
xr:037a: xx xx xx xx xx :
xr:037f: xx xx xx xx xx :
xr:0384: xx xx xx xx xx :
xr:0389: xx xx xx xx xx :
xr:038e: xx xx xx xx xx :
xr:0393: xx xx xx xx xx :
xr:0398: xx xx xx xx xx :
xr:039d: xx xx xx xx xx :
xr:03a2: xx xx xx xx xx :
xr:03a7: xx xx xx xx xx :
xr:03ac: xx xx xx xx xx :
xr:03b1: xx xx xx xx xx :
xr:03b6: xx xx xx xx xx :
xr:03bb: xx xx xx xx xx :
xr:03c0: xx xx xx xx xx :
xr:03c5: xx xx xx xx xx :
xr:03ca: xx xx xx xx xx :
xr:03cf: xx xx xx xx xx :
xr:03d4: xx xx xx xx xx :
xr:03d9: xx xx xx xx xx :
xr:03de: xx xx xx xx xx :
xr:03e3: xx xx xx xx xx :
xr:03e8: xx xx xx xx xx :
xr:03ed: xx xx xx xx xx :
xr:03f2: xx xx xx xx xx :
xr:03f7: xx xx xx xx xx :
xr:03fc: xx xx xx xx xx :
xr:0401: xx xx xx xx xx :
xr:0406: xx xx xx xx xx :
xr:040b: xx xx xx xx xx :
xr:0410: xx xx xx xx xx :
xr:0415: xx xx xx xx xx :
xr:041a: xx xx xx xx xx :
xr:041f: xx xx xx xx xx :
xr:0424: xx xx xx xx xx :
xr:0429: xx xx xx xx xx :
xr:042e: xx xx xx xx xx :
xr:0433: xx xx xx xx xx :
xr:0438: xx xx xx xx xx :
xr:043d: xx xx xx xx xx :
xr:0442: xx xx xx xx xx :
xr:0447: xx xx xx xx xx :
xr:044c: xx xx xx xx xx :
xr:0451: xx xx xx xx xx :
xr:0456: xx xx xx xx xx :
xr:045b: xx xx xx xx xx :
xr:0460: xx xx xx xx xx :
xr:0465: xx xx xx xx xx :
xr:046a: xx xx xx xx xx :
xr:046f: xx xx xx xx xx :
xr:0474: xx xx xx xx xx :
xr:0479: xx xx xx xx xx :
xr:047e: xx xx xx xx xx :
xr:0483: xx xx xx xx xx :
xr:0488: xx xx xx xx xx :
xr:048d: xx xx xx xx xx :
xr:0492: xx xx xx xx xx :
xr:0497: xx xx xx xx xx :
xr:049c: xx xx xx xx xx :
xr:04a1: xx xx xx xx xx :
xr:04a6: xx xx xx xx xx :
xr:04ab: xx xx xx xx xx :
xr:04b0: xx xx xx xx xx :
xr:04b5: xx xx xx xx xx :
xr:04ba: xx xx xx xx xx :
xr:04bf: xx xx xx xx xx :
xr:04c4: xx xx xx xx xx :
xr:04c9: xx xx xx xx xx :
xr:04ce: xx xx xx xx xx :
xr:04d3: xx xx xx xx xx :
xr:04d8: xx xx xx xx xx :
xr:04dd: xx xx xx xx xx :
xr:04e2: xx xx xx xx xx :
xr:04e7: xx xx xx xx xx :
xr:04ec: xx xx xx xx xx :
xr:04f1: xx xx xx xx xx :
xr:04f6: xx xx xx xx xx :
xr:04fb: xx xx xx xx xx :
xr:0500: xx xx xx xx xx :
xr:0505: xx xx xx xx xx :
xr:050a: xx xx xx xx xx :
xr:050f: xx xx xx xx xx :
xr:0514: xx xx xx xx xx :
xr:0519: xx xx xx xx xx :
xr:051e: xx xx xx xx xx :
xr:0523: xx xx xx xx xx :
xr:0528: xx xx xx xx xx :
xr:052d: xx xx xx xx xx :
xr:0532: xx xx xx xx xx :
xr:0537: xx xx xx xx xx :
xr:053c: xx xx xx xx xx :
xr:0541: xx xx xx xx xx :
xr:0546: xx xx xx xx xx :
xr:054b: xx xx xx xx xx :
xr:0550: xx xx xx xx xx :
xr:0555: xx xx xx xx xx :
xr:055a: xx xx xx xx xx :
xr:055f: xx xx xx xx xx :
xr:0564: xx xx xx xx xx :
xr:0569: xx xx xx xx xx :
xr:056e: xx xx xx xx xx :
xr:0573: xx xx xx xx xx :
xr:0578: xx xx xx xx xx :
xr:057d: xx xx xx xx xx :
xr:0582: xx xx xx xx xx :
xr:0587: xx xx xx xx xx :
xr:058c: xx xx xx xx xx :
xr:0591: xx xx xx xx xx :
xr:0596: xx xx xx xx xx :
xr:059b: xx xx xx xx xx :
xr:05a0: xx xx xx xx xx :
xr:05a5: xx xx xx xx xx :
xr:05aa: xx xx xx xx xx :
xr:05af: xx xx xx xx xx :
xr:05b4: xx xx xx xx xx :
xr:05b9: xx xx xx xx xx :
xr:05be: xx xx xx xx xx :
xr:05c3: xx xx xx xx xx :
xr:05c8: xx xx xx xx xx :
xr:05cd: xx xx xx xx xx :
xr:05d2: xx xx xx xx xx :
xr:05d7: xx xx xx xx xx :
xr:05dc: xx xx xx xx xx :
xr:05e1: xx xx xx xx xx :
xr:05e6: xx xx xx xx xx :
xr:05eb: xx xx xx xx xx :
xr:05f0: xx xx xx xx xx :
xr:05f5: xx xx xx xx xx :
xr:05fa: xx xx xx xx xx :
xr:05ff: xx xx xx xx xx :
xr:0604: xx xx xx xx xx :
xr:0609: xx xx xx xx xx :
xr:060e: xx xx xx xx xx :
xr:0613: xx xx xx xx xx :
xr:0618: xx xx xx xx xx :
xr:061d: xx xx xx xx xx :
xr:0622: xx xx xx xx xx :
xr:0627: xx xx xx xx xx :
xr:062c: xx xx xx xx xx :
xr:0631: xx xx xx xx xx :
xr:0636: xx xx xx xx xx :
xr:063b: xx xx xx xx xx :
xr:0640: xx xx xx xx xx :
xr:0645: xx xx xx xx xx :
xr:064a: xx xx xx xx xx :
xr:064f: xx xx xx xx xx :
xr:0654: xx xx xx xx xx :
xr:0659: xx xx xx xx xx :
xr:065e: xx xx xx xx xx :
xr:0663: xx xx xx xx xx :
xr:0668: xx xx xx xx xx :
xr:066d: xx xx xx xx xx :
xr:0672: xx xx xx xx xx :
xr:0677: xx xx xx xx xx :
xr:067c: xx xx xx xx xx :
xr:0681: xx xx xx xx xx :
xr:0686: xx xx xx xx xx :
xr:068b: xx xx xx xx xx :
xr:0690: xx xx xx xx xx :
xr:0695: xx xx xx xx xx :
xr:069a: xx xx xx xx xx :
xr:069f: xx xx xx xx xx :
xr:06a4: xx xx xx xx xx :
xr:06a9: xx xx xx xx xx :
xr:06ae: xx xx xx xx xx :
xr:06b3: xx xx xx xx xx :
xr:06b8: xx xx xx xx xx :
xr:06bd: xx xx xx xx xx :
xr:06c2: xx xx xx xx xx :
xr:06c7: xx xx xx xx xx :
xr:06cc: xx xx xx xx xx :
xr:06d1: xx xx xx xx xx :
xr:06d6: xx xx xx xx xx :
xr:06db: xx xx xx xx xx :
xr:06e0: xx xx xx xx xx :
xr:06e5: xx xx xx xx xx :
xr:06ea: xx xx xx xx xx :
xr:06ef: xx xx xx xx xx :
xr:06f4: xx xx xx xx xx :
xr:06f9: xx xx xx xx xx :
xr:06fe: xx xx xx xx xx :
xr:0703: xx xx xx xx xx :
xr:0708: xx xx xx xx xx :
xr:070d: xx xx xx xx xx :
xr:0712: xx xx xx xx xx :
xr:0717: xx xx xx xx xx :
xr:071c: xx xx xx xx xx :
xr:0721: xx xx xx xx xx :
xr:0726: xx xx xx xx xx :
xr:072b: xx xx xx xx xx :
xr:0730: xx xx xx xx xx :
xr:0735: xx xx xx xx xx :
xr:073a: xx xx xx xx xx :
xr:073f: xx xx xx xx xx :
xr:0744: xx xx xx xx xx :
xr:0749: xx xx xx xx xx :
xr:074e: xx xx xx xx xx :
xr:0753: xx xx xx xx xx :
xr:0758: xx xx xx xx xx :
xr:075d: xx xx xx xx xx :
xr:0762: xx xx xx xx xx :
xr:0767: xx xx xx xx xx :
xr:076c: xx xx xx xx xx :
xr:0771: xx xx xx xx xx :
xr:0776: xx xx xx xx xx :
xr:077b: xx xx xx xx xx :
xr:0780: xx xx xx xx xx :
xr:0785: xx xx xx xx xx :
                        :  .export _uc_socket ; xdata UC_SOCKET uc_socket[2]
                        : _uc_socket: ; xdata UC_SOCKET uc_socket[2]
xr:078a: xx xx xx xx xx :  .ds.b 100
xr:078f: xx xx xx xx xx :
xr:0794: xx xx xx xx xx :
xr:0799: xx xx xx xx xx :
xr:079e: xx xx xx xx xx :
xr:07a3: xx xx xx xx xx :
xr:07a8: xx xx xx xx xx :
xr:07ad: xx xx xx xx xx :
xr:07b2: xx xx xx xx xx :
xr:07b7: xx xx xx xx xx :
xr:07bc: xx xx xx xx xx :
xr:07c1: xx xx xx xx xx :
xr:07c6: xx xx xx xx xx :
xr:07cb: xx xx xx xx xx :
xr:07d0: xx xx xx xx xx :
xr:07d5: xx xx xx xx xx :
xr:07da: xx xx xx xx xx :
xr:07df: xx xx xx xx xx :
xr:07e4: xx xx xx xx xx :
xr:07e9: xx xx xx xx xx :
                        :  .export _gateway_ip ; xdata IP_ADR gateway_ip
                        : _gateway_ip: ; xdata IP_ADR gateway_ip
xr:07ee: xx xx xx xx    :  .ds.b 4
                        :  .export _subnet_ip ; xdata IP_ADR subnet_ip
                        : _subnet_ip: ; xdata IP_ADR subnet_ip
xr:07f2: xx xx xx xx    :  .ds.b 4
                        :  .export _remote_ip ; xdata IP_ADR remote_ip
                        : _remote_ip: ; xdata IP_ADR remote_ip
xr:07f6: xx xx xx xx    :  .ds.b 4
                        :  .export _my_ip ; xdata IP_ADR my_ip
                        : _my_ip: ; xdata IP_ADR my_ip
xr:07fa: xx xx xx xx    :  .ds.b 4
                        :  .import _EA ; bit unsigned char EA
                        :  .import _ET0 ; bit unsigned char ET0
                        :  .import _TMOD ; near unsigned char TMOD
                        :  .import _TR0 ; bit unsigned char TR0
                        :  .import _bmove ; void bmove(far void *, far void *, unsigned int)
                        :  .import _strlen ; int strlen(far char *)
                        :  .import __wait_ms ; void _wait_ms(unsigned int) reentrant
                        :  .end
                        :>}
                        :>
                        :>
                        :>// END
=             _send_TCP =  40b7 (hex),  16567 (dez), text
=     _send_request_ARP =  3d05 (hex),  15621 (dez), text
=    _state_machine_TCP =  369e (hex),  13982 (dez), text
=            _timer0int =  2c4b (hex),  11339 (dez), text
=           _process_IP =  3da5 (hex),  15781 (dez), text
=             _Init_net =  2815 (hex),  10261 (dez), text
=    _send_match_ok_TCP =  41f1 (hex),  16881 (dez), text
=            _subnet_ip =   7f2 (hex),   2034 (dez), xram
=                _rx_bd =    22 (hex),     34 (dez), dram
=             _send_upd =  4767 (hex),  18279 (dez), text
=          _process_ARP =  4580 (hex),  17792 (dez), text
=           _remote_mac =   20a (hex),    522 (dez), xram
=           _pseudo_hdr =   1e4 (hex),    484 (dez), xram
=      _open_socket_udp =  49cb (hex),  18891 (dez), text
=  _final_timeout_socke =  3ec1 (hex),  16065 (dez), text
=                _my_ip =   7fa (hex),   2042 (dez), xram
=     _close_socket_udp =  4b88 (hex),  19336 (dez), text
=           _tx_bufleft =     6 (hex),      6 (dez), xram
=          _process_UDP =  4845 (hex),  18501 (dez), text
=            _net_timer =    27 (hex),     39 (dez), dram
=     _close_socket_tcp =  4ab9 (hex),  19129 (dez), text
=    _retransmit_socket =  3f78 (hex),  16248 (dez), text
=          _process_TCP =  4399 (hex),  17305 (dez), text
=         _match_socket =     a (hex),     10 (dez), xram
=  _send_incomming_rese =  3eec (hex),  16108 (dez), text
=            _remote_ip =   7f6 (hex),   2038 (dez), xram
=          _free_tx_buf =  3634 (hex),  13876 (dez), text
=          _gateway_mac =   204 (hex),    516 (dez), xram
=              _rcv_len =   210 (hex),    528 (dez), xram
=             _poll_net =  29cf (hex),  10703 (dez), text
=    _periodical_socket =  4080 (hex),  16512 (dez), text
=              _rcv_buf =   212 (hex),    530 (dez), xram
=           _tx_buffers =    3c (hex),     60 (dez), xram
=      _net_service_cnt =    26 (hex),     38 (dez), dram
=                 _hhdr =   1f0 (hex),    496 (dez), xram
=            _uc_socket =   78a (hex),   1930 (dez), xram
=         _process_ICMP =  427c (hex),  17020 (dez), text
=      _send_socket_udp =  4952 (hex),  18770 (dez), text
=           _gateway_ip =   7ee (hex),   2030 (dez), xram
=               _hframe =   1d0 (hex),    464 (dez), xram
=      _send_socket_tcp =  3a55 (hex),  14933 (dez), text
=    _free_match_socket =  3bee (hex),  15342 (dez), text
=               _my_mac =     0 (hex),      0 (dez), xram
=  _notready_socket_tcp =  3c86 (hex),  15494 (dez), text
=      _allocate_tx_buf =  3657 (hex),  13911 (dez), text

objectfile:tcpip\netutil.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'tcpip\netutil.c', time: Thu Dec 14 11:33:34 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :         .include <reg52.def>
                        : ; **** 80C52 (extended) defs ***
                        : 
                        :         .hide
                        :         .show
                        :  .export _memset ; void memset(xdata unsigned char *, char, unsigned int)
                        :  .segment _memset_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _memset_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _memset_formal_near, _memset_local_near, __memset
                        : 
                        :  .segment __memset
                        : _memset: ; (leaf function) void memset(xdata unsigned char *, char, unsigned int)
                        :  ; parameter 'size' in 'RW23'
                        :  ; parameter 'ch' in 'R5'
                        :  ; parameter 'pMem' in 'RW67' assigned to 'B1_RW89'
co:24ef: 8e 08          :  mov AR8,R6
co:24f1: 8f 09          :  mov AR9,R7
                        :>/**********************************************************************************
                        :>* Netutil.c
                        :>*
                        :>* Some TCP/IP utility functions
                        :>*
                        :>* V2.01 (C) 2004 WWW.WICKENHAEUSER.DE
                        :>*
                        :>* Please support us:
                        :>* ==================
                        :>* 
                        :>* The offer the uC/51-ANSI-C-Compiler at a very low price. So we do not have a
                        :>* large budget for advertisements. Every link to our Internet pages
                        :>* (WWW.WICKENHAEUSER.COM, WWW.WICKENHAEUSER.DE, WWW.FLEXGATE.COM, WWW.FLEXGATE.DE)
                        :>* is welcome! 
                        :>*
                        :>**********************************************************************************/
                        :>
                        :>
                        :>#include <stdio.h>
                        :>#include <reg52.h>
                        :>
                        :>#include "phy.h"                // Physical Layer
                        :>#include "netutil.h"            // Utilities
                        :>
                        :>
                        :>void memset(xdata uchar* pMem,char ch,uint size) {
co:24f3: 80 13          :  sjmp ?3
                        : ?2:
                        :>    while(size--) {
co:24f5: 85 08 83       :  mov DPH,AR8
co:24f8: 85 09 82       :  mov DPL,AR9
co:24fb: 74 01          :  mov A,#1
co:24fd: 25 82          :  add A,DPL
co:24ff: f5 09          :  mov AR9,A
co:2501: e4             :  clr A
co:2502: 35 83          :  addc A,DPH
co:2504: f5 08          :  mov AR8,A
co:2506: ed             :  mov A,R5
co:2507: f0             :  movx @DPTR,A
                        :>      *pMem++=ch;
                        :>    }  
                        : ?3:
                        : 
co:2508: ae 02          :  mov R6,AR2
co:250a: af 03          :  mov R7,AR3
co:250c: 74 ff          :  mov A,#255
co:250e: 2f             :  add A,R7
co:250f: fb             :  mov R3,A
co:2510: 74 ff          :  mov A,#255
co:2512: 3e             :  addc A,R6
co:2513: fa             :  mov R2,A
co:2514: ee             :  mov A,R6
co:2515: 4f             :  orl A,R7
co:2516: 70 dd          :  jnz ?2
co:2518: 22             :  ret
                        : ; end of function memset
                        : ; used: R0123-567 BR01------ DPTR ACC PSW
                        : 
                        :  .export _net_match_ulong ; unsigned char net_match_ulong(unsigned long)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __net_match_ulong
                        : _net_match_ulong: ; unsigned char net_match_ulong(unsigned long)
                        :  ; parameter 'm' in 'RL4567' moved and assigned to local '?net_match_ulong_m'
co:24d2: 74 37          :  mov A,#?net_match_ulong_m
co:24d4: 12 32 9c       :  lcall __st_a_r47
                        :>}
                        :>/*
                        :>void memset(xdata uchar* dest,char ch,uint size);
                        :>#asm
                        :>        .segment __memset
                        :>        .export _memset
                        :>_memset:
                        :>        ; dest in R6/R7
                        :>        ; ch in R5
                        :>        ; size in R3/R4
                        :>        mov A,R4        ; prepare to use 2 djnz
                        :>        jz ?xms1
                        :>        inc R3  
                        :>?xms1:  ; get from source byte
                        :>        mov DPL,R7
                        :>        mov DPH,R6
                        :>        mov a,r5
                        :>?xms2:
                        :>  movx @dptr,a
                        :>  inc dptr
                        :>        djnz R4,?xms2
                        :>        djnz R3,?xms2
                        :>        ret
                        :>#endasm*/
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* uchar net_match_ulong(unsigned long m)
                        :>* 
                        :>* function, that returns 0 only if the nrext read word from the Ethernet matches
                        :>* matches a fixed one
                        :>**********************************************************************************/
                        :>uchar net_match_ulong(unsigned long m){
co:24d7: 12 3e aa       :  lcall _Read_Frame_long_Phy
co:24da: 12 33 1a       :  lcall __movel_4_0
co:24dd: 74 37          :  mov A,#?net_match_ulong_m
co:24df: 12 33 44       :  lcall __ld_a_r47
co:24e2: c3             :  clr C
co:24e3: 12 34 08       :  lcall __cmp_i4
co:24e6: 60 04          :  jz ?6
                        :>        if(Read_Frame_long_Phy()!=m) return 1;
co:24e8: 7f 01          :  mov R7,#1
co:24ea: 80 02          :  sjmp ?5
                        : ?6:
                        :>        return 0;       // MATCH!
co:24ec: e4             :  clr A
co:24ed: ff             :  mov R7,A
                        : ?5:
co:24ee: 22             :  ret
                        : ; end of function net_match_ulong
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:4 bytes
                        : 
                        :  .export _net_match_uint ; unsigned char net_match_uint(unsigned int)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __net_match_uint
                        : _net_match_uint: ; unsigned char net_match_uint(unsigned int)
                        :  ; parameter 'm' in 'RW67' moved and assigned to local '?net_match_uint_m'
co:27f7: 8e 3d          :  mov ?net_match_uint_m,R6
co:27f9: 8f 3e          :  mov ?net_match_uint_m+1,R7
                        :>}
                        :>/**********************************************************************************
                        :>* uchar net_match_uint(uint m){
                        :>* 
                        :>* function, that returns 0 only if the next read long from the Ethernet matches
                        :>* matches a fixed one
                        :>**********************************************************************************/
                        :>uchar net_match_uint(uint m){
co:27fb: 12 47 50       :  lcall _Read_Frame_word_Phy
co:27fe: ac 06          :  mov R4,AR6
co:2800: ad 07          :  mov R5,AR7
co:2802: ae 3d          :  mov R6,?net_match_uint_m
co:2804: af 3e          :  mov R7,?net_match_uint_m+1
co:2806: ef             :  mov A,R7
co:2807: 6d             :  xrl A,R5
co:2808: 70 04          :  jnz ?_3
co:280a: ee             :  mov A,R6
co:280b: 6c             :  xrl A,R4
co:280c: 60 04          :  jz ?9
                        : ?_3:
                        :>        if(Read_Frame_word_Phy()!=m) return 1;
co:280e: 7f 01          :  mov R7,#1
co:2810: 80 02          :  sjmp ?8
                        : ?9:
                        :>        return 0;       // MATCH!
co:2812: e4             :  clr A
co:2813: ff             :  mov R7,A
                        : ?8:
co:2814: 22             :  ret
                        : ; end of function net_match_uint
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :         .segment __ip_check
                        :         .export _ip_check, _ip_check_more
                        : _ip_check:              ; Adr: R6:R7, len: R4:R5, tmp: B
co:27c1: e4             :         clr A           ; R6:7 working reg. (delayed in R2:3)
co:27c2: fa             :         mov R2,A
co:27c3: fb             :         mov R3,A
                        : 
                        : _ip_check_more:         ; Adr: R6:R7, len: R4:R5, tmp: B, old_cs in R2:R3
co:27c4: 8f 82          :         mov DPL,R7
co:27c6: 8e 83          :         mov DPH,R6
co:27c8: ae 02          :         mov R6,2        ; CS Working register, copy from R2
co:27ca: af 03          :         mov R7,3        ; R3
co:27cc: 75 f0 00       :         mov B,#0        ;
co:27cf: ec             :         mov A,R4        ; omit 0 words len
co:27d0: 4d             :         orl A,R5
co:27d1: 60 23          :         jz ?csx
co:27d3: ed             :         mov A,R5        ; prepare to use 2 djnz
co:27d4: 60 01          :         jz ?cs1
co:27d6: 0c             :         inc R4
co:27d7: e0             : ?cs1:   movx A,@DPTR
co:27d8: a3             :         inc DPTR
co:27d9: 30 f0 0b       :         jnb B.0,?csh
co:27dc: 2f             :         add A,R7
co:27dd: ff             :         mov R7,A
co:27de: 50 10          :         jnc ?cs2
co:27e0: 0e             :         inc R6
co:27e1: ee             :         mov A,R6
co:27e2: 70 0c          :         jnz ?cs2
co:27e4: 0f             :         inc R7
co:27e5: 80 09          :         sjmp ?cs2
co:27e7: 2e             : ?csh:   add A,R6
co:27e8: fe             :         mov R6,A
co:27e9: 50 05          :         jnc ?cs2
co:27eb: 0f             :         inc R7
co:27ec: ef             :         mov A,R7
co:27ed: 70 01          :         jnz ?cs2
co:27ef: 0e             :         inc R6
co:27f0: 05 f0          : ?cs2:   inc B
co:27f2: dd e3          :         djnz R5,?cs1
co:27f4: dc e1          :         djnz R4,?cs1
                        : ?csx:
co:27f6: 22             :         ret
                        :         .segment __xram_fast_copy
                        :         .export _xram_fast_copy
                        : _xram_fast_copy:
                        :         ; src in R6/R7
                        :         ; dest in R4/R5
                        :         ; len in R2/R3
co:23e5: eb             :         mov A,R3        ; prepare to use 2 djnz
co:23e6: 60 01          :         jz ?xfc1
co:23e8: 0a             :         inc R2
                        : ?xfc1:  ; get from source byte
co:23e9: 8f 82          :         mov DPL,R7
co:23eb: 8e 83          :         mov DPH,R6
co:23ed: e0             :         movx A,@DPTR
co:23ee: a3             :         inc DPTR
co:23ef: af 82          :         mov R7,DPL
co:23f1: ae 83          :         mov R6,DPH
                        :         ; write to dest byte
co:23f3: 8d 82          :         mov DPL,R5
co:23f5: 8c 83          :         mov DPH,R4
co:23f7: f0             :         movx @DPTR,A
co:23f8: a3             :         inc DPTR
co:23f9: ad 82          :         mov R5,DPL
co:23fb: ac 83          :         mov R4,DPH
                        :         ; loop
co:23fd: db ea          :         djnz R3,?xfc1
co:23ff: da e8          :         djnz R2,?xfc1
co:2401: 22             :         ret
                        :  .import _Read_Frame_long_Phy ; unsigned long Read_Frame_long_Phy(void)
                        :  .import _Read_Frame_word_Phy ; unsigned int Read_Frame_word_Phy(void)
                        :  .end
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* unsigned int ip_check(xdata uchar* ps, uint len);
                        :>* unsigned int ip_check_more(xdata uchar* ps, uint len, uint old_cs);
                        :>*
                        :>* Calculate an IP Checksum of Xram Block Block , 
                        :>* Used Assembler: This is really FAST! 
                        :>* ip_check_more: Takes a given CS and adds some more bytes. This is necessary
                        :>* for TCP-segments (and optional UDP too), if data are not in a continous block...
                        :>* ip_check_more is only allowed if previously an even number of bytes was read...
                        :>**********************************************************************************/
                        :>#asm
                        :>        .segment __ip_check
                        :>        .export _ip_check, _ip_check_more
                        :>_ip_check:              ; Adr: R6:R7, len: R4:R5, tmp: B
                        :>        clr A           ; R6:7 working reg. (delayed in R2:3)
                        :>        mov R2,A
                        :>        mov R3,A
                        :>
                        :>_ip_check_more:         ; Adr: R6:R7, len: R4:R5, tmp: B, old_cs in R2:R3
                        :>        mov DPL,R7
                        :>        mov DPH,R6
                        :>        mov R6,2        ; CS Working register, copy from R2
                        :>        mov R7,3        ; R3
                        :>        mov B,#0        ; 
                        :>        mov A,R4        ; omit 0 words len
                        :>        orl A,R5
                        :>        jz ?csx
                        :>        mov A,R5        ; prepare to use 2 djnz
                        :>        jz ?cs1
                        :>        inc R4  
                        :>?cs1:   movx A,@DPTR
                        :>        inc DPTR
                        :>        jnb B.0,?csh
                        :>        add A,R7
                        :>        mov R7,A
                        :>        jnc ?cs2
                        :>        inc R6
                        :>        mov A,R6
                        :>        jnz ?cs2
                        :>        inc R7
                        :>        sjmp ?cs2
                        :>?csh:   add A,R6
                        :>        mov R6,A
                        :>        jnc ?cs2
                        :>        inc R7
                        :>        mov A,R7
                        :>        jnz ?cs2
                        :>        inc R6
                        :>?cs2:   inc B
                        :>        djnz R5,?cs1    
                        :>        djnz R4,?cs1    
                        :>?csx:   
                        :>        ret
                        :>#endasm
                        :>
                        :>/**********************************************************************************
                        :>* void xram_fast_copy(xdata uchar* src,xdata uchar* dest,uint size);
                        :>* 
                        :>* Copy size data in XRAM
                        :>**********************************************************************************/
                        :>void xram_fast_copy(xdata uchar* src,xdata uchar* dest,uint size);
                        :>#asm
                        :>        .segment __xram_fast_copy
                        :>        .export _xram_fast_copy
                        :>_xram_fast_copy:
                        :>        ; src in R6/R7
                        :>        ; dest in R4/R5
                        :>        ; len in R2/R3
                        :>        mov A,R3        ; prepare to use 2 djnz
                        :>        jz ?xfc1
                        :>        inc R2  
                        :>?xfc1:  ; get from source byte
                        :>        mov DPL,R7
                        :>        mov DPH,R6
                        :>        movx A,@DPTR
                        :>        inc DPTR
                        :>        mov R7,DPL
                        :>        mov R6,DPH
                        :>        ; write to dest byte
                        :>        mov DPL,R5
                        :>        mov DPH,R4
                        :>        movx @DPTR,A
                        :>        inc DPTR
                        :>        mov R5,DPL
                        :>        mov R4,DPH
                        :>        ; loop
                        :>        djnz R3,?xfc1
                        :>        djnz R2,?xfc1
                        :>        ret
                        :>#endasm
                        :>
                        :>// END
=      _net_match_ulong =  24d2 (hex),   9426 (dez), text
=             _ip_check =  27c1 (hex),  10177 (dez), text
=       _net_match_uint =  27f7 (hex),  10231 (dez), text
=        _ip_check_more =  27c4 (hex),  10180 (dez), text
=       _xram_fast_copy =  23e5 (hex),   9189 (dez), text
=               _memset =  24ef (hex),   9455 (dez), text

objectfile:tcpip\web_serv.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'tcpip\web_serv.c', time: Thu Dec 14 11:33:34 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :         .include <reg52.def>
                        : ; **** 80C52 (extended) defs ***
                        : 
                        :         .hide
                        :         .show
                        :  .segment lit
                        :  .export _html_notfound ; code unsigned char html_notfound[]
                        : _html_notfound: ; code unsigned char html_notfound[]
co:22a8: 48 54 54 50 2f :  .dc.b "HTTP/1.0 200 OK",13,10,"Content-Type: text/html",13,10,"C"
co:22ad: 31 2e 30 20 32 :
co:22b2: 30 30 20 4f 4b :
co:22b7: 0d 0a 43 6f 6e :
co:22bc: 74 65 6e 74 2d :
co:22c1: 54 79 70 65 3a :
co:22c6: 20 74 65 78 74 :
co:22cb: 2f 68 74 6d 6c :
co:22d0: 0d 0a 43       :
co:22d3: 6f 6e 6e 65 63 :  .dc.b "onnection: close",13,10,13,10,"<html><head><title>Elekto"
co:22d8: 74 69 6f 6e 3a :
co:22dd: 20 63 6c 6f 73 :
co:22e2: 65 0d 0a 0d 0a :
co:22e7: 3c 68 74 6d 6c :
co:22ec: 3e 3c 68 65 61 :
co:22f1: 64 3e 3c 74 69 :
co:22f6: 74 6c 65 3e 45 :
co:22fb: 6c 65 6b 74 6f :
co:2300: 72 20 46 50 47 :  .dc.b "r FPGA Webserver</title></head><body text=",34,"#0000FF",34
co:2305: 41 20 57 65 62 :
co:230a: 73 65 72 76 65 :
co:230f: 72 3c 2f 74 69 :
co:2314: 74 6c 65 3e 3c :
co:2319: 2f 68 65 61 64 :
co:231e: 3e 3c 62 6f 64 :
co:2323: 79 20 74 65 78 :
co:2328: 74 3d 22 23 30 :
co:232d: 30 30 30 46 46 :
co:2332: 22             :
co:2333: 20 62 67 63 6f :  .dc.b " bgcolor=",34,"#FFFF80",34," link=",34,"#FF0000",34,">Elekt"
co:2338: 6c 6f 72 3d 22 :
co:233d: 23 46 46 46 46 :
co:2342: 38 30 22 20 6c :
co:2347: 69 6e 6b 3d 22 :
co:234c: 23 46 46 30 30 :
co:2351: 30 30 22 3e 45 :
co:2356: 6c 65 6b 74    :
co:235a: 6f 72 20 46 50 :  .dc.b "or FPGA Webserver - Page not found</body></html>",13,10,0
co:235f: 47 41 20 57 65 :
co:2364: 62 73 65 72 76 :
co:2369: 65 72 20 2d 20 :
co:236e: 50 61 67 65 20 :
co:2373: 6e 6f 74 20 66 :
co:2378: 6f 75 6e 64 3c :
co:237d: 2f 62 6f 64 79 :
co:2382: 3e 3c 2f 68 74 :
co:2387: 6d 6c 3e 0d 0a :
co:238c: 00             :
                        :  .segment data, sclass xram
                        :  .export _csock ; xdata unsigned char csock
                        : _csock: ; xdata unsigned char csock
xr:0007: ff             :  .dc.b 255
                        :  .export _gendyn_html ; unsigned int gendyn_html(xdata HTTP_INFO *, xdata unsigned char *)
                        :  .segment _gendyn_html_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _gendyn_html_local_near, size 3, fill, notext, sclass dram
                        :  .sgraph _gendyn_html_formal_near, _gendyn_html_local_near, __gendyn_html
                        : ?gendyn_html_df = _gendyn_html_local_near+2 ; unsigned char
                        : ?gendyn_html_pinfo = _gendyn_html_local_near+0 ; xdata HTTP_INFO *
                        : 
                        :  .segment __gendyn_html
                        : _gendyn_html: ; (leaf function) unsigned int gendyn_html(xdata HTTP_INFO *, xdata unsigned char *)
                        :  ; parameter 'pbuf' in 'RW45' assigned to 'B1_RW89'
                        :  ; parameter 'pinfo' in 'RW67' moved and assigned to local '?gendyn_html_pinfo'
co:2110: 8e 35          :  mov ?gendyn_html_pinfo,R6
co:2112: 8f 36          :  mov ?gendyn_html_pinfo+1,R7
co:2114: 8c 08          :  mov AR8,R4
co:2116: 8d 09          :  mov AR9,R5
                        :>/*********************************************************************************
                        :>* Web_serv.C
                        :>* 
                        :>* Webserver_Layer
                        :>* The Webserver is a top-layer of poll_net()
                        :>*
                        :>* V2.01 (C) 2004 WWW.WICKENHAEUSER.DE
                        :>*
                        :>* Please support us:
                        :>* ==================
                        :>* 
                        :>* The offer the uC/51-ANSI-C-Compiler at a very low price. So we do not have a
                        :>* large budget for advertisements. Every link to our Internet pages
                        :>* (WWW.WICKENHAEUSER.COM, WWW.WICKENHAEUSER.DE, WWW.FLEXGATE.COM, WWW.FLEXGATE.DE)
                        :>* is welcome! 
                        :>*
                        :>**********************************************************************************/
                        :>
                        :>#include <stdio.h>
                        :>#include <string.h>     
                        :>
                        :>#include <reg52.h>
                        :>
                        :>#include "net.h"                // Basic network handling (public)
                        :>#include "web_serv.h"           // Webserver
                        :>
                        :>// This is the Default Message. Using code 200 displays OUR page, whereas 404 may display a Browser's 
                        :>code uchar html_notfound[] = {
                        :>"HTTP/1.0 200 OK\r\n"
                        :>"Content-Type: text/html\r\n"
                        :>"Connection: close\r\n"
                        :>"\r\n"
                        :>"<html><head><title>Elektor FPGA Webserver</title></head>"
                        :>"<body text=\"#0000FF\" bgcolor=\"#FFFF80\" link=\"#FF0000\">"
                        :>"Elektor FPGA Webserver - Page not found"
                        :>"</body></html>\r\n"
                        :>};
                        :>
                        :>// Here the HTTP state machine is managed
                        :>HTTP_INFO http_info[MAX_SOCK];  
                        :>
                        :>xdata uchar *web_args; // static internal variable, points to start of first argument
                        :>
                        :>uchar csock=0xFF;       //   static internal variable, Current-Socket Index if !0xFF
                        :>
                        :>/**********************************************************************************
                        :>* uint gendyn_data(xdata HTTP_INFO *pinfo, xdata uchar *pbuf)
                        :>*
                        :>* Fill given buffer with dynamic data, return size (max MAX_TX)
                        :>**********************************************************************************/
                        :>uint gendyn_html(xdata HTTP_INFO *pinfo, xdata uchar *pbuf){
co:2118: ae 35          :  mov R6,?gendyn_html_pinfo
co:211a: af 36          :  mov R7,?gendyn_html_pinfo+1
co:211c: 74 02          :  mov A,#2
co:211e: 2f             :  add A,R7
co:211f: ff             :  mov R7,A
co:2120: e4             :  clr A
co:2121: 3e             :  addc A,R6
co:2122: fe             :  mov R6,A
co:2123: 8e 83          :  mov DPH,R6
co:2125: 8f 82          :  mov DPL,R7
co:2127: 12 35 4c       :  lcall __ld_dptr_r67
                        :  ; variable 'psrc' assigned to register 'B1_RW1213'
co:212a: 8e 0c          :  mov AR12,R6
co:212c: 8f 0d          :  mov AR13,R7
                        :>        uint leftos;            // Left to send or process
                        :>        uint cnt;               // No. of data to send
                        :>        uint rlen;
                        :>
                        :>        xdata uchar *dsrc;
                        :>
                        :>        code uchar *psrc;       // Source is in pinfo
                        :>        uchar df;
                        :>        uchar c;
                        :>
                        :>        psrc=pinfo->pweb;
                        :>        leftos=pinfo->weblen;
co:212e: ae 35          :  mov R6,?gendyn_html_pinfo
co:2130: af 36          :  mov R7,?gendyn_html_pinfo+1
co:2132: 74 04          :  mov A,#4
co:2134: 2f             :  add A,R7
co:2135: ff             :  mov R7,A
co:2136: e4             :  clr A
co:2137: 3e             :  addc A,R6
co:2138: fe             :  mov R6,A
co:2139: 8e 83          :  mov DPH,R6
co:213b: 8f 82          :  mov DPL,R7
co:213d: 12 35 4c       :  lcall __ld_dptr_r67
                        :  ; variable 'leftos' assigned to register 'B1_RW1415'
co:2140: 8e 0e          :  mov AR14,R6
co:2142: 8f 0f          :  mov AR15,R7
                        :>        df=pinfo->dyna_flag;
co:2144: ae 35          :  mov R6,?gendyn_html_pinfo
co:2146: af 36          :  mov R7,?gendyn_html_pinfo+1
co:2148: 0f             :  inc R7
co:2149: ef             :  mov A,R7
co:214a: 70 01          :  jnz ?__1
co:214c: 0e             :  inc R6
                        : ?__1:
co:214d: 85 06 83       :  mov DPH,AR6
co:2150: 85 07 82       :  mov DPL,AR7
co:2153: e0             :  movx A,@DPTR
co:2154: ff             :  mov R7,A
                        :  ; variable 'df' allocated as 'auto'
co:2155: 8f 37          :  mov ?gendyn_html_df,R7
                        :  ; variable 'cnt' assigned to register 'B1_RW1011'
                        :>        cnt=0;
co:2157: e4             :  clr A
co:2158: f5 0a          :  mov AR10,A
co:215a: f5 0b          :  mov AR11,A
co:215c: 02 22 6e       :  ljmp ?8
                        : ?7:
                        :>        while(leftos){
co:215f: 85 0c 83       :  mov DPH,AR12
co:2162: 85 0d 82       :  mov DPL,AR13
co:2165: e4             :  clr A
co:2166: 93             :  movc A,@A+DPTR
co:2167: ff             :  mov R7,A
                        :  ; variable 'c' assigned to register 'B '
co:2168: 8f f0          :  mov B,R7
                        :>                c=*psrc;
                        :>                psrc++;
co:216a: 05 0d          :  inc AR13
co:216c: e5 0d          :  mov A,AR13
co:216e: 70 02          :  jnz ?_1
co:2170: 05 0c          :  inc AR12
                        : ?_1:
                        :>                leftos--;
co:2172: e5 0f          :  mov A,AR15
co:2174: 15 0f          :  dec AR15
co:2176: 70 02          :  jnz ?_2
co:2178: 15 0e          :  dec AR14
                        : ?_2:
                        :>                if(df && c==255){       // Dynamic Sentinel
co:217a: e5 37          :  mov A,?gendyn_html_df
co:217c: 70 03          :  jnz ?_3
co:217e: 02 22 4a       :  ljmp ?10
                        : ?_3:
co:2181: 74 ff          :  mov A,#255
co:2183: 65 f0          :  xrl A,B
co:2185: 60 03          :  jz ?_4
co:2187: 02 22 4a       :  ljmp ?10
                        : ?_4:
                        : 
co:218a: ae 0c          :  mov R6,AR12
co:218c: af 0d          :  mov R7,AR13
co:218e: 8e 83          :  mov DPH,R6
co:2190: 8f 82          :  mov DPL,R7
co:2192: 12 32 0e       :  lcall __ldc_dptr_r45
                        :  ; variable 'dsrc' assigned to register 'RW45'
                        :>
                        :>                        dsrc= (xdata uchar*)(*(code uint*)psrc);
                        :>                        rlen=0;
co:2195: e4             :  clr A
co:2196: f8             :  mov R0,A
co:2197: f9             :  mov R1,A
                        :  ; variable 'rlen' assigned to register 'RW01'
co:2198: 80 05          :  sjmp ?13
                        : ?12:
                        :>                        while(*dsrc++) rlen++;  // Calc. Stringlen of variable          
co:219a: 09             :  inc R1
co:219b: e9             :  mov A,R1
co:219c: 70 01          :  jnz ?__2
co:219e: 08             :  inc R0
                        : ?__2:
                        : ?13:
                        : 
co:219f: 8c 83          :  mov DPH,R4
co:21a1: 8d 82          :  mov DPL,R5
co:21a3: ae 83          :  mov R6,DPH
co:21a5: af 82          :  mov R7,DPL
co:21a7: 74 01          :  mov A,#1
co:21a9: 2f             :  add A,R7
co:21aa: fd             :  mov R5,A
co:21ab: e4             :  clr A
co:21ac: 3e             :  addc A,R6
co:21ad: fc             :  mov R4,A
co:21ae: e0             :  movx A,@DPTR
co:21af: ff             :  mov R7,A
co:21b0: 70 e8          :  jnz ?12
                        :>
                        :>                        if(rlen>MAX_TX) rlen=MAX_TX;    // Clip too long variables to max. segment siz
co:21b2: 7e 00          :  mov R6,#0
co:21b4: 7f 64          :  mov R7,#100
co:21b6: d3             :  setb C
co:21b7: e9             :  mov A,R1
co:21b8: 9f             :  subb A,R7
co:21b9: e8             :  mov A,R0
co:21ba: 9e             :  subb A,R6
co:21bb: 40 04          :  jc ?15
                        : 
co:21bd: 78 00          :  mov R0,#0
co:21bf: 79 64          :  mov R1,#100
                        : ?15:
                        :>
                        :>                        if(rlen+cnt>MAX_TX){    // Current data + Variable: Too much!
co:21c1: e5 0b          :  mov A,AR11
co:21c3: 29             :  add A,R1
co:21c4: fb             :  mov R3,A
co:21c5: e5 0a          :  mov A,AR10
co:21c7: 38             :  addc A,R0
co:21c8: fa             :  mov R2,A
co:21c9: 7e 00          :  mov R6,#0
co:21cb: 7f 64          :  mov R7,#100
co:21cd: d3             :  setb C
co:21ce: eb             :  mov A,R3
co:21cf: 9f             :  subb A,R7
co:21d0: ea             :  mov A,R2
co:21d1: 9e             :  subb A,R6
co:21d2: 40 17          :  jc ?17
                        : 
co:21d4: 74 ff          :  mov A,#255
co:21d6: 25 0d          :  add A,AR13
co:21d8: f5 0d          :  mov AR13,A
co:21da: 74 ff          :  mov A,#255
co:21dc: 35 0c          :  addc A,AR12
co:21de: f5 0c          :  mov AR12,A
                        :>                                psrc--;         // Wind back HTML-Template and 
                        :>                                leftos++;       // use a new segment...
co:21e0: 05 0f          :  inc AR15
co:21e2: e5 0f          :  mov A,AR15
co:21e4: 70 02          :  jnz ?_8
co:21e6: 05 0e          :  inc AR14
                        : ?_8:
                        :>                                break;          // Exit for now
co:21e8: 02 22 77       :  ljmp ?9
                        : ?17:
                        :>                        }
                        :>
                        :>                        dsrc= (xdata uchar*)(*(code uint*)psrc);
co:21eb: ae 0c          :  mov R6,AR12
co:21ed: af 0d          :  mov R7,AR13
co:21ef: 8e 83          :  mov DPH,R6
co:21f1: 8f 82          :  mov DPL,R7
co:21f3: 12 35 ab       :  lcall __ldc_dptr_r23
                        :  ; variable 'dsrc' assigned to register 'RW23'
                        :>                        psrc+=2;        // Eat Address from Template
co:21f6: 74 02          :  mov A,#2
co:21f8: 25 0d          :  add A,AR13
co:21fa: f5 0d          :  mov AR13,A
co:21fc: e4             :  clr A
co:21fd: 35 0c          :  addc A,AR12
co:21ff: f5 0c          :  mov AR12,A
                        :>                        leftos-=2;
co:2201: 74 fe          :  mov A,#254
co:2203: 25 0f          :  add A,AR15
co:2205: f5 0f          :  mov AR15,A
co:2207: 74 ff          :  mov A,#255
co:2209: 35 0e          :  addc A,AR14
co:220b: f5 0e          :  mov AR14,A
co:220d: 80 29          :  sjmp ?20
                        : ?19:
                        :>
                        :>                        // Insert Var. string in HTML
                        :>                        while(rlen--){
co:220f: 8a 83          :  mov DPH,R2
co:2211: 8b 82          :  mov DPL,R3
co:2213: ae 83          :  mov R6,DPH
co:2215: af 82          :  mov R7,DPL
co:2217: 74 01          :  mov A,#1
co:2219: 2f             :  add A,R7
co:221a: fb             :  mov R3,A
co:221b: e4             :  clr A
co:221c: 3e             :  addc A,R6
co:221d: fa             :  mov R2,A
co:221e: e0             :  movx A,@DPTR
co:221f: ff             :  mov R7,A
                        :  ; variable 'c' assigned to register 'R7'
                        :>                                c=*dsrc++;
                        :>                                *pbuf=c;
co:2220: 85 08 83       :  mov DPH,AR8
co:2223: 85 09 82       :  mov DPL,AR9
co:2226: ef             :  mov A,R7
co:2227: f0             :  movx @DPTR,A
                        :>                                pbuf++;
co:2228: 05 09          :  inc AR9
co:222a: e5 09          :  mov A,AR9
co:222c: 70 02          :  jnz ?_9
co:222e: 05 08          :  inc AR8
                        : ?_9:
                        :>                                cnt++;
co:2230: 05 0b          :  inc AR11
co:2232: e5 0b          :  mov A,AR11
co:2234: 70 02          :  jnz ?_10
co:2236: 05 0a          :  inc AR10
                        : ?_10:
                        :>                        }                       
                        : ?20:
                        : 
co:2238: ac 00          :  mov R4,AR0
co:223a: ad 01          :  mov R5,AR1
co:223c: 74 ff          :  mov A,#255
co:223e: 2d             :  add A,R5
co:223f: f9             :  mov R1,A
co:2240: 74 ff          :  mov A,#255
co:2242: 3c             :  addc A,R4
co:2243: f8             :  mov R0,A
co:2244: ec             :  mov A,R4
co:2245: 4d             :  orl A,R5
co:2246: 70 c7          :  jnz ?19
                        :>
                        :>
                        :>                }else{
co:2248: 80 1a          :  sjmp ?11
                        : ?10:
                        : 
co:224a: af f0          :  mov R7,B
co:224c: 85 08 83       :  mov DPH,AR8
co:224f: 85 09 82       :  mov DPL,AR9
co:2252: ef             :  mov A,R7
co:2253: f0             :  movx @DPTR,A
                        :>                        *pbuf=c;
                        :>                        pbuf++;
co:2254: 05 09          :  inc AR9
co:2256: e5 09          :  mov A,AR9
co:2258: 70 02          :  jnz ?_12
co:225a: 05 08          :  inc AR8
                        : ?_12:
                        :>                        cnt++;
co:225c: 05 0b          :  inc AR11
co:225e: e5 0b          :  mov A,AR11
co:2260: 70 02          :  jnz ?_13
co:2262: 05 0a          :  inc AR10
                        : ?_13:
                        :>                }
                        : ?11:
                        :>                
                        :>                if(cnt==MAX_TX) break;  // Buffer full
co:2264: ae 0a          :  mov R6,AR10
co:2266: af 0b          :  mov R7,AR11
co:2268: ef             :  mov A,R7
co:2269: 64 64          :  xrl A,#100
co:226b: 4e             :  orl A,R6
                        : 
co:226c: 60 09          :  jz ?9
                        :>        }
                        : ?8:
                        : 
co:226e: e5 0e          :  mov A,AR14
co:2270: 45 0f          :  orl A,AR15
co:2272: 60 03          :  jz ?_15
co:2274: 02 21 5f       :  ljmp ?7
                        : ?_15:
                        : ?9:
                        :>
                        :>        pinfo->pweb=psrc;
co:2277: ae 35          :  mov R6,?gendyn_html_pinfo
co:2279: af 36          :  mov R7,?gendyn_html_pinfo+1
co:227b: 74 02          :  mov A,#2
co:227d: 2f             :  add A,R7
co:227e: fb             :  mov R3,A
co:227f: e4             :  clr A
co:2280: 3e             :  addc A,R6
co:2281: fa             :  mov R2,A
co:2282: ae 0c          :  mov R6,AR12
co:2284: af 0d          :  mov R7,AR13
co:2286: 8a 83          :  mov DPH,R2
co:2288: 8b 82          :  mov DPL,R3
co:228a: 12 35 40       :  lcall __st_dptr_r67
                        :>        pinfo->weblen=leftos;
co:228d: ae 35          :  mov R6,?gendyn_html_pinfo
co:228f: af 36          :  mov R7,?gendyn_html_pinfo+1
co:2291: 74 04          :  mov A,#4
co:2293: 2f             :  add A,R7
co:2294: fb             :  mov R3,A
co:2295: e4             :  clr A
co:2296: 3e             :  addc A,R6
co:2297: fa             :  mov R2,A
co:2298: ae 0e          :  mov R6,AR14
co:229a: af 0f          :  mov R7,AR15
co:229c: 8a 83          :  mov DPH,R2
co:229e: 8b 82          :  mov DPL,R3
co:22a0: 12 35 40       :  lcall __st_dptr_r67
                        :>
                        :>        return cnt;
co:22a3: ae 0a          :  mov R6,AR10
co:22a5: af 0b          :  mov R7,AR11
co:22a7: 22             :  ret
                        : ; end of function gendyn_html
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:3 bytes
                        : 
                        :  .export _poll_webserver ; unsigned int poll_webserver(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __poll_webserver
                        : _poll_webserver: ; unsigned int poll_webserver(void)
                        :>}
                        :>
                        :>
                        :>/**********************************************************************************
                        :>*  poll_webserver()
                        :>**********************************************************************************/
                        :>uint poll_webserver(void){
co:1e50: 12 29 cf       :  lcall _poll_net
                        :  ; variable 'res' allocated as 'auto'
co:1e53: 8e 2d          :  mov ?poll_webserver_res,R6
co:1e55: 8f 2e          :  mov ?poll_webserver_res+1,R7
                        :>        uint res;
                        :>        uint i;
                        :>        uchar uci,c;
                        :>        uchar sock,state;
                        :>        xdata HTTP_INFO *pinfo;
                        :>
                        :>        uint sendlen;           // Temp. Len
                        :>        xdata uchar *pbuf;      // Temp. Buffer
                        :>        
                        :>        res=poll_net();
                        :>
                        :>        // First check if a socket is pending
                        :>        if(!res && csock!=0xFF && http_info[csock].html_state==3 &&  !notready_socket_tcp(csock,RDY_4_
co:1e57: e5 2d          :  mov A,?poll_webserver_res
co:1e59: 45 2e          :  orl A,?poll_webserver_res+1
co:1e5b: 60 03          :  jz ?_16
co:1e5d: 02 1e b6       :  ljmp ?27
                        : ?_16:
co:1e60: 90 00 07       :  mov DPTR,#_csock
co:1e63: e0             :  movx A,@DPTR
co:1e64: fb             :  mov R3,A
co:1e65: f4             :  cpl A
co:1e66: 70 03          :  jnz ?_17
co:1e68: 02 1e b6       :  ljmp ?27
                        : ?_17:
co:1e6b: af 03          :  mov R7,AR3
co:1e6d: e4             :  clr A
co:1e6e: fe             :  mov R6,A
co:1e6f: fc             :  mov R4,A
co:1e70: 7d 06          :  mov R5,#6
co:1e72: 12 34 21       :  lcall __mul_i2
co:1e75: 7c 08          :  mov R4,#((_http_info)>>8)&255
co:1e77: 7d 00          :  mov R5,#(_http_info)&255
co:1e79: ed             :  mov A,R5
co:1e7a: 2f             :  add A,R7
co:1e7b: ff             :  mov R7,A
co:1e7c: ec             :  mov A,R4
co:1e7d: 3e             :  addc A,R6
co:1e7e: fe             :  mov R6,A
co:1e7f: 85 06 83       :  mov DPH,AR6
co:1e82: 85 07 82       :  mov DPL,AR7
co:1e85: e0             :  movx A,@DPTR
co:1e86: ff             :  mov R7,A
co:1e87: bf 03 2c       :  cjne R7,#3,?27
co:1e8a: 7d 01          :  mov R5,#1
co:1e8c: af 03          :  mov R7,AR3
co:1e8e: 12 3c 86       :  lcall _notready_socket_tcp
co:1e91: ee             :  mov A,R6
co:1e92: 4f             :  orl A,R7
co:1e93: 70 21          :  jnz ?27
                        : 
co:1e95: 90 00 07       :  mov DPTR,#_csock
co:1e98: e0             :  movx A,@DPTR
co:1e99: ff             :  mov R7,A
co:1e9a: e4             :  clr A
co:1e9b: fe             :  mov R6,A
co:1e9c: 2f             :  add A,R7
co:1e9d: ff             :  mov R7,A
co:1e9e: 74 f5          :  mov A,#245
co:1ea0: 3e             :  addc A,R6
co:1ea1: fe             :  mov R6,A
co:1ea2: 8e 2d          :  mov ?poll_webserver_res,R6
co:1ea4: 8f 2e          :  mov ?poll_webserver_res+1,R7
                        :>                // Patch EVENT
                        :>                res=EVENT_TCP_DATARECEIVED+csock;
                        :>                rcv_len=0;
co:1ea6: 90 02 10       :  mov DPTR,#_rcv_len
co:1ea9: e4             :  clr A
co:1eaa: f0             :  movx @DPTR,A
co:1eab: a3             :  inc DPTR
co:1eac: f0             :  movx @DPTR,A
                        :>                csock=0xFF;
co:1ead: 90 00 07       :  mov DPTR,#_csock
co:1eb0: 74 ff          :  mov A,#255
co:1eb2: f0             :  movx @DPTR,A
                        :>        }else if(res==EVENT_SOCKET_IDLETIMER){
co:1eb3: 02 1f 16       :  ljmp ?28
                        : ?27:
                        : 
co:1eb6: ae 2d          :  mov R6,?poll_webserver_res
co:1eb8: af 2e          :  mov R7,?poll_webserver_res+1
co:1eba: bf 00 05       :  cjne R7,#0,?_21
co:1ebd: be d4 02       :  cjne R6,#212,?_21
co:1ec0: 80 03          :  sjmp ?_22
                        : ?_21:
co:1ec2: 02 1f 16       :  ljmp ?29
                        : ?_22:
                        :  ; variable 'uci' allocated as 'auto'
                        : 
co:1ec5: e4             :  clr A
co:1ec6: f5 2f          :  mov ?poll_webserver_uci,A
                        : ?31:
                        :>                for(uci=0;uci<MAX_SOCK;uci++){
co:1ec8: af 2f          :  mov R7,?poll_webserver_uci
co:1eca: e4             :  clr A
co:1ecb: fe             :  mov R6,A
co:1ecc: fc             :  mov R4,A
co:1ecd: 7d 06          :  mov R5,#6
co:1ecf: 12 34 21       :  lcall __mul_i2
co:1ed2: 7c 08          :  mov R4,#((_http_info)>>8)&255
co:1ed4: 7d 00          :  mov R5,#(_http_info)&255
co:1ed6: ed             :  mov A,R5
co:1ed7: 2f             :  add A,R7
co:1ed8: ff             :  mov R7,A
co:1ed9: ec             :  mov A,R4
co:1eda: 3e             :  addc A,R6
co:1edb: fe             :  mov R6,A
co:1edc: 85 06 83       :  mov DPH,AR6
co:1edf: 85 07 82       :  mov DPL,AR7
co:1ee2: e0             :  movx A,@DPTR
co:1ee3: fd             :  mov R5,A
co:1ee4: 7f 03          :  mov R7,#3
co:1ee6: c3             :  clr C
co:1ee7: ed             :  mov A,R5
co:1ee8: 9f             :  subb A,R7
co:1ee9: 40 20          :  jc ?35
co:1eeb: 7d 01          :  mov R5,#1
co:1eed: af 2f          :  mov R7,?poll_webserver_uci
co:1eef: 12 3c 86       :  lcall _notready_socket_tcp
co:1ef2: ee             :  mov A,R6
co:1ef3: 4f             :  orl A,R7
co:1ef4: 70 15          :  jnz ?35
                        :>                        if(http_info[uci].html_state>=3 &&  !notready_socket_tcp(uci,RDY_4_TX)){
co:1ef6: af 2f          :  mov R7,?poll_webserver_uci
co:1ef8: e4             :  clr A
co:1ef9: fe             :  mov R6,A
co:1efa: 2f             :  add A,R7
co:1efb: ff             :  mov R7,A
co:1efc: 74 f5          :  mov A,#245
co:1efe: 3e             :  addc A,R6
co:1eff: fe             :  mov R6,A
co:1f00: 8e 2d          :  mov ?poll_webserver_res,R6
co:1f02: 8f 2e          :  mov ?poll_webserver_res+1,R7
                        :>                                // Patch EVENT (simulate a received 0-size segment)
                        :>                                res=EVENT_TCP_DATARECEIVED+uci;
                        :>                                rcv_len=0;
co:1f04: 90 02 10       :  mov DPTR,#_rcv_len
co:1f07: e4             :  clr A
co:1f08: f0             :  movx @DPTR,A
co:1f09: a3             :  inc DPTR
co:1f0a: f0             :  movx @DPTR,A
                        :>                        }
                        : ?35:
                        :>                }
co:1f0b: 05 2f          :  inc ?poll_webserver_uci
                        : 
co:1f0d: 74 02          :  mov A,#2
co:1f0f: 65 2f          :  xrl A,?poll_webserver_uci
co:1f11: 60 03          :  jz ?_25
co:1f13: 02 1e c8       :  ljmp ?31
                        : ?_25:
                        :>        }
                        : ?29:
                        : ?28:
                        :>
                        :>        // Received a TCP_EVENT. Could indicate received data or a closure of the TCP socket
                        :>        if(res>=0xF000){
co:1f16: 7c f0          :  mov R4,#240
co:1f18: 7d 00          :  mov R5,#0
co:1f1a: ae 2d          :  mov R6,?poll_webserver_res
co:1f1c: af 2e          :  mov R7,?poll_webserver_res+1
co:1f1e: c3             :  clr C
co:1f1f: ef             :  mov A,R7
co:1f20: 9d             :  subb A,R5
co:1f21: ee             :  mov A,R6
co:1f22: 9c             :  subb A,R4
co:1f23: 50 03          :  jnc ?_26
co:1f25: 02 21 0b       :  ljmp ?37
                        : ?_26:
                        : 
co:1f28: ae 2d          :  mov R6,?poll_webserver_res
co:1f2a: af 2e          :  mov R7,?poll_webserver_res+1
                        :  ; variable 'sock' allocated as 'auto'
co:1f2c: 8f 2f          :  mov ?poll_webserver_sock,R7
                        :>                sock=(uchar)res;        // isolate socket index
                        :>
                        :>                // Only process HTTP-Sockets!
                        :>                if(uc_socket[sock].local_port!=80) return res;
co:1f2e: af 2f          :  mov R7,?poll_webserver_sock
co:1f30: e4             :  clr A
co:1f31: fe             :  mov R6,A
co:1f32: fc             :  mov R4,A
co:1f33: 7d 32          :  mov R5,#50
co:1f35: 12 34 21       :  lcall __mul_i2
co:1f38: 7c 07          :  mov R4,#((_uc_socket+14)>>8)&255
co:1f3a: 7d 98          :  mov R5,#(_uc_socket+14)&255
co:1f3c: ed             :  mov A,R5
co:1f3d: 2f             :  add A,R7
co:1f3e: ff             :  mov R7,A
co:1f3f: ec             :  mov A,R4
co:1f40: 3e             :  addc A,R6
co:1f41: fe             :  mov R6,A
co:1f42: 8e 83          :  mov DPH,R6
co:1f44: 8f 82          :  mov DPL,R7
co:1f46: 12 35 4c       :  lcall __ld_dptr_r67
co:1f49: ef             :  mov A,R7
co:1f4a: 64 50          :  xrl A,#80
co:1f4c: 70 03          :  jnz ?_27
co:1f4e: ee             :  mov A,R6
co:1f4f: 60 07          :  jz ?39
                        : ?_27:
                        : 
co:1f51: ae 2d          :  mov R6,?poll_webserver_res
co:1f53: af 2e          :  mov R7,?poll_webserver_res+1
co:1f55: 02 21 0f       :  ljmp ?26
                        : ?39:
                        :>
                        :>                pinfo=&http_info[sock]; // Pointer to HTTP_INFO for the current socket
co:1f58: af 2f          :  mov R7,?poll_webserver_sock
co:1f5a: e4             :  clr A
co:1f5b: fe             :  mov R6,A
co:1f5c: fc             :  mov R4,A
co:1f5d: 7d 06          :  mov R5,#6
co:1f5f: 12 34 21       :  lcall __mul_i2
co:1f62: 7c 08          :  mov R4,#((_http_info)>>8)&255
co:1f64: 7d 00          :  mov R5,#(_http_info)&255
co:1f66: ed             :  mov A,R5
co:1f67: 2f             :  add A,R7
co:1f68: ff             :  mov R7,A
co:1f69: ec             :  mov A,R4
co:1f6a: 3e             :  addc A,R6
co:1f6b: fe             :  mov R6,A
                        :  ; variable 'pinfo' allocated as 'auto'
co:1f6c: 8e 30          :  mov ?poll_webserver_pinfo,R6
co:1f6e: 8f 31          :  mov ?poll_webserver_pinfo+1,R7
                        :>
                        :>                state=pinfo->html_state;
co:1f70: 85 30 83       :  mov DPH,?poll_webserver_pinfo
co:1f73: 85 31 82       :  mov DPL,?poll_webserver_pinfo+1
co:1f76: e0             :  movx A,@DPTR
co:1f77: ff             :  mov R7,A
                        :  ; variable 'state' allocated as 'auto'
co:1f78: 8f 32          :  mov ?poll_webserver_state,R7
                        :>                
                        :>                // *** RECEIVED DATA ***
                        :>                if((res&0xFF00)==EVENT_TCP_DATARECEIVED){
co:1f7a: ae 2d          :  mov R6,?poll_webserver_res
co:1f7c: af 2e          :  mov R7,?poll_webserver_res+1
co:1f7e: 7f 00          :  mov R7,#0
co:1f80: bf 00 05       :  cjne R7,#0,?_29
co:1f83: be f5 02       :  cjne R6,#245,?_29
co:1f86: 80 03          :  sjmp ?_30
                        : ?_29:
co:1f88: 02 20 ef       :  ljmp ?41
                        : ?_30:
                        : 
co:1f8b: e4             :  clr A
co:1f8c: f8             :  mov R0,A
co:1f8d: f9             :  mov R1,A
                        :  ; variable 'res' assigned to register 'RW01'
                        :>#if 0 // Disabled (enable only for debugging)
                        :>                        // Show request...
                        :>                        for(i=0;i<rcv_len;i++){
                        :>                                c=rcv_buf[i];
                        :>                                if(c=='\r') putsl("<CR>");
                        :>                                else if(c=='\n') puts("<LF>");
                        :>                                else putchar(c);
                        :>                        }
                        :>#endif
                        :>                        res=0;  // This is our new return EVENT (default: nothing)
                        :>                        // Parse request
                        :>                        for(i=0;i<rcv_len;i++){
co:1f8e: e4             :  clr A
co:1f8f: fa             :  mov R2,A
co:1f90: fb             :  mov R3,A
                        :  ; variable 'i' assigned to register 'RW23'
co:1f91: 02 20 45       :  ljmp ?46
                        : ?43:
                        : 
co:1f94: 7e 02          :  mov R6,#((_rcv_buf)>>8)&255
co:1f96: 7f 12          :  mov R7,#(_rcv_buf)&255
co:1f98: ef             :  mov A,R7
co:1f99: 2b             :  add A,R3
co:1f9a: ff             :  mov R7,A
co:1f9b: ee             :  mov A,R6
co:1f9c: 3a             :  addc A,R2
co:1f9d: fe             :  mov R6,A
co:1f9e: 85 06 83       :  mov DPH,AR6
co:1fa1: 85 07 82       :  mov DPL,AR7
co:1fa4: e0             :  movx A,@DPTR
co:1fa5: ff             :  mov R7,A
                        :  ; variable 'c' assigned to register 'B '
co:1fa6: 8f f0          :  mov B,R7
                        :>                                c=rcv_buf[i];
                        :>
                        :>                                switch(state){
co:1fa8: e5 32          :  mov A,?poll_webserver_state
co:1faa: 60 17          :  jz ?49
co:1fac: af 32          :  mov R7,?poll_webserver_state
co:1fae: ef             :  mov A,R7
co:1faf: 64 01          :  xrl A,#1
co:1fb1: 70 03          :  jnz ?_32
co:1fb3: 02 20 20       :  ljmp ?52
                        : ?_32:
co:1fb6: af 32          :  mov R7,?poll_webserver_state
co:1fb8: ef             :  mov A,R7
co:1fb9: 64 02          :  xrl A,#2
co:1fbb: 70 03          :  jnz ?_33
co:1fbd: 02 20 2b       :  ljmp ?55
                        : ?_33:
co:1fc0: 02 20 40       :  ljmp ?47
                        : 
                        : ?49:
                        :>                                case 0:
                        :>                                        if(c=='G' && i==0){     // Assume a GET
co:1fc3: 74 47          :  mov A,#71
co:1fc5: 65 f0          :  xrl A,B
co:1fc7: 60 03          :  jz ?_34
co:1fc9: 02 20 40       :  ljmp ?48
                        : ?_34:
co:1fcc: ea             :  mov A,R2
co:1fcd: 4b             :  orl A,R3
co:1fce: 60 03          :  jz ?_35
co:1fd0: 02 20 40       :  ljmp ?48
                        : ?_35:
                        : 
co:1fd3: 75 32 01       :  mov ?poll_webserver_state,#1
                        :>                                                state=1;
                        :>                                                // Emit a HTTP-Request
                        :>                                                res=EVENT_HTTP_REQUEST+sock;
co:1fd6: af 2f          :  mov R7,?poll_webserver_sock
co:1fd8: e4             :  clr A
co:1fd9: fe             :  mov R6,A
co:1fda: 2f             :  add A,R7
co:1fdb: f9             :  mov R1,A
co:1fdc: 74 90          :  mov A,#144
co:1fde: 3e             :  addc A,R6
co:1fdf: f8             :  mov R0,A
                        :>                
                        :>                                                // Set Default Reply to NotFound
                        :>                                                pinfo->pweb=html_notfound;
co:1fe0: ae 30          :  mov R6,?poll_webserver_pinfo
co:1fe2: af 31          :  mov R7,?poll_webserver_pinfo+1
co:1fe4: 74 02          :  mov A,#2
co:1fe6: 2f             :  add A,R7
co:1fe7: fd             :  mov R5,A
co:1fe8: e4             :  clr A
co:1fe9: 3e             :  addc A,R6
co:1fea: fc             :  mov R4,A
co:1feb: 7e 22          :  mov R6,#((_html_notfound)>>8)&255
co:1fed: 7f a8          :  mov R7,#(_html_notfound)&255
co:1fef: 8c 83          :  mov DPH,R4
co:1ff1: 8d 82          :  mov DPL,R5
co:1ff3: 12 35 40       :  lcall __st_dptr_r67
                        :>                                                pinfo->weblen=sizeof(html_notfound);
co:1ff6: ae 30          :  mov R6,?poll_webserver_pinfo
co:1ff8: af 31          :  mov R7,?poll_webserver_pinfo+1
co:1ffa: 74 04          :  mov A,#4
co:1ffc: 2f             :  add A,R7
co:1ffd: fd             :  mov R5,A
co:1ffe: e4             :  clr A
co:1fff: 3e             :  addc A,R6
co:2000: fc             :  mov R4,A
co:2001: 7e 00          :  mov R6,#0
co:2003: 7f e5          :  mov R7,#229
co:2005: 8c 83          :  mov DPH,R4
co:2007: 8d 82          :  mov DPL,R5
co:2009: 12 35 40       :  lcall __st_dptr_r67
                        :>                                                pinfo->dyna_flag=1; // With interpretation! (because H
co:200c: ae 30          :  mov R6,?poll_webserver_pinfo
co:200e: af 31          :  mov R7,?poll_webserver_pinfo+1
co:2010: 0f             :  inc R7
co:2011: ef             :  mov A,R7
co:2012: 70 01          :  jnz ?__3
co:2014: 0e             :  inc R6
                        : ?__3:
co:2015: 85 06 83       :  mov DPH,AR6
co:2018: 85 07 82       :  mov DPL,AR7
co:201b: 74 01          :  mov A,#1
co:201d: f0             :  movx @DPTR,A
                        :>                                                
                        :>                                        }
co:201e: 80 20          :  sjmp ?48
                        : ?52:
                        :>                                        break;
                        :>                                case 1: // Wait for a EOL after chars were found
                        :>                                        if(c=='\n') state=2;
co:2020: 74 0a          :  mov A,#10
co:2022: 65 f0          :  xrl A,B
co:2024: 70 1a          :  jnz ?48
                        : 
co:2026: 75 32 02       :  mov ?poll_webserver_state,#2
                        :>                                        break;
co:2029: 80 15          :  sjmp ?48
                        : ?55:
                        :>                                case 2: // Rec. new line, CR LF marks end of HTTP_Request
                        :>                                        if(c=='\n') {
co:202b: 74 0a          :  mov A,#10
co:202d: 65 f0          :  xrl A,B
co:202f: 70 05          :  jnz ?56
                        : 
co:2031: 75 32 03       :  mov ?poll_webserver_state,#3
                        :>                                                state=3;        // CR LF: End of Request
                        :>                                        }else {
co:2034: 80 0a          :  sjmp ?57
                        : ?56:
                        : 
co:2036: af f0          :  mov R7,B
co:2038: ef             :  mov A,R7
co:2039: 64 0d          :  xrl A,#13
co:203b: 60 03          :  jz ?58
                        :>                                                if(c!='\r') state=1;    // ignore all visible chars
co:203d: 75 32 01       :  mov ?poll_webserver_state,#1
                        : ?58:
                        :>                                        }
                        : ?57:
                        :>                                } // switch
                        : ?47:
                        : ?48:
                        :>                        } // for
co:2040: 0b             :  inc R3
co:2041: eb             :  mov A,R3
co:2042: 70 01          :  jnz ?__4
co:2044: 0a             :  inc R2
                        : ?__4:
                        : ?46:
                        : 
co:2045: 90 02 10       :  mov DPTR,#_rcv_len
co:2048: 12 35 4c       :  lcall __ld_dptr_r67
co:204b: c3             :  clr C
co:204c: eb             :  mov A,R3
co:204d: 9f             :  subb A,R7
co:204e: ea             :  mov A,R2
co:204f: 9e             :  subb A,R6
co:2050: 50 03          :  jnc ?_39
co:2052: 02 1f 94       :  ljmp ?43
                        : ?_39:
                        :>
                        :>                        // Inform User about page request
                        :>                        if(res) {
co:2055: e8             :  mov A,R0
co:2056: 49             :  orl A,R1
co:2057: 60 11          :  jz ?60
                        : 
co:2059: af 32          :  mov R7,?poll_webserver_state
co:205b: 85 30 83       :  mov DPH,?poll_webserver_pinfo
co:205e: 85 31 82       :  mov DPL,?poll_webserver_pinfo+1
co:2061: ef             :  mov A,R7
co:2062: f0             :  movx @DPTR,A
                        :>                                pinfo->html_state=state;        // Keep state
                        :>                                return res;                     // And return (0 or REQUEST) to the us
co:2063: ae 00          :  mov R6,AR0
co:2065: af 01          :  mov R7,AR1
co:2067: 02 21 0f       :  ljmp ?26
                        : ?60:
                        :>                        }
                        :>
                        :>                        // Try to send data for states 3 and 4
                        :>                        if(state>=3){
co:206a: 7d 03          :  mov R5,#3
co:206c: af 32          :  mov R7,?poll_webserver_state
co:206e: c3             :  clr C
co:206f: ef             :  mov A,R7
co:2070: 9d             :  subb A,R5
co:2071: 50 03          :  jnc ?_41
co:2073: 02 20 e0       :  ljmp ?62
                        : ?_41:
                        : 
co:2076: 7d 01          :  mov R5,#1
co:2078: af 2f          :  mov R7,?poll_webserver_sock
co:207a: 12 3c 86       :  lcall _notready_socket_tcp
co:207d: ee             :  mov A,R6
co:207e: 4f             :  orl A,R7
co:207f: 60 03          :  jz ?_42
co:2081: 02 20 dd       :  ljmp ?64
                        : ?_42:
                        :>                                if(!notready_socket_tcp(sock,RDY_4_TX)){
co:2084: 75 32 03       :  mov ?poll_webserver_state,#3
                        :>                                        state=3;
                        :>                                        if(pinfo->weblen){      // There is still something to send
co:2087: ae 30          :  mov R6,?poll_webserver_pinfo
co:2089: af 31          :  mov R7,?poll_webserver_pinfo+1
co:208b: 74 04          :  mov A,#4
co:208d: 2f             :  add A,R7
co:208e: ff             :  mov R7,A
co:208f: e4             :  clr A
co:2090: 3e             :  addc A,R6
co:2091: fe             :  mov R6,A
co:2092: 8e 83          :  mov DPH,R6
co:2094: 8f 82          :  mov DPL,R7
co:2096: 12 35 4c       :  lcall __ld_dptr_r67
co:2099: ee             :  mov A,R6
co:209a: 4f             :  orl A,R7
co:209b: 60 28          :  jz ?66
                        : 
co:209d: 12 36 57       :  lcall _allocate_tx_buf
                        :  ; variable 'pbuf' allocated as 'auto'
co:20a0: 8e 33          :  mov ?poll_webserver_pbuf,R6
co:20a2: 8f 34          :  mov ?poll_webserver_pbuf+1,R7
                        :>                                                pbuf=allocate_tx_buf(); // Allocate a buffer
                        :>                                                sendlen=gendyn_html(pinfo,pbuf); // Fill Buffer
co:20a4: ac 33          :  mov R4,?poll_webserver_pbuf
co:20a6: ad 34          :  mov R5,?poll_webserver_pbuf+1
co:20a8: ae 30          :  mov R6,?poll_webserver_pinfo
co:20aa: af 31          :  mov R7,?poll_webserver_pinfo+1
co:20ac: 12 21 10       :  lcall _gendyn_html
                        :  ; variable 'sendlen' assigned to register 'RW67'
                        :>                                                send_socket_tcp(sock, pbuf, sendlen); // Send buffer (
co:20af: aa 06          :  mov R2,AR6
co:20b1: ab 07          :  mov R3,AR7
co:20b3: ac 33          :  mov R4,?poll_webserver_pbuf
co:20b5: ad 34          :  mov R5,?poll_webserver_pbuf+1
co:20b7: af 2f          :  mov R7,?poll_webserver_sock
co:20b9: 12 3a 55       :  lcall _send_socket_tcp
                        :>                                                csock=sock;     // Could send something, retry soon!
co:20bc: af 2f          :  mov R7,?poll_webserver_sock
co:20be: 90 00 07       :  mov DPTR,#_csock
co:20c1: ef             :  mov A,R7
co:20c2: f0             :  movx @DPTR,A
                        :>                                        }else{ // Manually close only dynamic Pages...
co:20c3: 80 1b          :  sjmp ?65
                        : ?66:
                        : 
co:20c5: 75 32 04       :  mov ?poll_webserver_state,#4
                        :>                                                state=4;        // Waiting for close could block other
                        :>                                                if(!notready_socket_tcp(sock,RDY_4_CLOSE)){
co:20c8: e4             :  clr A
co:20c9: fd             :  mov R5,A
co:20ca: af 2f          :  mov R7,?poll_webserver_sock
co:20cc: 12 3c 86       :  lcall _notready_socket_tcp
co:20cf: ee             :  mov A,R6
co:20d0: 4f             :  orl A,R7
co:20d1: 70 0d          :  jnz ?65
                        : 
co:20d3: e4             :  clr A
co:20d4: f5 32          :  mov ?poll_webserver_state,A
                        :>                                                        state=0;
                        :>                                                        close_socket_tcp(sock);
co:20d6: af 2f          :  mov R7,?poll_webserver_sock
co:20d8: 12 4a b9       :  lcall _close_socket_tcp
                        :>                                                }
co:20db: 80 03          :  sjmp ?65
                        : ?64:
                        :>                                        }
                        :>
                        :>                                }else{ // !notready
co:20dd: 75 32 04       :  mov ?poll_webserver_state,#4
                        :>                                        state=4; // Mark socket as pending, try in 500 msec again
                        :>                                }
                        : ?65:
                        :>
                        :>                        }
                        : ?62:
                        :>                        pinfo->html_state=state;        // Keep state
co:20e0: af 32          :  mov R7,?poll_webserver_state
co:20e2: 85 30 83       :  mov DPH,?poll_webserver_pinfo
co:20e5: 85 31 82       :  mov DPL,?poll_webserver_pinfo+1
co:20e8: ef             :  mov A,R7
co:20e9: f0             :  movx @DPTR,A
                        :>                        return 0;                       // Ignore Webserver maintained events
co:20ea: e4             :  clr A
co:20eb: fe             :  mov R6,A
co:20ec: ff             :  mov R7,A
co:20ed: 80 20          :  sjmp ?26
                        : ?41:
                        :>
                        :>                }else if(res>=0xF800){ // all Events >=0xF800 close TCP Connections.
co:20ef: 7c f8          :  mov R4,#248
co:20f1: 7d 00          :  mov R5,#0
co:20f3: ae 2d          :  mov R6,?poll_webserver_res
co:20f5: af 2e          :  mov R7,?poll_webserver_res+1
co:20f7: c3             :  clr C
co:20f8: ef             :  mov A,R7
co:20f9: 9d             :  subb A,R5
co:20fa: ee             :  mov A,R6
co:20fb: 9c             :  subb A,R4
co:20fc: 40 0d          :  jc ?70
                        : 
co:20fe: 85 30 83       :  mov DPH,?poll_webserver_pinfo
co:2101: 85 31 82       :  mov DPL,?poll_webserver_pinfo+1
co:2104: e4             :  clr A
co:2105: f0             :  movx @DPTR,A
                        :>                        pinfo->html_state=0;    // ALL other TCP_EVENTS close the socket (ensured by d
                        :>                        return 0;               // Ignore this Event, socket is maintained by webserve
co:2106: e4             :  clr A
co:2107: fe             :  mov R6,A
co:2108: ff             :  mov R7,A
co:2109: 80 04          :  sjmp ?26
                        : ?70:
                        :>                }
                        :>        }
                        : ?37:
                        :>        return res;
co:210b: ae 2d          :  mov R6,?poll_webserver_res
co:210d: af 2e          :  mov R7,?poll_webserver_res+1
                        : ?26:
co:210f: 22             :  ret
                        : ; end of function poll_webserver
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:8 bytes
                        : 
                        :  .export _webpage_name ; xdata unsigned char *webpage_name(void)
                        :  .segment _webpage_name_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _webpage_name_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _webpage_name_formal_near, _webpage_name_local_near, __webpage_name
                        : 
                        :  .segment __webpage_name
                        : _webpage_name: ; (leaf function) xdata unsigned char *webpage_name(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>*  webpage_name(): Return the Name of the requested page. 
                        :>*
                        :>* Attention: Maybe called only ONCE, because terminates URL-String
                        :>**********************************************************************************/
                        :>xdata uchar * webpage_name(void){
co:1e09: 7c 02          :  mov R4,#((_rcv_buf+5)>>8)&255
co:1e0b: 7d 17          :  mov R5,#(_rcv_buf+5)&255
                        :  ; variable 'pc' assigned to register 'RW45'
                        :>        uchar c;
                        :>        xdata uchar *pc=rcv_buf+5;      // Kill GET slash (5 chars)
                        :>        web_args=0;             // Assume NO Arguments
co:1e0d: e4             :  clr A
co:1e0e: fe             :  mov R6,A
co:1e0f: ff             :  mov R7,A
co:1e10: 90 07 fe       :  mov DPTR,#_web_args
co:1e13: 12 35 40       :  lcall __st_dptr_r67
                        :>        rcv_buf[MAX_RX-1]=0;    // Prevent Buffer overread
co:1e16: 90 07 89       :  mov DPTR,#_rcv_buf+1399
co:1e19: e4             :  clr A
co:1e1a: f0             :  movx @DPTR,A
                        :>        for(;;){
                        : ?74:
                        : 
co:1e1b: 85 04 83       :  mov DPH,AR4
co:1e1e: 85 05 82       :  mov DPL,AR5
co:1e21: e0             :  movx A,@DPTR
co:1e22: fb             :  mov R3,A
                        :  ; variable 'c' assigned to register 'R3'
                        :>                c=*pc;
                        :>                if(c=='?') {
co:1e23: bb 3f 0f       :  cjne R3,#63,?78
                        : 
co:1e26: 74 01          :  mov A,#1
co:1e28: 2d             :  add A,R5
co:1e29: ff             :  mov R7,A
co:1e2a: e4             :  clr A
co:1e2b: 3c             :  addc A,R4
co:1e2c: fe             :  mov R6,A
co:1e2d: 90 07 fe       :  mov DPTR,#_web_args
co:1e30: 12 35 40       :  lcall __st_dptr_r67
                        :>                        web_args=pc+1;
                        :>                        break;
co:1e33: 80 0e          :  sjmp ?76
                        : ?78:
                        :>                }else  if(c<=' ') break;
co:1e35: 7f 20          :  mov R7,#32
co:1e37: d3             :  setb C
co:1e38: eb             :  mov A,R3
co:1e39: 9f             :  subb A,R7
                        : 
co:1e3a: 40 07          :  jc ?76
                        :>                pc++;
co:1e3c: 0d             :  inc R5
co:1e3d: ed             :  mov A,R5
co:1e3e: 70 01          :  jnz ?__5
co:1e40: 0c             :  inc R4
                        : ?__5:
                        :>        }
co:1e41: 80 d8          :  sjmp ?74
                        : ?76:
                        :>        *pc=0;
co:1e43: 85 04 83       :  mov DPH,AR4
co:1e46: 85 05 82       :  mov DPL,AR5
co:1e49: e4             :  clr A
co:1e4a: f0             :  movx @DPTR,A
                        :>        return rcv_buf+5;
co:1e4b: 7e 02          :  mov R6,#((_rcv_buf+5)>>8)&255
co:1e4d: 7f 17          :  mov R7,#(_rcv_buf+5)&255
co:1e4f: 22             :  ret
                        : ; end of function webpage_name
                        : ; used: R---34567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _url_getarg_no ; unsigned char url_getarg_no(void)
                        :  .segment _url_getarg_no_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _url_getarg_no_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _url_getarg_no_formal_near, _url_getarg_no_local_near, __url_getarg_no
                        : 
                        :  .segment __url_getarg_no
                        : _url_getarg_no: ; (leaf function) unsigned char url_getarg_no(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* uchar url_getarg_no(void)
                        :>*
                        :>* Will return the index No of an argument or 0 for none. The Value of an argument
                        :>* can be retrieved with url_getarg_str();
                        :>* All Arguments must be named A1 - A255 or a1-a255
                        :>**********************************************************************************/
                        :>uchar url_getarg_no(void){
co:2402: 90 07 fe       :  mov DPTR,#_web_args
co:2405: 12 35 4c       :  lcall __ld_dptr_r67
co:2408: ee             :  mov A,R6
co:2409: 4f             :  orl A,R7
co:240a: 70 05          :  jnz ?83
                        :>        uchar ano;
                        :>        uchar c;
                        :>        if(!web_args) return 0;
co:240c: e4             :  clr A
co:240d: ff             :  mov R7,A
co:240e: 02 24 79       :  ljmp ?82
                        : ?83:
                        :>        c=*web_args++;
co:2411: 90 07 fe       :  mov DPTR,#_web_args
co:2414: 12 35 46       :  lcall __ld_dptr_r45
co:2417: 74 01          :  mov A,#1
co:2419: 2d             :  add A,R5
co:241a: ff             :  mov R7,A
co:241b: e4             :  clr A
co:241c: 3c             :  addc A,R4
co:241d: fe             :  mov R6,A
co:241e: 90 07 fe       :  mov DPTR,#_web_args
co:2421: 12 35 40       :  lcall __st_dptr_r67
co:2424: 85 04 83       :  mov DPH,AR4
co:2427: 85 05 82       :  mov DPL,AR5
co:242a: e0             :  movx A,@DPTR
                        :  ; variable 'c' assigned to register 'R7'
                        :>        if(c!='a' && c!='A') return 0;  // No Arg found!
co:242b: ff             :  mov R7,A
co:242c: 64 61          :  xrl A,#97
co:242e: 60 0a          :  jz ?85
co:2430: ef             :  mov A,R7
co:2431: 64 41          :  xrl A,#65
co:2433: 60 05          :  jz ?85
                        : 
co:2435: e4             :  clr A
co:2436: ff             :  mov R7,A
co:2437: 02 24 79       :  ljmp ?82
                        : ?85:
                        :>        ano=0;
co:243a: e4             :  clr A
co:243b: fb             :  mov R3,A
                        :  ; variable 'ano' assigned to register 'R3'
                        :>        for(;;){
                        : ?87:
                        : 
co:243c: 90 07 fe       :  mov DPTR,#_web_args
co:243f: 12 35 46       :  lcall __ld_dptr_r45
co:2442: 74 01          :  mov A,#1
co:2444: 2d             :  add A,R5
co:2445: ff             :  mov R7,A
co:2446: e4             :  clr A
co:2447: 3c             :  addc A,R4
co:2448: fe             :  mov R6,A
co:2449: 90 07 fe       :  mov DPTR,#_web_args
co:244c: 12 35 40       :  lcall __st_dptr_r67
co:244f: 85 04 83       :  mov DPH,AR4
co:2452: 85 05 82       :  mov DPL,AR5
co:2455: e0             :  movx A,@DPTR
co:2456: ff             :  mov R7,A
co:2457: 74 d0          :  mov A,#208
co:2459: 2f             :  add A,R7
co:245a: fd             :  mov R5,A
                        :  ; variable 'c' assigned to register 'R5'
                        :>                c=(*web_args++)-'0';
                        :>                if(c>9) break;
co:245b: 7f 09          :  mov R7,#9
co:245d: d3             :  setb C
co:245e: ed             :  mov A,R5
co:245f: 9f             :  subb A,R7
                        : 
co:2460: 50 0c          :  jnc ?89
                        :>                ano*=10;
co:2462: 7f 0a          :  mov R7,#10
co:2464: eb             :  mov A,R3
co:2465: 8f f0          :  mov B,R7
co:2467: a4             :  mul AB
co:2468: ff             :  mov R7,A
                        :  ; variable 'ano' assigned to register 'R7'
                        :>                ano+=c;
co:2469: ed             :  mov A,R5
co:246a: 2f             :  add A,R7
co:246b: fb             :  mov R3,A
                        :>        }               
co:246c: 80 ce          :  sjmp ?87
                        : ?89:
                        :>        if(c!= ('='-'0')) return 0;     // Format error
co:246e: ed             :  mov A,R5
co:246f: 64 0d          :  xrl A,#13
co:2471: 60 04          :  jz ?93
                        : 
co:2473: e4             :  clr A
co:2474: ff             :  mov R7,A
co:2475: 80 02          :  sjmp ?82
                        : ?93:
                        :>        return ano;     
co:2477: af 03          :  mov R7,AR3
                        : ?82:
co:2479: 22             :  ret
                        : ; end of function url_getarg_no
                        : ; used: R---34567 BR-------- DPTR ACC PSW B
                        : 
                        :  .export _url_getarg_str ; xdata unsigned char *url_getarg_str(void)
                        :  .segment _url_getarg_str_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _url_getarg_str_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _url_getarg_str_formal_near, _url_getarg_str_local_near, __url_getarg_str
                        : 
                        :  .segment __url_getarg_str
                        : _url_getarg_str: ; (leaf function) xdata unsigned char *url_getarg_str(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>* xdata uchar url_getarg_str(void)
                        :>*
                        :>* Will return the value of the last identified argument
                        :>**********************************************************************************/
                        :>xdata uchar *url_getarg_str(void){
co:247a: 90 07 fe       :  mov DPTR,#_web_args
co:247d: 12 34 d4       :  lcall __ld_dptr_r23
                        :  ; variable 'ret' assigned to register 'RW23'
                        :>        xdata uchar *ret;
                        :>         uchar c;
                        :>        ret=web_args;
                        :>        for(;;){
                        : ?98:
                        : 
co:2480: 90 07 fe       :  mov DPTR,#_web_args
co:2483: 12 35 4c       :  lcall __ld_dptr_r67
co:2486: 85 06 83       :  mov DPH,AR6
co:2489: 85 07 82       :  mov DPL,AR7
co:248c: e0             :  movx A,@DPTR
                        :  ; variable 'c' assigned to register 'R5'
                        :>                c=*web_args;
                        :>                if(c=='&' || c<=' ') break;
co:248d: fd             :  mov R5,A
co:248e: 64 26          :  xrl A,#38
co:2490: 60 07          :  jz ?104
co:2492: 7f 20          :  mov R7,#32
co:2494: d3             :  setb C
co:2495: ed             :  mov A,R5
co:2496: 9f             :  subb A,R7
co:2497: 50 02          :  jnc ?102
                        : ?104:
                        : 
co:2499: 80 13          :  sjmp ?100
                        : ?102:
                        :>                web_args++;     // Read over
co:249b: 90 07 fe       :  mov DPTR,#_web_args
co:249e: 12 35 4c       :  lcall __ld_dptr_r67
co:24a1: 0f             :  inc R7
co:24a2: ef             :  mov A,R7
co:24a3: 70 01          :  jnz ?__6
co:24a5: 0e             :  inc R6
                        : ?__6:
co:24a6: 90 07 fe       :  mov DPTR,#_web_args
co:24a9: 12 35 40       :  lcall __st_dptr_r67
                        :>        }               
co:24ac: 80 d2          :  sjmp ?98
                        : ?100:
                        :>        *web_args=0;    // Terminate string for this argument
co:24ae: 90 07 fe       :  mov DPTR,#_web_args
co:24b1: 12 35 4c       :  lcall __ld_dptr_r67
co:24b4: 85 06 83       :  mov DPH,AR6
co:24b7: 85 07 82       :  mov DPL,AR7
co:24ba: e4             :  clr A
co:24bb: f0             :  movx @DPTR,A
                        :>        web_args++;     // and set to next Arg.
co:24bc: 90 07 fe       :  mov DPTR,#_web_args
co:24bf: 12 35 4c       :  lcall __ld_dptr_r67
co:24c2: 0f             :  inc R7
co:24c3: ef             :  mov A,R7
co:24c4: 70 01          :  jnz ?__7
co:24c6: 0e             :  inc R6
                        : ?__7:
co:24c7: 90 07 fe       :  mov DPTR,#_web_args
co:24ca: 12 35 40       :  lcall __st_dptr_r67
                        :>        return ret;
co:24cd: ae 02          :  mov R6,AR2
co:24cf: af 03          :  mov R7,AR3
co:24d1: 22             :  ret
                        : ; end of function url_getarg_str
                        : ; used: R--23-567 BR-------- DPTR ACC PSW
                        : 
                        :  .export _webpage_bind ; void webpage_bind(unsigned char, code unsigned char *)
                        :  .segment _webpage_bind_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _webpage_bind_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _webpage_bind_formal_near, _webpage_bind_local_near, __webpage_bind
                        : 
                        :  .segment __webpage_bind
                        : _webpage_bind: ; (leaf function) void webpage_bind(unsigned char, code unsigned char *)
                        :  ; parameter 'pd' in 'RW45' assigned to 'B1_RW89'
                        :  ; parameter 'sock' in 'R7'
co:274b: 8c 08          :  mov AR8,R4
co:274d: 8d 09          :  mov AR9,R5
                        :>}
                        :>
                        :>
                        :>
                        :>/**********************************************************************************
                        :>* webpage_bind(uchar socket, code unsigned char *pd)
                        :>* This will bind a webpage to a given socket, after a HTTP-Request was received
                        :>* for this page.
                        :>**********************************************************************************/
                        :>void webpage_bind(uchar sock, code unsigned char *pd){
co:274f: ad 07          :  mov R5,AR7
co:2751: e4             :  clr A
co:2752: fc             :  mov R4,A
co:2753: fe             :  mov R6,A
co:2754: 7f 06          :  mov R7,#6
co:2756: 12 34 21       :  lcall __mul_i2
co:2759: 7a 08          :  mov R2,#((_http_info)>>8)&255
co:275b: 7b 00          :  mov R3,#(_http_info)&255
co:275d: eb             :  mov A,R3
co:275e: 2f             :  add A,R7
co:275f: f9             :  mov R1,A
co:2760: ea             :  mov A,R2
co:2761: 3e             :  addc A,R6
co:2762: f8             :  mov R0,A
                        :  ; variable 'pinfo' assigned to register 'RW01'
                        :>        xdata HTTP_INFO *pinfo;
                        :>        pinfo=&http_info[sock]; // Pointer to HTTP_INFO for the current socket
                        :>
                        :>        pinfo->weblen=*((code uint*)pd);
co:2763: ae 08          :  mov R6,AR8
co:2765: af 09          :  mov R7,AR9
co:2767: 8e 83          :  mov DPH,R6
co:2769: 8f 82          :  mov DPL,R7
co:276b: 12 35 ab       :  lcall __ldc_dptr_r23
co:276e: 74 04          :  mov A,#4
co:2770: 29             :  add A,R1
co:2771: ff             :  mov R7,A
co:2772: e4             :  clr A
co:2773: 38             :  addc A,R0
co:2774: fe             :  mov R6,A
co:2775: 8e 83          :  mov DPH,R6
co:2777: 8f 82          :  mov DPL,R7
co:2779: 12 34 da       :  lcall __st_dptr_r23
                        :>        pd+=2;
co:277c: ae 08          :  mov R6,AR8
co:277e: af 09          :  mov R7,AR9
co:2780: 74 02          :  mov A,#2
co:2782: 2f             :  add A,R7
co:2783: ff             :  mov R7,A
co:2784: e4             :  clr A
co:2785: 3e             :  addc A,R6
co:2786: fe             :  mov R6,A
                        :  ; variable 'pd' assigned to register 'RW67'
                        :>        pinfo->dyna_flag=*pd++;
co:2787: ac 06          :  mov R4,AR6
co:2789: ad 07          :  mov R5,AR7
co:278b: 74 01          :  mov A,#1
co:278d: 2d             :  add A,R5
co:278e: ff             :  mov R7,A
co:278f: e4             :  clr A
co:2790: 3c             :  addc A,R4
co:2791: fe             :  mov R6,A
                        :  ; variable 'pd' assigned to register 'B1_RW89'
co:2792: 8e 08          :  mov AR8,R6
co:2794: 8f 09          :  mov AR9,R7
co:2796: 85 04 83       :  mov DPH,AR4
co:2799: 85 05 82       :  mov DPL,AR5
co:279c: e4             :  clr A
co:279d: 93             :  movc A,@A+DPTR
co:279e: fb             :  mov R3,A
co:279f: 74 01          :  mov A,#1
co:27a1: 29             :  add A,R1
co:27a2: ff             :  mov R7,A
co:27a3: e4             :  clr A
co:27a4: 38             :  addc A,R0
co:27a5: fe             :  mov R6,A
co:27a6: 85 06 83       :  mov DPH,AR6
co:27a9: 85 07 82       :  mov DPL,AR7
co:27ac: eb             :  mov A,R3
co:27ad: f0             :  movx @DPTR,A
                        :>        pinfo->pweb=pd;
co:27ae: 74 02          :  mov A,#2
co:27b0: 29             :  add A,R1
co:27b1: fb             :  mov R3,A
co:27b2: e4             :  clr A
co:27b3: 38             :  addc A,R0
co:27b4: fa             :  mov R2,A
co:27b5: ae 08          :  mov R6,AR8
co:27b7: af 09          :  mov R7,AR9
co:27b9: 8a 83          :  mov DPH,R2
co:27bb: 8b 82          :  mov DPL,R3
co:27bd: 12 35 40       :  lcall __st_dptr_r67
co:27c0: 22             :  ret
                        : ; end of function webpage_bind
                        : ; used: R01234567 BR01------ DPTR ACC PSW B
                        : 
                        :  .segment bss, sclass xram, notext
                        :  .export _web_args ; xdata unsigned char *xdata web_args
                        : _web_args: ; xdata unsigned char *xdata web_args
xr:07fe: xx xx          :  .ds.b 2
                        :  .export _http_info ; xdata HTTP_INFO http_info[2]
                        : _http_info: ; xdata HTTP_INFO http_info[2]
xr:0800: xx xx xx xx xx :  .ds.b 12
xr:0805: xx xx xx xx xx :
xr:080a: xx xx          :
                        :  .import _poll_net ; unsigned int poll_net(void)
                        :  .import _close_socket_tcp ; unsigned int close_socket_tcp(unsigned char)
                        :  .import _notready_socket_tcp ; unsigned int notready_socket_tcp(unsigned char, unsigned char)
                        :  .import _send_socket_tcp ; unsigned int send_socket_tcp(unsigned char, xdata unsigned char *, unsigne
                        :  .import _allocate_tx_buf ; xdata unsigned char *allocate_tx_buf(void)
                        :  .import _rcv_len ; xdata unsigned int rcv_len
                        :  .import _rcv_buf ; xdata unsigned char rcv_buf[1400]
                        :  .import _uc_socket ; xdata UC_SOCKET uc_socket[2]
                        :  .end
                        :>}
                        :>
                        :>// EOF
=        _html_notfound =  22a8 (hex),   8872 (dez), text
=         _webpage_bind =  274b (hex),  10059 (dez), text
=            _http_info =   800 (hex),   2048 (dez), xram
=         _webpage_name =  1e09 (hex),   7689 (dez), text
=          _gendyn_html =  2110 (hex),   8464 (dez), text
=             _web_args =   7fe (hex),   2046 (dez), xram
=                _csock =     7 (hex),      7 (dez), xram
=       _url_getarg_str =  247a (hex),   9338 (dez), text
=        _url_getarg_no =  2402 (hex),   9218 (dez), text
=       _poll_webserver =  1e50 (hex),   7760 (dez), text

objectfile:tcpip\dhcp.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'tcpip\dhcp.c', time: Thu Dec 14 11:33:34 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :         .include <reg52.def>
                        : ; **** 80C52 (extended) defs ***
                        : 
                        :         .hide
                        :         .show
                        :  .export _send_DHCP_DISCOVER ; void send_DHCP_DISCOVER(unsigned char, xdata unsigned char *)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_DHCP_DISCOVER
                        : _send_DHCP_DISCOVER: ; void send_DHCP_DISCOVER(unsigned char, xdata unsigned char *)
                        :  ; parameter 'pBfr' in 'RW45' moved and assigned to local '?send_DHCP_DISCOVER_pBfr'
                        :  ; parameter 'sock' in 'R7' moved and assigned to local '?send_DHCP_DISCOVER_sock'
co:2519: 8c 32          :  mov ?send_DHCP_DISCOVER_pBfr,R4
co:251b: 8d 33          :  mov ?send_DHCP_DISCOVER_pBfr+1,R5
co:251d: 8f 34          :  mov ?send_DHCP_DISCOVER_sock,R7
                        :>/* $Workfile:   dhcp.c $                                                                              
                        :>/* $Revision: 1.1 $                                             */
                        :>/* $Author: hse00045 $                                                                                
                        :>/* $Date: 2003/14/02 19:31:38 $                                                                       
                        :>/* Description: DHCP Client                                     */
                        :>/*                                                                                                    
                        :>/* Remarks:     No remarks.                                     */
                        :>/*
                        :>DESCRIPTION :  DHCP protocol messaging flow
                        :>                             |                      |
                        :>                             |   DHCP DISCOVER      |
                        :>                             |--------------------->|
                        :>                             |      DHCP OFFER      |
                        :>                DHCP Client  |<---------------------|  DHCP SERVER
                        :>                             |   DHCP REQUEST       |
                        :>                             |--------------------->|
                        :>                             |   DHCP ACK           |
                        :>                             |<---------------------|
                        :>                             |                          |
                        :>*/
                        :>#include <reg52.h>
                        :>#include <stdio.h>
                        :>#include <ctype.h>
                        :>#include <string.h>
                        :>#include "net.h"
                        :>#include "netutil.h"
                        :>#include "dhcp.h"
                        :>
                        :>
                        :>// Create Discover DHCP packet and broadcast it.
                        :>void send_DHCP_DISCOVER(uchar sock,xdata uchar *pBfr)
                        :>{
co:251f: 85 32 83       :  mov DPH,?send_DHCP_DISCOVER_pBfr
co:2522: 85 33 82       :  mov DPL,?send_DHCP_DISCOVER_pBfr+1
co:2525: 74 01          :  mov A,#1
co:2527: f0             :  movx @DPTR,A
                        :>   
                        :>        #define MSG ((xdata RIP_MSG*) pBfr)
                        :>        // Generate DISCOVER DHCP PACKET
                        :>        // setting values as DHCP Protocol
                        :>        MSG->op = DHCP_BOOTREQUEST;
                        :>        MSG->htype = DHCP_HTYPE10MB;
co:2528: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:252a: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:252c: 0f             :  inc R7
co:252d: ef             :  mov A,R7
co:252e: 70 01          :  jnz ?__1
co:2530: 0e             :  inc R6
                        : ?__1:
co:2531: 85 06 83       :  mov DPH,AR6
co:2534: 85 07 82       :  mov DPL,AR7
co:2537: 74 01          :  mov A,#1
co:2539: f0             :  movx @DPTR,A
                        :>        MSG->hlen = DHCP_HLENETHERNET;
co:253a: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:253c: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:253e: 74 02          :  mov A,#2
co:2540: 2f             :  add A,R7
co:2541: ff             :  mov R7,A
co:2542: e4             :  clr A
co:2543: 3e             :  addc A,R6
co:2544: fe             :  mov R6,A
co:2545: 85 06 83       :  mov DPH,AR6
co:2548: 85 07 82       :  mov DPL,AR7
co:254b: 74 06          :  mov A,#6
co:254d: f0             :  movx @DPTR,A
                        :>        MSG->hops = DHCP_HOPS;
co:254e: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:2550: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:2552: 74 03          :  mov A,#3
co:2554: 2f             :  add A,R7
co:2555: ff             :  mov R7,A
co:2556: e4             :  clr A
co:2557: 3e             :  addc A,R6
co:2558: fe             :  mov R6,A
co:2559: 85 06 83       :  mov DPH,AR6
co:255c: 85 07 82       :  mov DPL,AR7
co:255f: e4             :  clr A
co:2560: f0             :  movx @DPTR,A
                        :>        MSG->xid = DHCP_XID;
co:2561: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:2563: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:2565: 74 04          :  mov A,#4
co:2567: 2f             :  add A,R7
co:2568: fb             :  mov R3,A
co:2569: e4             :  clr A
co:256a: 3e             :  addc A,R6
co:256b: fa             :  mov R2,A
co:256c: 7c 12          :  mov R4,#18
co:256e: 7d 34          :  mov R5,#52
co:2570: 7e 56          :  mov R6,#86
co:2572: 7f 70          :  mov R7,#112
co:2574: 8a 83          :  mov DPH,R2
co:2576: 8b 82          :  mov DPL,R3
co:2578: 12 34 bc       :  lcall __st_dptr_r47
                        :>        MSG->secs = DHCP_SECS;
co:257b: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:257d: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:257f: 74 08          :  mov A,#8
co:2581: 2f             :  add A,R7
co:2582: fd             :  mov R5,A
co:2583: e4             :  clr A
co:2584: 3e             :  addc A,R6
co:2585: fc             :  mov R4,A
co:2586: e4             :  clr A
co:2587: fe             :  mov R6,A
co:2588: ff             :  mov R7,A
co:2589: 8c 83          :  mov DPH,R4
co:258b: 8d 82          :  mov DPL,R5
co:258d: 12 35 40       :  lcall __st_dptr_r67
                        :>        MSG->flags = 0; //DHCP_FLAGSBROADCAST;
co:2590: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:2592: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:2594: 74 0a          :  mov A,#10
co:2596: 2f             :  add A,R7
co:2597: fd             :  mov R5,A
co:2598: e4             :  clr A
co:2599: 3e             :  addc A,R6
co:259a: fc             :  mov R4,A
co:259b: e4             :  clr A
co:259c: fe             :  mov R6,A
co:259d: ff             :  mov R7,A
co:259e: 8c 83          :  mov DPH,R4
co:25a0: 8d 82          :  mov DPL,R5
co:25a2: 12 35 40       :  lcall __st_dptr_r67
                        :>  
                        :>        memset(MSG->ciaddr,0,RIP_MSG_SIZE-12);
co:25a5: 7a 02          :  mov R2,#2
co:25a7: 7b 18          :  mov R3,#24
co:25a9: e4             :  clr A
co:25aa: fd             :  mov R5,A
co:25ab: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:25ad: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:25af: 74 0c          :  mov A,#12
co:25b1: 2f             :  add A,R7
co:25b2: ff             :  mov R7,A
co:25b3: e4             :  clr A
co:25b4: 3e             :  addc A,R6
co:25b5: fe             :  mov R6,A
co:25b6: 12 24 ef       :  lcall _memset
                        :>
                        :>        // setting default Mac Address Value.
                        :>        memcpy(MSG->chaddr,my_mac,6);
co:25b9: 7a 00          :  mov R2,#0
co:25bb: 7b 06          :  mov R3,#6
co:25bd: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:25bf: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:25c1: 74 1c          :  mov A,#28
co:25c3: 2f             :  add A,R7
co:25c4: fd             :  mov R5,A
co:25c5: e4             :  clr A
co:25c6: 3e             :  addc A,R6
co:25c7: fc             :  mov R4,A
co:25c8: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:25ca: 7f 00          :  mov R7,#(_my_mac)&255
co:25cc: 12 23 e5       :  lcall _xram_fast_copy
                        :>        
                        :>        *((xdata unsigned long*)MSG->OPT)=MAGIC_COOKIE;
co:25cf: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:25d1: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:25d3: 74 ec          :  mov A,#236
co:25d5: 2f             :  add A,R7
co:25d6: fb             :  mov R3,A
co:25d7: e4             :  clr A
co:25d8: 3e             :  addc A,R6
co:25d9: fa             :  mov R2,A
co:25da: 7c 63          :  mov R4,#99
co:25dc: 7d 82          :  mov R5,#130
co:25de: 7e 53          :  mov R6,#83
co:25e0: 7f 63          :  mov R7,#99
co:25e2: 8a 83          :  mov DPH,R2
co:25e4: 8b 82          :  mov DPL,R3
co:25e6: 12 34 bc       :  lcall __st_dptr_r47
                        :>        
                        :>        // Option Request Param.
                        :>        MSG->OPT[4] = dhcpMessageType;
co:25e9: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:25eb: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:25ed: 74 f0          :  mov A,#240
co:25ef: 2f             :  add A,R7
co:25f0: ff             :  mov R7,A
co:25f1: e4             :  clr A
co:25f2: 3e             :  addc A,R6
co:25f3: fe             :  mov R6,A
co:25f4: 85 06 83       :  mov DPH,AR6
co:25f7: 85 07 82       :  mov DPL,AR7
co:25fa: 74 35          :  mov A,#53
co:25fc: f0             :  movx @DPTR,A
                        :>        MSG->OPT[5] = 0x01;
co:25fd: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:25ff: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:2601: 74 f1          :  mov A,#241
co:2603: 2f             :  add A,R7
co:2604: ff             :  mov R7,A
co:2605: e4             :  clr A
co:2606: 3e             :  addc A,R6
co:2607: fe             :  mov R6,A
co:2608: 85 06 83       :  mov DPH,AR6
co:260b: 85 07 82       :  mov DPL,AR7
co:260e: 74 01          :  mov A,#1
co:2610: f0             :  movx @DPTR,A
                        :>        MSG->OPT[6] = DHCP_DISCOVER;
co:2611: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:2613: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:2615: 74 f2          :  mov A,#242
co:2617: 2f             :  add A,R7
co:2618: ff             :  mov R7,A
co:2619: e4             :  clr A
co:261a: 3e             :  addc A,R6
co:261b: fe             :  mov R6,A
co:261c: 85 06 83       :  mov DPH,AR6
co:261f: 85 07 82       :  mov DPL,AR7
co:2622: 74 01          :  mov A,#1
co:2624: f0             :  movx @DPTR,A
                        :>        MSG->OPT[7] = dhcpParamRequest;
co:2625: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:2627: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:2629: 74 f3          :  mov A,#243
co:262b: 2f             :  add A,R7
co:262c: ff             :  mov R7,A
co:262d: e4             :  clr A
co:262e: 3e             :  addc A,R6
co:262f: fe             :  mov R6,A
co:2630: 85 06 83       :  mov DPH,AR6
co:2633: 85 07 82       :  mov DPL,AR7
co:2636: 74 37          :  mov A,#55
co:2638: f0             :  movx @DPTR,A
                        :>        MSG->OPT[8] = 0x05;
co:2639: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:263b: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:263d: 74 f4          :  mov A,#244
co:263f: 2f             :  add A,R7
co:2640: ff             :  mov R7,A
co:2641: e4             :  clr A
co:2642: 3e             :  addc A,R6
co:2643: fe             :  mov R6,A
co:2644: 85 06 83       :  mov DPH,AR6
co:2647: 85 07 82       :  mov DPL,AR7
co:264a: 74 05          :  mov A,#5
co:264c: f0             :  movx @DPTR,A
                        :>        MSG->OPT[9] = subnetMask;
co:264d: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:264f: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:2651: 74 f5          :  mov A,#245
co:2653: 2f             :  add A,R7
co:2654: ff             :  mov R7,A
co:2655: e4             :  clr A
co:2656: 3e             :  addc A,R6
co:2657: fe             :  mov R6,A
co:2658: 85 06 83       :  mov DPH,AR6
co:265b: 85 07 82       :  mov DPL,AR7
co:265e: 74 01          :  mov A,#1
co:2660: f0             :  movx @DPTR,A
                        :>        MSG->OPT[10] = routersOnSubnet;
co:2661: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:2663: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:2665: 74 f6          :  mov A,#246
co:2667: 2f             :  add A,R7
co:2668: ff             :  mov R7,A
co:2669: e4             :  clr A
co:266a: 3e             :  addc A,R6
co:266b: fe             :  mov R6,A
co:266c: 85 06 83       :  mov DPH,AR6
co:266f: 85 07 82       :  mov DPL,AR7
co:2672: 74 03          :  mov A,#3
co:2674: f0             :  movx @DPTR,A
                        :>        MSG->OPT[11] = dns;
co:2675: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:2677: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:2679: 74 f7          :  mov A,#247
co:267b: 2f             :  add A,R7
co:267c: ff             :  mov R7,A
co:267d: e4             :  clr A
co:267e: 3e             :  addc A,R6
co:267f: fe             :  mov R6,A
co:2680: 85 06 83       :  mov DPH,AR6
co:2683: 85 07 82       :  mov DPL,AR7
co:2686: 74 06          :  mov A,#6
co:2688: f0             :  movx @DPTR,A
                        :>        MSG->OPT[12] = dhcpT1value;
co:2689: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:268b: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:268d: 74 f8          :  mov A,#248
co:268f: 2f             :  add A,R7
co:2690: ff             :  mov R7,A
co:2691: e4             :  clr A
co:2692: 3e             :  addc A,R6
co:2693: fe             :  mov R6,A
co:2694: 85 06 83       :  mov DPH,AR6
co:2697: 85 07 82       :  mov DPL,AR7
co:269a: 74 3a          :  mov A,#58
co:269c: f0             :  movx @DPTR,A
                        :>        MSG->OPT[13] = dhcpT2value;
co:269d: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:269f: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:26a1: 74 f9          :  mov A,#249
co:26a3: 2f             :  add A,R7
co:26a4: ff             :  mov R7,A
co:26a5: e4             :  clr A
co:26a6: 3e             :  addc A,R6
co:26a7: fe             :  mov R6,A
co:26a8: 85 06 83       :  mov DPH,AR6
co:26ab: 85 07 82       :  mov DPL,AR7
co:26ae: 74 3b          :  mov A,#59
co:26b0: f0             :  movx @DPTR,A
                        :>        
                        :>  MSG->OPT[14]= hostName;
co:26b1: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:26b3: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:26b5: 74 fa          :  mov A,#250
co:26b7: 2f             :  add A,R7
co:26b8: ff             :  mov R7,A
co:26b9: e4             :  clr A
co:26ba: 3e             :  addc A,R6
co:26bb: fe             :  mov R6,A
co:26bc: 85 06 83       :  mov DPH,AR6
co:26bf: 85 07 82       :  mov DPL,AR7
co:26c2: 74 0c          :  mov A,#12
co:26c4: f0             :  movx @DPTR,A
                        :>  MSG->OPT[15]= 4;
co:26c5: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:26c7: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:26c9: 74 fb          :  mov A,#251
co:26cb: 2f             :  add A,R7
co:26cc: ff             :  mov R7,A
co:26cd: e4             :  clr A
co:26ce: 3e             :  addc A,R6
co:26cf: fe             :  mov R6,A
co:26d0: 85 06 83       :  mov DPH,AR6
co:26d3: 85 07 82       :  mov DPL,AR7
co:26d6: 74 04          :  mov A,#4
co:26d8: f0             :  movx @DPTR,A
                        :>  
                        :>//      memcpy(&MSG->OPT[16],"FPGA",4); // fucking compiler
                        :>  MSG->OPT[16] = 'F';
co:26d9: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:26db: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:26dd: 74 fc          :  mov A,#252
co:26df: 2f             :  add A,R7
co:26e0: ff             :  mov R7,A
co:26e1: e4             :  clr A
co:26e2: 3e             :  addc A,R6
co:26e3: fe             :  mov R6,A
co:26e4: 85 06 83       :  mov DPH,AR6
co:26e7: 85 07 82       :  mov DPL,AR7
co:26ea: 74 46          :  mov A,#70
co:26ec: f0             :  movx @DPTR,A
                        :>  MSG->OPT[17] = 'P';
co:26ed: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:26ef: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:26f1: 74 fd          :  mov A,#253
co:26f3: 2f             :  add A,R7
co:26f4: ff             :  mov R7,A
co:26f5: e4             :  clr A
co:26f6: 3e             :  addc A,R6
co:26f7: fe             :  mov R6,A
co:26f8: 85 06 83       :  mov DPH,AR6
co:26fb: 85 07 82       :  mov DPL,AR7
co:26fe: 74 50          :  mov A,#80
co:2700: f0             :  movx @DPTR,A
                        :>  MSG->OPT[18] = 'G';
co:2701: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:2703: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:2705: 74 fe          :  mov A,#254
co:2707: 2f             :  add A,R7
co:2708: ff             :  mov R7,A
co:2709: e4             :  clr A
co:270a: 3e             :  addc A,R6
co:270b: fe             :  mov R6,A
co:270c: 85 06 83       :  mov DPH,AR6
co:270f: 85 07 82       :  mov DPL,AR7
co:2712: 74 47          :  mov A,#71
co:2714: f0             :  movx @DPTR,A
                        :>  MSG->OPT[19] = 'A';
co:2715: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:2717: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:2719: 74 ff          :  mov A,#255
co:271b: 2f             :  add A,R7
co:271c: ff             :  mov R7,A
co:271d: e4             :  clr A
co:271e: 3e             :  addc A,R6
co:271f: fe             :  mov R6,A
co:2720: 85 06 83       :  mov DPH,AR6
co:2723: 85 07 82       :  mov DPL,AR7
co:2726: 74 41          :  mov A,#65
co:2728: f0             :  movx @DPTR,A
                        :>        MSG->OPT[20] = endOption;
co:2729: ae 32          :  mov R6,?send_DHCP_DISCOVER_pBfr
co:272b: af 33          :  mov R7,?send_DHCP_DISCOVER_pBfr+1
co:272d: e4             :  clr A
co:272e: 2f             :  add A,R7
co:272f: ff             :  mov R7,A
co:2730: 74 01          :  mov A,#1
co:2732: 3e             :  addc A,R6
co:2733: fe             :  mov R6,A
co:2734: 85 06 83       :  mov DPH,AR6
co:2737: 85 07 82       :  mov DPL,AR7
co:273a: 74 ff          :  mov A,#255
co:273c: f0             :  movx @DPTR,A
                        :>        send_socket_udp(sock,pBfr,RIP_MSG_SIZE);
co:273d: 7a 02          :  mov R2,#2
co:273f: 7b 24          :  mov R3,#36
co:2741: ac 32          :  mov R4,?send_DHCP_DISCOVER_pBfr
co:2743: ad 33          :  mov R5,?send_DHCP_DISCOVER_pBfr+1
co:2745: af 34          :  mov R7,?send_DHCP_DISCOVER_sock
co:2747: 12 49 52       :  lcall _send_socket_udp
co:274a: 22             :  ret
                        : ; end of function send_DHCP_DISCOVER
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:3 bytes
                        : 
                        :  .export _send_DHCP_REQUEST ; void send_DHCP_REQUEST(unsigned char, xdata unsigned char *)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __send_DHCP_REQUEST
                        : _send_DHCP_REQUEST: ; void send_DHCP_REQUEST(unsigned char, xdata unsigned char *)
                        :  ; parameter 'pBfr' in 'RW45' moved and assigned to local '?send_DHCP_REQUEST_pBfr'
                        :  ; parameter 'sock' in 'R7' moved and assigned to local '?send_DHCP_REQUEST_sock'
co:2dc1: 8c 32          :  mov ?send_DHCP_REQUEST_pBfr,R4
co:2dc3: 8d 33          :  mov ?send_DHCP_REQUEST_pBfr+1,R5
co:2dc5: 8f 34          :  mov ?send_DHCP_REQUEST_sock,R7
                        :>}
                        :>
                        :>
                        :>void send_DHCP_REQUEST(uchar sock,xdata uchar *pBfr)
                        :>{
co:2dc7: 85 32 83       :  mov DPH,?send_DHCP_REQUEST_pBfr
co:2dca: 85 33 82       :  mov DPL,?send_DHCP_REQUEST_pBfr+1
co:2dcd: 74 01          :  mov A,#1
co:2dcf: f0             :  movx @DPTR,A
                        :>//      uint i;
                        :>        #define MSG ((xdata RIP_MSG*) pBfr)
                        :>
                        :>        MSG->op = DHCP_BOOTREQUEST;
                        :>        MSG->htype = DHCP_HTYPE10MB;
co:2dd0: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2dd2: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2dd4: 0f             :  inc R7
co:2dd5: ef             :  mov A,R7
co:2dd6: 70 01          :  jnz ?__2
co:2dd8: 0e             :  inc R6
                        : ?__2:
co:2dd9: 85 06 83       :  mov DPH,AR6
co:2ddc: 85 07 82       :  mov DPL,AR7
co:2ddf: 74 01          :  mov A,#1
co:2de1: f0             :  movx @DPTR,A
                        :>        MSG->hlen = DHCP_HLENETHERNET;
co:2de2: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2de4: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2de6: 74 02          :  mov A,#2
co:2de8: 2f             :  add A,R7
co:2de9: ff             :  mov R7,A
co:2dea: e4             :  clr A
co:2deb: 3e             :  addc A,R6
co:2dec: fe             :  mov R6,A
co:2ded: 85 06 83       :  mov DPH,AR6
co:2df0: 85 07 82       :  mov DPL,AR7
co:2df3: 74 06          :  mov A,#6
co:2df5: f0             :  movx @DPTR,A
                        :>        MSG->hops = DHCP_HOPS;
co:2df6: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2df8: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2dfa: 74 03          :  mov A,#3
co:2dfc: 2f             :  add A,R7
co:2dfd: ff             :  mov R7,A
co:2dfe: e4             :  clr A
co:2dff: 3e             :  addc A,R6
co:2e00: fe             :  mov R6,A
co:2e01: 85 06 83       :  mov DPH,AR6
co:2e04: 85 07 82       :  mov DPL,AR7
co:2e07: e4             :  clr A
co:2e08: f0             :  movx @DPTR,A
                        :>        MSG->xid = DHCP_XID;
co:2e09: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2e0b: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2e0d: 74 04          :  mov A,#4
co:2e0f: 2f             :  add A,R7
co:2e10: fb             :  mov R3,A
co:2e11: e4             :  clr A
co:2e12: 3e             :  addc A,R6
co:2e13: fa             :  mov R2,A
co:2e14: 7c 12          :  mov R4,#18
co:2e16: 7d 34          :  mov R5,#52
co:2e18: 7e 56          :  mov R6,#86
co:2e1a: 7f 70          :  mov R7,#112
co:2e1c: 8a 83          :  mov DPH,R2
co:2e1e: 8b 82          :  mov DPL,R3
co:2e20: 12 34 bc       :  lcall __st_dptr_r47
                        :>        MSG->secs = DHCP_SECS;
co:2e23: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2e25: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2e27: 74 08          :  mov A,#8
co:2e29: 2f             :  add A,R7
co:2e2a: fd             :  mov R5,A
co:2e2b: e4             :  clr A
co:2e2c: 3e             :  addc A,R6
co:2e2d: fc             :  mov R4,A
co:2e2e: e4             :  clr A
co:2e2f: fe             :  mov R6,A
co:2e30: ff             :  mov R7,A
co:2e31: 8c 83          :  mov DPH,R4
co:2e33: 8d 82          :  mov DPL,R5
co:2e35: 12 35 40       :  lcall __st_dptr_r67
                        :>        MSG->flags = DHCP_FLAGSBROADCAST;
co:2e38: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2e3a: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2e3c: 74 0a          :  mov A,#10
co:2e3e: 2f             :  add A,R7
co:2e3f: fd             :  mov R5,A
co:2e40: e4             :  clr A
co:2e41: 3e             :  addc A,R6
co:2e42: fc             :  mov R4,A
co:2e43: 7e 80          :  mov R6,#128
co:2e45: 7f 00          :  mov R7,#0
co:2e47: 8c 83          :  mov DPH,R4
co:2e49: 8d 82          :  mov DPL,R5
co:2e4b: 12 35 40       :  lcall __st_dptr_r67
                        :>
                        :>        *((xdata unsigned long*)MSG->ciaddr)=my_ip.ipl;
co:2e4e: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2e50: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2e52: 74 0c          :  mov A,#12
co:2e54: 2f             :  add A,R7
co:2e55: fb             :  mov R3,A
co:2e56: e4             :  clr A
co:2e57: 3e             :  addc A,R6
co:2e58: fa             :  mov R2,A
co:2e59: 90 07 fa       :  mov DPTR,#_my_ip
co:2e5c: 12 34 f2       :  lcall __ld_dptr_r47
co:2e5f: 8a 83          :  mov DPH,R2
co:2e61: 8b 82          :  mov DPL,R3
co:2e63: 12 34 bc       :  lcall __st_dptr_r47
                        :>        memset(MSG->yiaddr,0,RIP_MSG_SIZE-16);
co:2e66: 7a 02          :  mov R2,#2
co:2e68: 7b 14          :  mov R3,#20
co:2e6a: e4             :  clr A
co:2e6b: fd             :  mov R5,A
co:2e6c: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2e6e: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2e70: 74 10          :  mov A,#16
co:2e72: 2f             :  add A,R7
co:2e73: ff             :  mov R7,A
co:2e74: e4             :  clr A
co:2e75: 3e             :  addc A,R6
co:2e76: fe             :  mov R6,A
co:2e77: 12 24 ef       :  lcall _memset
                        :>        memcpy(MSG->chaddr,my_mac,6);
co:2e7a: 7a 00          :  mov R2,#0
co:2e7c: 7b 06          :  mov R3,#6
co:2e7e: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2e80: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2e82: 74 1c          :  mov A,#28
co:2e84: 2f             :  add A,R7
co:2e85: fd             :  mov R5,A
co:2e86: e4             :  clr A
co:2e87: 3e             :  addc A,R6
co:2e88: fc             :  mov R4,A
co:2e89: 7e 00          :  mov R6,#((_my_mac)>>8)&255
co:2e8b: 7f 00          :  mov R7,#(_my_mac)&255
co:2e8d: 12 23 e5       :  lcall _xram_fast_copy
                        :>        *((xdata unsigned long *)MSG->OPT)=MAGIC_COOKIE;
co:2e90: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2e92: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2e94: 74 ec          :  mov A,#236
co:2e96: 2f             :  add A,R7
co:2e97: fb             :  mov R3,A
co:2e98: e4             :  clr A
co:2e99: 3e             :  addc A,R6
co:2e9a: fa             :  mov R2,A
co:2e9b: 7c 63          :  mov R4,#99
co:2e9d: 7d 82          :  mov R5,#130
co:2e9f: 7e 53          :  mov R6,#83
co:2ea1: 7f 63          :  mov R7,#99
co:2ea3: 8a 83          :  mov DPH,R2
co:2ea5: 8b 82          :  mov DPL,R3
co:2ea7: 12 34 bc       :  lcall __st_dptr_r47
                        :>
                        :>        // Option Request Param.
                        :>        MSG->OPT[4] = dhcpMessageType;
co:2eaa: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2eac: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2eae: 74 f0          :  mov A,#240
co:2eb0: 2f             :  add A,R7
co:2eb1: ff             :  mov R7,A
co:2eb2: e4             :  clr A
co:2eb3: 3e             :  addc A,R6
co:2eb4: fe             :  mov R6,A
co:2eb5: 85 06 83       :  mov DPH,AR6
co:2eb8: 85 07 82       :  mov DPL,AR7
co:2ebb: 74 35          :  mov A,#53
co:2ebd: f0             :  movx @DPTR,A
                        :>        MSG->OPT[5] = 0x01;
co:2ebe: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2ec0: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2ec2: 74 f1          :  mov A,#241
co:2ec4: 2f             :  add A,R7
co:2ec5: ff             :  mov R7,A
co:2ec6: e4             :  clr A
co:2ec7: 3e             :  addc A,R6
co:2ec8: fe             :  mov R6,A
co:2ec9: 85 06 83       :  mov DPH,AR6
co:2ecc: 85 07 82       :  mov DPL,AR7
co:2ecf: 74 01          :  mov A,#1
co:2ed1: f0             :  movx @DPTR,A
                        :>        MSG->OPT[6] = DHCP_REQUEST;
co:2ed2: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2ed4: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2ed6: 74 f2          :  mov A,#242
co:2ed8: 2f             :  add A,R7
co:2ed9: ff             :  mov R7,A
co:2eda: e4             :  clr A
co:2edb: 3e             :  addc A,R6
co:2edc: fe             :  mov R6,A
co:2edd: 85 06 83       :  mov DPH,AR6
co:2ee0: 85 07 82       :  mov DPL,AR7
co:2ee3: 74 03          :  mov A,#3
co:2ee5: f0             :  movx @DPTR,A
                        :>
                        :>        // DHCP Option Request Param.
                        :>        MSG->OPT[7] = dhcpParamRequest;
co:2ee6: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2ee8: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2eea: 74 f3          :  mov A,#243
co:2eec: 2f             :  add A,R7
co:2eed: ff             :  mov R7,A
co:2eee: e4             :  clr A
co:2eef: 3e             :  addc A,R6
co:2ef0: fe             :  mov R6,A
co:2ef1: 85 06 83       :  mov DPH,AR6
co:2ef4: 85 07 82       :  mov DPL,AR7
co:2ef7: 74 37          :  mov A,#55
co:2ef9: f0             :  movx @DPTR,A
                        :>        MSG->OPT[8] = 0x05;
co:2efa: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2efc: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2efe: 74 f4          :  mov A,#244
co:2f00: 2f             :  add A,R7
co:2f01: ff             :  mov R7,A
co:2f02: e4             :  clr A
co:2f03: 3e             :  addc A,R6
co:2f04: fe             :  mov R6,A
co:2f05: 85 06 83       :  mov DPH,AR6
co:2f08: 85 07 82       :  mov DPL,AR7
co:2f0b: 74 05          :  mov A,#5
co:2f0d: f0             :  movx @DPTR,A
                        :>        MSG->OPT[9] = subnetMask;
co:2f0e: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2f10: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2f12: 74 f5          :  mov A,#245
co:2f14: 2f             :  add A,R7
co:2f15: ff             :  mov R7,A
co:2f16: e4             :  clr A
co:2f17: 3e             :  addc A,R6
co:2f18: fe             :  mov R6,A
co:2f19: 85 06 83       :  mov DPH,AR6
co:2f1c: 85 07 82       :  mov DPL,AR7
co:2f1f: 74 01          :  mov A,#1
co:2f21: f0             :  movx @DPTR,A
                        :>        MSG->OPT[10] = routersOnSubnet;
co:2f22: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2f24: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2f26: 74 f6          :  mov A,#246
co:2f28: 2f             :  add A,R7
co:2f29: ff             :  mov R7,A
co:2f2a: e4             :  clr A
co:2f2b: 3e             :  addc A,R6
co:2f2c: fe             :  mov R6,A
co:2f2d: 85 06 83       :  mov DPH,AR6
co:2f30: 85 07 82       :  mov DPL,AR7
co:2f33: 74 03          :  mov A,#3
co:2f35: f0             :  movx @DPTR,A
                        :>
                        :>        MSG->OPT[11] = dns;
co:2f36: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2f38: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2f3a: 74 f7          :  mov A,#247
co:2f3c: 2f             :  add A,R7
co:2f3d: ff             :  mov R7,A
co:2f3e: e4             :  clr A
co:2f3f: 3e             :  addc A,R6
co:2f40: fe             :  mov R6,A
co:2f41: 85 06 83       :  mov DPH,AR6
co:2f44: 85 07 82       :  mov DPL,AR7
co:2f47: 74 06          :  mov A,#6
co:2f49: f0             :  movx @DPTR,A
                        :>        MSG->OPT[12] = dhcpT1value;
co:2f4a: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2f4c: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2f4e: 74 f8          :  mov A,#248
co:2f50: 2f             :  add A,R7
co:2f51: ff             :  mov R7,A
co:2f52: e4             :  clr A
co:2f53: 3e             :  addc A,R6
co:2f54: fe             :  mov R6,A
co:2f55: 85 06 83       :  mov DPH,AR6
co:2f58: 85 07 82       :  mov DPL,AR7
co:2f5b: 74 3a          :  mov A,#58
co:2f5d: f0             :  movx @DPTR,A
                        :>        MSG->OPT[13] = dhcpT2value;
co:2f5e: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2f60: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2f62: 74 f9          :  mov A,#249
co:2f64: 2f             :  add A,R7
co:2f65: ff             :  mov R7,A
co:2f66: e4             :  clr A
co:2f67: 3e             :  addc A,R6
co:2f68: fe             :  mov R6,A
co:2f69: 85 06 83       :  mov DPH,AR6
co:2f6c: 85 07 82       :  mov DPL,AR7
co:2f6f: 74 3b          :  mov A,#59
co:2f71: f0             :  movx @DPTR,A
                        :>
                        :>  MSG->OPT[14]= hostName;
co:2f72: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2f74: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2f76: 74 fa          :  mov A,#250
co:2f78: 2f             :  add A,R7
co:2f79: ff             :  mov R7,A
co:2f7a: e4             :  clr A
co:2f7b: 3e             :  addc A,R6
co:2f7c: fe             :  mov R6,A
co:2f7d: 85 06 83       :  mov DPH,AR6
co:2f80: 85 07 82       :  mov DPL,AR7
co:2f83: 74 0c          :  mov A,#12
co:2f85: f0             :  movx @DPTR,A
                        :>  MSG->OPT[15]= 4;
co:2f86: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2f88: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2f8a: 74 fb          :  mov A,#251
co:2f8c: 2f             :  add A,R7
co:2f8d: ff             :  mov R7,A
co:2f8e: e4             :  clr A
co:2f8f: 3e             :  addc A,R6
co:2f90: fe             :  mov R6,A
co:2f91: 85 06 83       :  mov DPH,AR6
co:2f94: 85 07 82       :  mov DPL,AR7
co:2f97: 74 04          :  mov A,#4
co:2f99: f0             :  movx @DPTR,A
                        :>//      memcpy(&MSG->OPT[16],"FPGA",4);   // never seen such a stupid compiler before :-(
                        :>  MSG->OPT[16] = 'F';
co:2f9a: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2f9c: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2f9e: 74 fc          :  mov A,#252
co:2fa0: 2f             :  add A,R7
co:2fa1: ff             :  mov R7,A
co:2fa2: e4             :  clr A
co:2fa3: 3e             :  addc A,R6
co:2fa4: fe             :  mov R6,A
co:2fa5: 85 06 83       :  mov DPH,AR6
co:2fa8: 85 07 82       :  mov DPL,AR7
co:2fab: 74 46          :  mov A,#70
co:2fad: f0             :  movx @DPTR,A
                        :>  MSG->OPT[17] = 'P';
co:2fae: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2fb0: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2fb2: 74 fd          :  mov A,#253
co:2fb4: 2f             :  add A,R7
co:2fb5: ff             :  mov R7,A
co:2fb6: e4             :  clr A
co:2fb7: 3e             :  addc A,R6
co:2fb8: fe             :  mov R6,A
co:2fb9: 85 06 83       :  mov DPH,AR6
co:2fbc: 85 07 82       :  mov DPL,AR7
co:2fbf: 74 50          :  mov A,#80
co:2fc1: f0             :  movx @DPTR,A
                        :>  MSG->OPT[18] = 'G';
co:2fc2: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2fc4: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2fc6: 74 fe          :  mov A,#254
co:2fc8: 2f             :  add A,R7
co:2fc9: ff             :  mov R7,A
co:2fca: e4             :  clr A
co:2fcb: 3e             :  addc A,R6
co:2fcc: fe             :  mov R6,A
co:2fcd: 85 06 83       :  mov DPH,AR6
co:2fd0: 85 07 82       :  mov DPL,AR7
co:2fd3: 74 47          :  mov A,#71
co:2fd5: f0             :  movx @DPTR,A
                        :>  MSG->OPT[19] = 'A';
co:2fd6: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2fd8: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2fda: 74 ff          :  mov A,#255
co:2fdc: 2f             :  add A,R7
co:2fdd: ff             :  mov R7,A
co:2fde: e4             :  clr A
co:2fdf: 3e             :  addc A,R6
co:2fe0: fe             :  mov R6,A
co:2fe1: 85 06 83       :  mov DPH,AR6
co:2fe4: 85 07 82       :  mov DPL,AR7
co:2fe7: 74 41          :  mov A,#65
co:2fe9: f0             :  movx @DPTR,A
                        :>        MSG->OPT[20] = endOption;
co:2fea: ae 32          :  mov R6,?send_DHCP_REQUEST_pBfr
co:2fec: af 33          :  mov R7,?send_DHCP_REQUEST_pBfr+1
co:2fee: e4             :  clr A
co:2fef: 2f             :  add A,R7
co:2ff0: ff             :  mov R7,A
co:2ff1: 74 01          :  mov A,#1
co:2ff3: 3e             :  addc A,R6
co:2ff4: fe             :  mov R6,A
co:2ff5: 85 06 83       :  mov DPH,AR6
co:2ff8: 85 07 82       :  mov DPL,AR7
co:2ffb: 74 ff          :  mov A,#255
co:2ffd: f0             :  movx @DPTR,A
                        :>        send_socket_udp(sock,pBfr,RIP_MSG_SIZE);
co:2ffe: 7a 02          :  mov R2,#2
co:3000: 7b 24          :  mov R3,#36
co:3002: ac 32          :  mov R4,?send_DHCP_REQUEST_pBfr
co:3004: ad 33          :  mov R5,?send_DHCP_REQUEST_pBfr+1
co:3006: af 34          :  mov R7,?send_DHCP_REQUEST_sock
co:3008: 12 49 52       :  lcall _send_socket_udp
co:300b: 22             :  ret
                        : ; end of function send_DHCP_REQUEST
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:3 bytes
                        : 
                        :  .export _DefaultNetConfig ; void DefaultNetConfig(void)
                        :  .segment _DefaultNetConfig_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _DefaultNetConfig_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _DefaultNetConfig_formal_near, _DefaultNetConfig_local_near, __DefaultNetConfig
                        : 
                        :  .segment __DefaultNetConfig
                        : _DefaultNetConfig: ; (leaf function) void DefaultNetConfig(void)
                        :>}
                        :>
                        :>void DefaultNetConfig(void)
                        :>{
co:361c: 90 07 fa       :  mov DPTR,#_my_ip
co:361f: 74 c0          :  mov A,#192
co:3621: f0             :  movx @DPTR,A
                        :>        //COMPOSE_IP(my_ip,10,0,0,101);
                        :>        COMPOSE_IP(my_ip,192,168,0,1); 
co:3622: 90 07 fb       :  mov DPTR,#_my_ip+1
co:3625: 74 a8          :  mov A,#168
co:3627: f0             :  movx @DPTR,A
                        : 
co:3628: 90 07 fc       :  mov DPTR,#_my_ip+2
co:362b: e4             :  clr A
co:362c: f0             :  movx @DPTR,A
                        : 
co:362d: 90 07 fd       :  mov DPTR,#_my_ip+3
co:3630: 74 01          :  mov A,#1
co:3632: f0             :  movx @DPTR,A
co:3633: 22             :  ret
                        : ; end of function DefaultNetConfig
                        : ; used: R-------- BR-------- DPTR ACC
                        : 
                        :  .export _SetupTimer ; void SetupTimer(void)
                        :  .segment _SetupTimer_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _SetupTimer_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _SetupTimer_formal_near, _SetupTimer_local_near, __SetupTimer
                        : 
                        :  .segment __SetupTimer
                        : _SetupTimer: ; (leaf function) void SetupTimer(void)
                        :>}
                        :>
                        :>
                        :>void SetupTimer(void) {
co:2c63: c2 8f          :  clr _TF1
co:2c65: c2 8e          :  clr _TR1
                        :>        TR1 = TF1 = 0;  // stop timer 1 
                        :>        TMOD &= ~0xF0;  // clear timer 1 bits 
co:2c67: 53 89 0f       :  anl _TMOD,#15
                        :>        TMOD |= 0x10;     // 16 bit timer 
co:2c6a: 43 89 10       :  orl _TMOD,#16
                        :>
                        :>        TH1 = 0;
co:2c6d: e4             :  clr A
co:2c6e: f5 8d          :  mov _TH1,A
                        :>        TL1 = 0;
co:2c70: e4             :  clr A
co:2c71: f5 8b          :  mov _TL1,A
                        :>  TR1 = 1;
co:2c73: d2 8e          :  setb _TR1
                        :>  ET1 = 0;
co:2c75: c2 ab          :  clr _ET1
co:2c77: 22             :  ret
                        : ; end of function SetupTimer
                        : ; used: R-------- BR-------- ACC
                        : 
                        :  .export _DHCP_SetIP ; char DHCP_SetIP(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __DHCP_SetIP
                        : _DHCP_SetIP: ; char DHCP_SetIP(void)
                        :  ; variable 'type' allocated as 'auto'
                        :>}
                        :>
                        :>
                        :>char DHCP_SetIP()
                        :>{
co:2c78: e4             :  clr A
co:2c79: f5 2d          :  mov ?DHCP_SetIP_type,A
                        :  ; variable 'RetryCnt' allocated as 'auto'
                        :>        uchar i;
                        :>        uchar RetryCnt;
                        :>        uint res;
                        :>        uchar type;                     // DHCP message type
                        :>        xdata uchar *pbuf;
                        :>        unsigned char e;
                        :>
                        :>
                        :>        type = 0;
                        :>        RetryCnt = 0;
co:2c7b: e4             :  clr A
co:2c7c: f5 2e          :  mov ?DHCP_SetIP_RetryCnt,A
                        :>//      len = 0;
                        :>        
                        :>        // Discover DHCP server
                        :>  SOCKET_SETUP(UDP_SOCK,SOCKET_UDP,68,FLAG_PASSIVE_OPEN);
co:2c7e: 90 07 bc       :  mov DPTR,#_uc_socket+50
co:2c81: 74 01          :  mov A,#1
co:2c83: f0             :  movx @DPTR,A
                        : 
co:2c84: 90 07 ca       :  mov DPTR,#_uc_socket+50+14
co:2c87: e4             :  clr A
co:2c88: f0             :  movx @DPTR,A
co:2c89: a3             :  inc DPTR
co:2c8a: 74 44          :  mov A,#68
co:2c8c: f0             :  movx @DPTR,A
                        : 
co:2c8d: 75 2f 00       :  mov _open_socket_udp_formal_near,#0
co:2c90: 75 30 43       :  mov _open_socket_udp_formal_near+1,#67
co:2c93: 78 ff          :  mov R0,#255
co:2c95: 79 ff          :  mov R1,#255
co:2c97: 7a ff          :  mov R2,#255
co:2c99: 7b ff          :  mov R3,#255
co:2c9b: 7f 01          :  mov R7,#1
co:2c9d: 12 49 cb       :  lcall _open_socket_udp
co:2ca0: ee             :  mov A,R6
co:2ca1: 4f             :  orl A,R7
co:2ca2: 60 0e          :  jz ?10
                        :>        if(open_socket_udp(UDP_SOCK,0xffffffff,67)!=0) { 
co:2ca4: 7e 23          :  mov R6,#((?i12)>>8)&255
co:2ca6: 7f 8d          :  mov R7,#(?i12)&255
co:2ca8: 7c 01          :  mov R4,#COS
co:2caa: 12 34 fe       :  lcall _puts
                        :>                puts("Error opening UDP Socket\r");
                        :>                return 0;
co:2cad: e4             :  clr A
co:2cae: ff             :  mov R7,A
co:2caf: 02 2d c0       :  ljmp ?9
                        : ?10:
                        :>        }
                        :>        pbuf=allocate_tx_buf();
co:2cb2: 12 36 57       :  lcall _allocate_tx_buf
                        :  ; variable 'pbuf' allocated as 'auto'
co:2cb5: 8e 2f          :  mov ?DHCP_SetIP_pbuf,R6
co:2cb7: 8f 30          :  mov ?DHCP_SetIP_pbuf+1,R7
co:2cb9: 02 2d 37       :  ljmp ?14
                        : ?13:
                        :  ; variable 'e' allocated as 'auto'
                        :>        while(1)
                        :>        {               
co:2cbc: e4             :  clr A
co:2cbd: f5 31          :  mov ?DHCP_SetIP_e,A
                        :>    e=0;
                        :>                send_DHCP_DISCOVER(UDP_SOCK,pbuf);
co:2cbf: ac 2f          :  mov R4,?DHCP_SetIP_pbuf
co:2cc1: ad 30          :  mov R5,?DHCP_SetIP_pbuf+1
co:2cc3: 7f 01          :  mov R7,#1
co:2cc5: 12 25 19       :  lcall _send_DHCP_DISCOVER
                        :>    SetupTimer();
co:2cc8: 12 2c 63       :  lcall _SetupTimer
                        :  ; variable 'i' allocated as 'auto'
                        :>                // Check continuously with some delay if OFFER msg arrived from the DHCP server
                        :>                for(i = 0 ; i < 32 && !e; i++)
co:2ccb: e4             :  clr A
co:2ccc: f5 32          :  mov ?DHCP_SetIP_i,A
co:2cce: 80 2e          :  sjmp ?19
                        : ?16:
                        :>                {
co:2cd0: c2 8f          :  clr _TF1
co:2cd2: 80 25          :  sjmp ?21
                        : ?20:
                        :>      TF1=0;
                        :>      // wait 1 sec. for an answer to DHCP_DISCOVER message
                        :>      while(!TF1) {
co:2cd4: 12 29 cf       :  lcall _poll_net
co:2cd7: ac 06          :  mov R4,AR6
co:2cd9: ad 07          :  mov R5,AR7
                        :  ; variable 'res' assigned to register 'RW45'
                        :>                        res=poll_net();
                        :>                        if((res&0xff00)==EVENT_UDP_DATARECEIVED)
co:2cdb: 7f 00          :  mov R7,#0
co:2cdd: ec             :  mov A,R4
co:2cde: fe             :  mov R6,A
co:2cdf: bf 00 17       :  cjne R7,#0,?23
co:2ce2: be e2 14       :  cjne R6,#226,?23
                        :>            {
co:2ce5: ed             :  mov A,R5
co:2ce6: ff             :  mov R7,A
co:2ce7: 7e 00          :  mov R6,#0
co:2ce9: 12 30 cc       :  lcall _parseDHCPMSG
co:2cec: 8f 2d          :  mov ?DHCP_SetIP_type,R7
                        :>                        type = parseDHCPMSG(res&0xff);  
                        :>                        if (type == DHCP_OFFER) 
co:2cee: 74 02          :  mov A,#2
co:2cf0: 65 2d          :  xrl A,?DHCP_SetIP_type
co:2cf2: 70 05          :  jnz ?25
                        :>                        {
co:2cf4: 75 31 01       :  mov ?DHCP_SetIP_e,#1
                        :>//                              puts("Receive DHCP_OFFER OK\r\n");
                        :>              e=1;
                        :>                                break;
co:2cf7: 80 03          :  sjmp ?22
                        : ?25:
                        :>                        }
                        :>            }
                        : ?23:
                        :>//                      __wait_ms(5);           
                        :>//                      wait_10ms(5);           // Wait OFFER message
                        :>      }
                        : ?21:
                        : 
co:2cf9: 30 8f d8       :  jnb _TF1,?20
                        : ?22:
                        :>                }
co:2cfc: 05 32          :  inc ?DHCP_SetIP_i
                        : ?19:
                        : 
co:2cfe: 7d 20          :  mov R5,#32
co:2d00: af 32          :  mov R7,?DHCP_SetIP_i
co:2d02: c3             :  clr C
co:2d03: e5 07          :  mov A,AR7
co:2d05: 95 05          :  subb A,AR5
co:2d07: 50 04          :  jnc ?27
co:2d09: e5 31          :  mov A,?DHCP_SetIP_e
co:2d0b: 60 c3          :  jz ?16
                        : ?27:
                        :>                if (type == DHCP_OFFER) {
co:2d0d: 74 02          :  mov A,#2
co:2d0f: 65 2d          :  xrl A,?DHCP_SetIP_type
                        : 
co:2d11: 60 27          :  jz ?15
                        :>                        break;
                        :>                }else if ( RetryCnt++ > 10){
co:2d13: ad 2e          :  mov R5,?DHCP_SetIP_RetryCnt
co:2d15: af 05          :  mov R7,AR5
co:2d17: 0f             :  inc R7
co:2d18: 8f 2e          :  mov ?DHCP_SetIP_RetryCnt,R7
co:2d1a: 7f 0a          :  mov R7,#10
co:2d1c: d3             :  setb C
co:2d1d: ed             :  mov A,R5
co:2d1e: 9f             :  subb A,R7
co:2d1f: 40 16          :  jc ?30
                        : 
co:2d21: c2 8e          :  clr _TR1
                        :>//                close(s);
                        :>      TR1=0;
                        :>                        free_tx_buf(pbuf);
co:2d23: ae 2f          :  mov R6,?DHCP_SetIP_pbuf
co:2d25: af 30          :  mov R7,?DHCP_SetIP_pbuf+1
co:2d27: 12 36 34       :  lcall _free_tx_buf
                        :>                        close_socket_udp(UDP_SOCK);
co:2d2a: 7f 01          :  mov R7,#1
co:2d2c: 12 4b 88       :  lcall _close_socket_udp
                        :>                        DefaultNetConfig();
co:2d2f: 12 36 1c       :  lcall _DefaultNetConfig
                        :>                        return 0;
co:2d32: e4             :  clr A
co:2d33: ff             :  mov R7,A
co:2d34: 02 2d c0       :  ljmp ?9
                        : ?30:
                        :>                }
                        :>        }  
                        : ?14:
                        : 
co:2d37: 02 2c bc       :  ljmp ?13
                        : ?15:
                        :  ; variable 'RetryCnt' allocated as 'auto'
                        :>
                        :>        RetryCnt = 0;
co:2d3a: e4             :  clr A
co:2d3b: f5 2d          :  mov ?i51,A
                        :  ; variable 'type' allocated as 'auto'
                        :>        type = 0;
co:2d3d: e4             :  clr A
co:2d3e: f5 2e          :  mov ?i52,A
co:2d40: 02 2d ad       :  ljmp ?33
                        : ?32:
                        :  ; variable 'e' allocated as 'auto'
                        :>//      len = 0;
                        :>        
                        :>        // After receiving OFFER message, send REQUEST message
                        :>        while(1)
                        :>        {
co:2d43: e4             :  clr A
co:2d44: f5 31          :  mov ?i53,A
                        :>    e=0;
                        :>                send_DHCP_REQUEST(UDP_SOCK,pbuf);
co:2d46: ac 2f          :  mov R4,?DHCP_SetIP_pbuf
co:2d48: ad 30          :  mov R5,?DHCP_SetIP_pbuf+1
co:2d4a: 7f 01          :  mov R7,#1
co:2d4c: 12 2d c1       :  lcall _send_DHCP_REQUEST
                        :>    SetupTimer();
co:2d4f: 12 2c 63       :  lcall _SetupTimer
                        :  ; variable 'i' allocated as 'auto'
                        :>//              puts("Send DHCP REQUEST OK\r\n");
                        :>//              wait_10ms(5);           // Wait REQUEST message
                        :>                // Check continuously with some delay if ACK message arrived from the DHCP server
                        :>                for(i = 0 ; i < 32 && !e; i++)
co:2d52: e4             :  clr A
co:2d53: f5 32          :  mov ?i54,A
co:2d55: 80 2e          :  sjmp ?38
                        : ?35:
                        :>                {
co:2d57: c2 8f          :  clr _TF1
co:2d59: 80 25          :  sjmp ?40
                        : ?39:
                        :>      TF1=0;
                        :>      while(!TF1) {
co:2d5b: 12 29 cf       :  lcall _poll_net
co:2d5e: ac 06          :  mov R4,AR6
co:2d60: ad 07          :  mov R5,AR7
                        :  ; variable 'res' assigned to register 'RW45'
                        :>                        res=poll_net();
                        :>                        if((res&0xff00)==EVENT_UDP_DATARECEIVED)
co:2d62: 7f 00          :  mov R7,#0
co:2d64: ec             :  mov A,R4
co:2d65: fe             :  mov R6,A
co:2d66: bf 00 17       :  cjne R7,#0,?42
co:2d69: be e2 14       :  cjne R6,#226,?42
                        :>                        {
co:2d6c: ed             :  mov A,R5
co:2d6d: ff             :  mov R7,A
co:2d6e: 7e 00          :  mov R6,#0
co:2d70: 12 30 cc       :  lcall _parseDHCPMSG
co:2d73: 8f 2e          :  mov ?i52,R7
                        :>                                type = parseDHCPMSG(res&0xff);                          
                        :>                                if (type == DHCP_ACK)
co:2d75: 74 05          :  mov A,#5
co:2d77: 65 2e          :  xrl A,?i52
co:2d79: 70 05          :  jnz ?44
                        :>                                {
co:2d7b: 75 31 01       :  mov ?i53,#1
                        :>//                                      puts("Receive DHCP_ACK OK\r\n");
                        :>              e=1;
                        :>                                        break;
co:2d7e: 80 03          :  sjmp ?41
                        : ?44:
                        :>                }
                        :>                        }
                        : ?42:
                        :>//                      __wait_ms(5);           
                        :>//                      wait_10ms(5);
                        :>      }
                        : ?40:
                        : 
co:2d80: 30 8f d8       :  jnb _TF1,?39
                        : ?41:
                        :>                }       
co:2d83: 05 32          :  inc ?i54
                        : ?38:
                        : 
co:2d85: 7d 20          :  mov R5,#32
co:2d87: af 32          :  mov R7,?i54
co:2d89: c3             :  clr C
co:2d8a: e5 07          :  mov A,AR7
co:2d8c: 95 05          :  subb A,AR5
co:2d8e: 50 04          :  jnc ?46
co:2d90: e5 31          :  mov A,?i53
co:2d92: 60 c3          :  jz ?35
                        : ?46:
                        :>                if (type == DHCP_ACK) {
co:2d94: 74 05          :  mov A,#5
co:2d96: 65 2e          :  xrl A,?i52
                        : 
co:2d98: 60 16          :  jz ?34
                        :>                        break;
                        :>                }else if (RetryCnt++ > 10){
co:2d9a: ad 2d          :  mov R5,?i51
co:2d9c: af 05          :  mov R7,AR5
co:2d9e: 0f             :  inc R7
co:2d9f: 8f 2d          :  mov ?i51,R7
co:2da1: 7f 0a          :  mov R7,#10
co:2da3: d3             :  setb C
co:2da4: ed             :  mov A,R5
co:2da5: 9f             :  subb A,R7
co:2da6: 40 05          :  jc ?49
                        : 
co:2da8: 12 36 1c       :  lcall _DefaultNetConfig
                        :>//                      free_tx_buf(pbuf);
                        :>//                      close_socket_udp(UDP_SOCK);
                        :>                        DefaultNetConfig();
                        :>                        break;
co:2dab: 80 03          :  sjmp ?34
                        : ?49:
                        :>                        
                        :>                }
                        :>        }
                        : ?33:
                        : 
co:2dad: 02 2d 43       :  ljmp ?32
                        : ?34:
                        :>
                        :>        free_tx_buf(pbuf);
co:2db0: ae 2f          :  mov R6,?DHCP_SetIP_pbuf
co:2db2: af 30          :  mov R7,?DHCP_SetIP_pbuf+1
co:2db4: 12 36 34       :  lcall _free_tx_buf
                        :>        close_socket_udp(UDP_SOCK);
co:2db7: 7f 01          :  mov R7,#1
co:2db9: 12 4b 88       :  lcall _close_socket_udp
                        :>        // Setup packet information from the server
                        :>  TR1=0;
co:2dbc: c2 8e          :  clr _TR1
                        :>        return 1;
co:2dbe: 7f 01          :  mov R7,#1
                        : ?9:
co:2dc0: 22             :  ret
                        : ; end of function DHCP_SetIP
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:6 bytes
                        : 
                        :  .export _parseDHCPMSG ; char parseDHCPMSG(unsigned char)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __parseDHCPMSG
                        : _parseDHCPMSG: ; char parseDHCPMSG(unsigned char)
                        :  ; parameter 'sock' in 'R7'
                        :>}
                        :>
                        :>#define pMSG ((xdata RIP_MSG*) rcv_buf)
                        :>char parseDHCPMSG(uchar sock)
                        :>{
co:30cc: e4             :  clr A
co:30cd: fe             :  mov R6,A
co:30ce: fc             :  mov R4,A
co:30cf: 7d 32          :  mov R5,#50
co:30d1: 12 34 21       :  lcall __mul_i2
co:30d4: 7c 07          :  mov R4,#((_uc_socket+12)>>8)&255
co:30d6: 7d 96          :  mov R5,#(_uc_socket+12)&255
co:30d8: ed             :  mov A,R5
co:30d9: 2f             :  add A,R7
co:30da: ff             :  mov R7,A
co:30db: ec             :  mov A,R4
co:30dc: 3e             :  addc A,R6
co:30dd: fe             :  mov R6,A
co:30de: 8e 83          :  mov DPH,R6
co:30e0: 8f 82          :  mov DPL,R7
co:30e2: 12 35 4c       :  lcall __ld_dptr_r67
co:30e5: ef             :  mov A,R7
co:30e6: 64 43          :  xrl A,#67
co:30e8: 4e             :  orl A,R6
co:30e9: 70 0c          :  jnz ?57
                        :>        uchar type,opt_len;
                        :>        xdata uchar * p;
                        :>        xdata uchar * e;
                        :>
                        :>        if (uc_socket[sock].sremote_port == DHCP_SERVER_PORT)
                        :>        {
co:30eb: 90 02 22       :  mov DPTR,#_rcv_buf+16
co:30ee: 12 34 f2       :  lcall __ld_dptr_r47
co:30f1: 90 07 fa       :  mov DPTR,#_my_ip
co:30f4: 12 34 bc       :  lcall __st_dptr_r47
                        :>                my_ip.ipl=*((xdata unsigned long*)pMSG->yiaddr);
                        :>        }
                        : ?57:
                        :  ; variable 'type' allocated as 'auto'
                        :>        type = 0;       
co:30f7: e4             :  clr A
co:30f8: f5 33          :  mov ?parseDHCPMSG_type,A
                        :>        p = (xdata uchar *)(pMSG);
co:30fa: 7e 02          :  mov R6,#((_rcv_buf)>>8)&255
co:30fc: 7f 12          :  mov R7,#(_rcv_buf)&255
                        :  ; variable 'p' assigned to register 'RW67'
                        :>        p = p + 240;
co:30fe: 74 f0          :  mov A,#240
co:3100: 2f             :  add A,R7
co:3101: ff             :  mov R7,A
co:3102: e4             :  clr A
co:3103: 3e             :  addc A,R6
co:3104: fe             :  mov R6,A
                        :  ; variable 'p' allocated as 'auto'
co:3105: 8e 34          :  mov ?i72,R6
co:3107: 8f 35          :  mov ?i72+1,R7
                        :>        e = p + (rcv_len - 240);
co:3109: 90 02 10       :  mov DPTR,#_rcv_len
co:310c: 12 35 4c       :  lcall __ld_dptr_r67
co:310f: 74 10          :  mov A,#16
co:3111: 2f             :  add A,R7
co:3112: ff             :  mov R7,A
co:3113: 74 ff          :  mov A,#255
co:3115: 3e             :  addc A,R6
co:3116: fe             :  mov R6,A
co:3117: e5 35          :  mov A,?i72+1
co:3119: 2f             :  add A,R7
co:311a: ff             :  mov R7,A
co:311b: e5 34          :  mov A,?i72
co:311d: 3e             :  addc A,R6
co:311e: fe             :  mov R6,A
                        :  ; variable 'e' allocated as 'auto'
co:311f: 8e 36          :  mov ?parseDHCPMSG_e,R6
co:3121: 8f 37          :  mov ?parseDHCPMSG_e+1,R7
co:3123: 02 31 f2       :  ljmp ?60
                        : ?59:
                        :>// OPTIONS auswerten
                        :>        while ( p < e )
                        :>        {
co:3126: 85 34 83       :  mov DPH,?i72
co:3129: 85 35 82       :  mov DPL,?i72+1
co:312c: 74 01          :  mov A,#1
co:312e: 25 82          :  add A,DPL
co:3130: f5 35          :  mov ?i72+1,A
co:3132: e4             :  clr A
co:3133: 35 83          :  addc A,DPH
co:3135: f5 34          :  mov ?i72,A
co:3137: e0             :  movx A,@DPTR
co:3138: fd             :  mov R5,A
co:3139: 64 35          :  xrl A,#53
co:313b: 60 29          :  jz ?67
co:313d: 7f 35          :  mov R7,#53
co:313f: d3             :  setb C
co:3140: ed             :  mov A,R5
co:3141: 9f             :  subb A,R7
co:3142: 50 16          :  jnc ?71
co:3144: ed             :  mov A,R5
co:3145: 70 03          :  jnz ?_21
co:3147: 02 31 f2       :  ljmp ?63
                        : ?_21:
co:314a: ed             :  mov A,R5
co:314b: 64 01          :  xrl A,#1
co:314d: 60 36          :  jz ?68
co:314f: ed             :  mov A,R5
co:3150: 64 03          :  xrl A,#3
co:3152: 70 03          :  jnz ?_23
co:3154: 02 31 ac       :  ljmp ?69
                        : ?_23:
co:3157: 02 31 d3       :  ljmp ?62
                        : ?71:
co:315a: ed             :  mov A,R5
co:315b: f4             :  cpl A
co:315c: 60 03          :  jz ?65
co:315e: 02 31 d3       :  ljmp ?62
                        :>
                        :>                switch ( *p++ ) 
                        :>                {
                        : ?65:
                        :>                        case endOption :
                        :>                            return      type;
co:3161: af 33          :  mov R7,?parseDHCPMSG_type
co:3163: 02 32 0d       :  ljmp ?56
                        :>//                              goto PARSE_END;
                        :>                                break;
                        : ?67:
                        :>        case padOption :
                        :>//                              p++;
                        :>                                break;
                        :>                case dhcpMessageType :
                        :>//                              p++;
                        :>                                p++;
co:3166: ae 34          :  mov R6,?i72
co:3168: af 35          :  mov R7,?i72+1
co:316a: 0f             :  inc R7
co:316b: ef             :  mov A,R7
co:316c: 70 01          :  jnz ?__3
co:316e: 0e             :  inc R6
                        : ?__3:
                        :  ; variable 'p' assigned to register 'RW67'
                        :>                                type = *p++;
co:316f: 8e 83          :  mov DPH,R6
co:3171: 8f 82          :  mov DPL,R7
co:3173: 74 01          :  mov A,#1
co:3175: 25 82          :  add A,DPL
co:3177: f5 35          :  mov ?i72+1,A
co:3179: e4             :  clr A
co:317a: 35 83          :  addc A,DPH
co:317c: f5 34          :  mov ?i72,A
co:317e: e0             :  movx A,@DPTR
co:317f: ff             :  mov R7,A
co:3180: 8f 33          :  mov ?parseDHCPMSG_type,R7
                        :>                                break;
co:3182: 02 31 f2       :  ljmp ?63
                        : ?68:
                        :  ; variable 'p' allocated as 'auto'
                        :>                case subnetMask :
                        :>//                              p++;
                        :>                                p++;
co:3185: 74 01          :  mov A,#1
co:3187: 25 35          :  add A,?i72+1
co:3189: f5 39          :  mov ?i74+1,A
co:318b: e4             :  clr A
co:318c: 35 34          :  addc A,?i72
co:318e: f5 38          :  mov ?i74,A
                        :>                                memcpy(subnet_ip.bytes,p,4);
co:3190: 7a 00          :  mov R2,#0
co:3192: 7b 04          :  mov R3,#4
co:3194: 7c 07          :  mov R4,#((_subnet_ip)>>8)&255
co:3196: 7d f2          :  mov R5,#(_subnet_ip)&255
co:3198: ae 38          :  mov R6,?i74
co:319a: af 39          :  mov R7,?i74+1
co:319c: 12 23 e5       :  lcall _xram_fast_copy
                        :>                                p+=4;
co:319f: 74 04          :  mov A,#4
co:31a1: 25 39          :  add A,?i74+1
co:31a3: f5 35          :  mov ?i72+1,A
co:31a5: e4             :  clr A
co:31a6: 35 38          :  addc A,?i74
co:31a8: f5 34          :  mov ?i72,A
                        :>                                break;
co:31aa: 80 46          :  sjmp ?63
                        : ?69:
                        :  ; variable 'p' allocated as 'auto'
                        :>      case routersOnSubnet :
                        :>//                              p++;
                        :>                                p++;
co:31ac: 74 01          :  mov A,#1
co:31ae: 25 35          :  add A,?i72+1
co:31b0: f5 39          :  mov ?i75+1,A
co:31b2: e4             :  clr A
co:31b3: 35 34          :  addc A,?i72
co:31b5: f5 38          :  mov ?i75,A
                        :>                                memcpy(gateway_ip.bytes,p,4);
co:31b7: 7a 00          :  mov R2,#0
co:31b9: 7b 04          :  mov R3,#4
co:31bb: 7c 07          :  mov R4,#((_gateway_ip)>>8)&255
co:31bd: 7d ee          :  mov R5,#(_gateway_ip)&255
co:31bf: ae 38          :  mov R6,?i75
co:31c1: af 39          :  mov R7,?i75+1
co:31c3: 12 23 e5       :  lcall _xram_fast_copy
                        :>                                p+=4;
co:31c6: 74 04          :  mov A,#4
co:31c8: 25 39          :  add A,?i75+1
co:31ca: f5 35          :  mov ?i72+1,A
co:31cc: e4             :  clr A
co:31cd: 35 38          :  addc A,?i75
co:31cf: f5 34          :  mov ?i72,A
                        :>                                break;
co:31d1: 80 1f          :  sjmp ?63
                        :>/*              case dns :
                        :>//                              p++;
                        :>                                p++;
                        :>                                for (i = 0; i < 4; i++) DNS[i] = *p++;*/
                        :>/*                              WriteScreen("dns : ");
                        :>                                inet_ntoa(DNS,IPAddrStr);
                        :>                                WriteScreen(IPAddrStr); 
                        :>                                WriteScreenf("\r\n");*/
                        :>                                break;
                        : ?62:
                        :>                        default :
                        :>                                opt_len = *p++;
co:31d3: 85 34 83       :  mov DPH,?i72
co:31d6: 85 35 82       :  mov DPL,?i72+1
co:31d9: ae 83          :  mov R6,DPH
co:31db: af 82          :  mov R7,DPL
co:31dd: 74 01          :  mov A,#1
co:31df: 2f             :  add A,R7
co:31e0: fd             :  mov R5,A
co:31e1: e4             :  clr A
co:31e2: 3e             :  addc A,R6
co:31e3: fc             :  mov R4,A
                        :  ; variable 'p' assigned to register 'RW45'
co:31e4: e0             :  movx A,@DPTR
co:31e5: ff             :  mov R7,A
                        :  ; variable 'opt_len' assigned to register 'R7'
                        :>                                p += opt_len;
co:31e6: 7e 00          :  mov R6,#0
co:31e8: ed             :  mov A,R5
co:31e9: 2f             :  add A,R7
co:31ea: ff             :  mov R7,A
co:31eb: ec             :  mov A,R4
co:31ec: 3e             :  addc A,R6
co:31ed: fe             :  mov R6,A
co:31ee: 8e 34          :  mov ?i72,R6
co:31f0: 8f 35          :  mov ?i72+1,R7
                        :>                                break;
                        : ?63:
                        :>                }
                        :>        }
                        : ?60:
                        : 
co:31f2: ae 36          :  mov R6,?parseDHCPMSG_e
co:31f4: af 37          :  mov R7,?parseDHCPMSG_e+1
co:31f6: ab 07          :  mov R3,AR7
co:31f8: aa 06          :  mov R2,AR6
co:31fa: 78 00          :  mov R0,#XDS
co:31fc: ae 34          :  mov R6,?i72
co:31fe: af 35          :  mov R7,?i72+1
co:3200: 7c 00          :  mov R4,#XDS
co:3202: c3             :  clr C
co:3203: 12 33 95       :  lcall __cmp_u4
co:3206: 50 03          :  jnc ?_25
co:3208: 02 31 26       :  ljmp ?59
                        : ?_25:
                        :>//PARSE_END:
                        :>    return      type;
co:320b: af 33          :  mov R7,?parseDHCPMSG_type
                        : ?56:
co:320d: 22             :  ret
                        : ; end of function parseDHCPMSG
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:7 bytes
                        : 
                        :  .import _xram_fast_copy ; void xram_fast_copy(xdata unsigned char *, xdata unsigned char *, unsigned 
                        :  .import _memset ; void memset(xdata unsigned char *, char, unsigned int)
                        :  .import _poll_net ; unsigned int poll_net(void)
                        :  .import _close_socket_udp ; unsigned int close_socket_udp(unsigned char)
                        :  .import _send_socket_udp ; unsigned int send_socket_udp(unsigned char, xdata unsigned char *, unsigne
                        :  .import _open_socket_udp ; unsigned int open_socket_udp(unsigned char, unsigned long, unsigned int)
                        :  .import _free_tx_buf ; void free_tx_buf(xdata unsigned char *)
                        :  .import _allocate_tx_buf ; xdata unsigned char *allocate_tx_buf(void)
                        :  .import _rcv_len ; xdata unsigned int rcv_len
                        :  .import _rcv_buf ; xdata unsigned char rcv_buf[1400]
                        :  .import _uc_socket ; xdata UC_SOCKET uc_socket[2]
                        :  .import _gateway_ip ; xdata IP_ADR gateway_ip
                        :  .import _subnet_ip ; xdata IP_ADR subnet_ip
                        :  .import _my_ip ; xdata IP_ADR my_ip
                        :  .import _my_mac ; xdata unsigned char my_mac[6]
                        :  .import _puts ; int puts(far char *)
                        :  .import _ET1 ; bit unsigned char ET1
                        :  .import _TMOD ; near unsigned char TMOD
                        :  .import _TH1 ; near unsigned char TH1
                        :  .import _TL1 ; near unsigned char TL1
                        :  .import _TF1 ; bit unsigned char TF1
                        :  .import _TR1 ; bit unsigned char TR1
                        :  .segment lit
                        : ?i12: ; code char [26]
co:238d: 45 72 72 6f 72 :  .dc.b "Error opening UDP Socket",13,0
co:2392: 20 6f 70 65 6e :
co:2397: 69 6e 67 20 55 :
co:239c: 44 50 20 53 6f :
co:23a1: 63 6b 65 74 0d :
co:23a6: 00             :
                        :  .end
                        :>}
                        :>
=         _parseDHCPMSG =  30cc (hex),  12492 (dez), text
=    _send_DHCP_REQUEST =  2dc1 (hex),  11713 (dez), text
=           _SetupTimer =  2c63 (hex),  11363 (dez), text
=   _send_DHCP_DISCOVER =  2519 (hex),   9497 (dez), text
=           _DHCP_SetIP =  2c78 (hex),  11384 (dez), text
=     _DefaultNetConfig =  361c (hex),  13852 (dez), text

objectfile:fg1_http.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'fg1_http.c', time: Thu Dec 14 11:33:34 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :         .include <reg52.def>
                        : ; **** 80C52 (extended) defs ***
                        : 
                        :         .hide
                        :         .show
                        :         sevseg_ctrl  = $C0;
                        :   sevseg_data0 = $C1;
                        :   sevseg_data1 = $C2;
                        :   sevseg_data2 = $C3;
                        :   sevseg_data3 = $C4;
                        :   sevseg_en    = $C5;
                        :   _sevseg_ctrl  = sevseg_ctrl;
                        :   _sevseg_data0 = sevseg_data0;
                        :   _sevseg_data1 = sevseg_data1;
                        :   _sevseg_data2 = sevseg_data2;
                        :   _sevseg_data3 = sevseg_data3;
                        :   _sevseg_en    = sevseg_en;
                        : 
                        :   ps2_ctrl    = $d8;
                        :   ps2_rxf     = ps2_ctrl.0;
                        :   ps2_ovf     = ps2_ctrl.1;
                        :   ps2_rx_busy = ps2_ctrl.2;
                        :   ps2_tx_busy = ps2_ctrl.3;
                        :   ps2_ack     = ps2_ctrl.4;
                        :   ps2_init    = ps2_ctrl.7;
                        :   ps2_data    = $0xd9;
                        :   _ps2_ctrl    = ps2_ctrl;
                        :   _ps2_rxf     = ps2_rxf;
                        :   _ps2_ovf     = ps2_ovf;
                        :   _ps2_rx_busy = ps2_rx_busy;
                        :   _ps2_tx_busy = ps2_tx_busy;
                        :   _ps2_ack     = ps2_ack;
                        :   _ps2_init    = ps2_init;
                        :   _ps2_data    = ps2_data;
                        :   bank_sel   = $f9;
                        :   bank_en    = $f8;
                        :   vgaen      = bank_en.4;
                        :   sramb0     = bank_en.5;
                        :   sramen     = bank_en.6;
                        :   ethdis     = bank_en.7;
                        : 
                        :   _bank_sel   = bank_sel;
                        :   _bank_en    = bank_en;
                        :   _vgaen      = vgaen;
                        :   _sramb0     = sramb0;
                        :   _sramen     = sramen;
                        :   _ethdis     = ethdis;
                        :  .segment data, sclass xram
                        :  .export _hitcnt ; xdata unsigned int hitcnt
                        : _hitcnt: ; xdata unsigned int hitcnt
xr:0008: 00 00          :  .dc.w 0
                        :  .export _ad_measure ; void ad_measure(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __ad_measure
                        : _ad_measure: ; void ad_measure(void)
                        :>/*********************************************************************************
                        :>* FG1_HTTP.C
                        :>* 
                        :>* A simple dynamic Webserver on a FlexGate I
                        :>*
                        :>* (C) 2004 Wickenhaeuser
                        :>**********************************************************************************/
                        :>
                        :>#include <stdio.h>
                        :>#include <string.h> 
                        :>#include <ctype.h>
                        :>#include <reg52.h>
                        :>
                        :>#include "fpga_reg.h"
                        :>#include "tcpip/net.h"   // Basic network handling (public)
                        :>#include "tcpip/web_serv.h"  // Webserver
                        :>#include "tcpip/open_ether.h"
                        :>#include "tcpip/dhcp.h"
                        :>#include "i2c.h"
                        :>#include "lcd.h"
                        :>#include "fpga_reg.h"
                        :>
                        :>// Declaration of the Pages
                        :>extern code unsigned char home[];
                        :>//extern code unsigned char form[];
                        :>extern code unsigned char io[];
                        :>extern code unsigned char reply[];
                        :>extern code unsigned char ad_disp[];
                        :>uint hitcnt=0;
                        :>
                        :>// Dynamic Var (max.512+'\0'
                        :>// For ad_disp.html:
                        :>xdata uchar aval_0[5];
                        :>xdata uchar aval_1[5];
                        :>xdata uchar aval_2[5];
                        :>xdata uchar aval_3[5];
                        :>
                        :>// For form.html:
                        :>/*xdata uchar name[21];
                        :>xdata uchar adr[5];
                        :>xdata uchar cont[12];*/
                        :>
                        :>// For io.html:
                        :>xdata uchar En0[8];
                        :>xdata uchar En1[8];
                        :>xdata uchar En2[8];
                        :>xdata uchar En3[8];
                        :>xdata uchar sevseg[5];
                        :>
                        :>xdata uchar C0[8];
                        :>xdata uchar C1[8];
                        :>xdata uchar C2[8];
                        :>xdata uchar C3[8];
                        :>xdata uchar C4[8];
                        :>xdata uchar C5[8];
                        :>xdata uchar C6[8];
                        :>xdata uchar Hcnt[6];
                        :>
                        :>
                        :>// Measures Channel 1-4
                        :>void ad_measure(void) {
co:3016: 12 1a f2       :  lcall _I2C_start
                        :>  I2C_start();
                        :>        I2C_send (0x9e);                        // Send address for IC x Write operation
co:3019: 7f 9e          :  mov R7,#158
co:301b: 12 13 80       :  lcall _I2C_send
                        :>        I2C_send (0x44);                        // Set Output active, Auto increment and Channel 0
co:301e: 7f 44          :  mov R7,#68
co:3020: 12 13 80       :  lcall _I2C_send
                        :>        I2C_send (0x80);
co:3023: 7f 80          :  mov R7,#128
co:3025: 12 13 80       :  lcall _I2C_send
                        :>        I2C_stop();
co:3028: 12 00 0e       :  lcall _I2C_stop
                        :>        I2C_start();
co:302b: 12 1a f2       :  lcall _I2C_start
                        :>        I2C_send (0x9f);                        // Send adres for IC x Read operation
co:302e: 7f 9f          :  mov R7,#159
co:3030: 12 13 80       :  lcall _I2C_send
                        :>        I2C_get(1);                                     // Read last ADC conversion, and start A/D con
co:3033: 7f 01          :  mov R7,#1
co:3035: 12 1a 9c       :  lcall _I2C_get
                        :>
                        :>        sprintf(aval_0,"%u",I2C_get(1)*2);
co:3038: 7f 01          :  mov R7,#1
co:303a: 12 1a 9c       :  lcall _I2C_get
co:303d: 7e 00          :  mov R6,#0
co:303f: ef             :  mov A,R7
co:3040: 2f             :  add A,R7
co:3041: ff             :  mov R7,A
co:3042: ee             :  mov A,R6
co:3043: 33             :  rlc A
co:3044: fe             :  mov R6,A
co:3045: 8e 3d          :  mov _sprintf_formal_near,R6
co:3047: 8f 3e          :  mov _sprintf_formal_near+1,R7
co:3049: 7e 23          :  mov R6,#((?i9)>>8)&255
co:304b: 7f e2          :  mov R7,#(?i9)&255
co:304d: ab 07          :  mov R3,AR7
co:304f: aa 06          :  mov R2,AR6
co:3051: 78 01          :  mov R0,#COS
co:3053: 7e 08          :  mov R6,#((_aval_0)>>8)&255
co:3055: 7f 7e          :  mov R7,#(_aval_0)&255
co:3057: 7c 00          :  mov R4,#XDS
co:3059: 12 33 a6       :  lcall _sprintf
                        :>  sprintf(aval_1,"%u",I2C_get(1)*2);
co:305c: 7f 01          :  mov R7,#1
co:305e: 12 1a 9c       :  lcall _I2C_get
co:3061: 7e 00          :  mov R6,#0
co:3063: ef             :  mov A,R7
co:3064: 2f             :  add A,R7
co:3065: ff             :  mov R7,A
co:3066: ee             :  mov A,R6
co:3067: 33             :  rlc A
co:3068: fe             :  mov R6,A
co:3069: 8e 3d          :  mov _sprintf_formal_near,R6
co:306b: 8f 3e          :  mov _sprintf_formal_near+1,R7
co:306d: 7e 23          :  mov R6,#((?i9)>>8)&255
co:306f: 7f e2          :  mov R7,#(?i9)&255
co:3071: ab 07          :  mov R3,AR7
co:3073: aa 06          :  mov R2,AR6
co:3075: 78 01          :  mov R0,#COS
co:3077: 7e 08          :  mov R6,#((_aval_1)>>8)&255
co:3079: 7f 79          :  mov R7,#(_aval_1)&255
co:307b: 7c 00          :  mov R4,#XDS
co:307d: 12 33 a6       :  lcall _sprintf
                        :>  sprintf(aval_2,"%u",I2C_get(1)*2);
co:3080: 7f 01          :  mov R7,#1
co:3082: 12 1a 9c       :  lcall _I2C_get
co:3085: 7e 00          :  mov R6,#0
co:3087: ef             :  mov A,R7
co:3088: 2f             :  add A,R7
co:3089: ff             :  mov R7,A
co:308a: ee             :  mov A,R6
co:308b: 33             :  rlc A
co:308c: fe             :  mov R6,A
co:308d: 8e 3d          :  mov _sprintf_formal_near,R6
co:308f: 8f 3e          :  mov _sprintf_formal_near+1,R7
co:3091: 7e 23          :  mov R6,#((?i9)>>8)&255
co:3093: 7f e2          :  mov R7,#(?i9)&255
co:3095: ab 07          :  mov R3,AR7
co:3097: aa 06          :  mov R2,AR6
co:3099: 78 01          :  mov R0,#COS
co:309b: 7e 08          :  mov R6,#((_aval_2)>>8)&255
co:309d: 7f 74          :  mov R7,#(_aval_2)&255
co:309f: 7c 00          :  mov R4,#XDS
co:30a1: 12 33 a6       :  lcall _sprintf
                        :>  sprintf(aval_3,"%u",I2C_get(0)*2);
co:30a4: e4             :  clr A
co:30a5: ff             :  mov R7,A
co:30a6: 12 1a 9c       :  lcall _I2C_get
co:30a9: 7e 00          :  mov R6,#0
co:30ab: ef             :  mov A,R7
co:30ac: 2f             :  add A,R7
co:30ad: ff             :  mov R7,A
co:30ae: ee             :  mov A,R6
co:30af: 33             :  rlc A
co:30b0: fe             :  mov R6,A
co:30b1: 8e 3d          :  mov _sprintf_formal_near,R6
co:30b3: 8f 3e          :  mov _sprintf_formal_near+1,R7
co:30b5: 7e 23          :  mov R6,#((?i9)>>8)&255
co:30b7: 7f e2          :  mov R7,#(?i9)&255
co:30b9: ab 07          :  mov R3,AR7
co:30bb: aa 06          :  mov R2,AR6
co:30bd: 78 01          :  mov R0,#COS
co:30bf: 7e 08          :  mov R6,#((_aval_3)>>8)&255
co:30c1: 7f 6f          :  mov R7,#(_aval_3)&255
co:30c3: 7c 00          :  mov R4,#XDS
co:30c5: 12 33 a6       :  lcall _sprintf
                        :>        
                        :>        I2C_stop();
co:30c8: 12 00 0e       :  lcall _I2C_stop
co:30cb: 22             :  ret
                        : ; end of function ad_measure
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _set_chkbox ; void set_chkbox(unsigned char, xdata unsigned char *)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __set_chkbox
                        : _set_chkbox: ; void set_chkbox(unsigned char, xdata unsigned char *)
                        :  ; parameter 'val' in 'R7'
                        :  ; parameter 'bfr' in 'RW45' moved and assigned to local '?set_chkbox_bfr'
co:299a: 8c 30          :  mov ?set_chkbox_bfr,R4
co:299c: 8d 31          :  mov ?set_chkbox_bfr+1,R5
                        :>}
                        :>
                        :>void set_chkbox(uchar val,xdata uchar* bfr) {
co:299e: ef             :  mov A,R7
co:299f: 60 15          :  jz ?11
                        :>  if(val) {
co:29a1: 7e 23          :  mov R6,#((?i13)>>8)&255
co:29a3: 7f da          :  mov R7,#(?i13)&255
co:29a5: ab 07          :  mov R3,AR7
co:29a7: aa 06          :  mov R2,AR6
co:29a9: 78 01          :  mov R0,#COS
co:29ab: ae 30          :  mov R6,?set_chkbox_bfr
co:29ad: af 31          :  mov R7,?set_chkbox_bfr+1
co:29af: 7c 00          :  mov R4,#XDS
co:29b1: 12 35 b3       :  lcall _strcpy
                        :>    strcpy(bfr,"checked");
                        :>  }else{
co:29b4: 80 18          :  sjmp ?12
                        : ?11:
                        : 
co:29b6: 85 30 83       :  mov DPH,?set_chkbox_bfr
co:29b9: 85 31 82       :  mov DPL,?set_chkbox_bfr+1
co:29bc: ae 83          :  mov R6,DPH
co:29be: af 82          :  mov R7,DPL
co:29c0: 0f             :  inc R7
co:29c1: ef             :  mov A,R7
co:29c2: 70 01          :  jnz ?__1
co:29c4: 0e             :  inc R6
                        : ?__1:
                        :  ; variable 'bfr' assigned to register 'RW67'
co:29c5: 74 20          :  mov A,#32
co:29c7: f0             :  movx @DPTR,A
                        :>    *bfr++=' ';
                        :>    *bfr++=0;
co:29c8: 8e 83          :  mov DPH,R6
co:29ca: 8f 82          :  mov DPL,R7
co:29cc: e4             :  clr A
co:29cd: f0             :  movx @DPTR,A
                        :>  }
                        : ?12:
co:29ce: 22             :  ret
                        : ; end of function set_chkbox
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .export _eval_io ; void eval_io(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __eval_io
                        : _eval_io: ; void eval_io(void)
                        :>}
                        :>
                        :>void eval_io(void) {
co:28dc: af c1          :  mov R7,_sevseg_data0
co:28de: ad 07          :  mov R5,AR7
co:28e0: 7c 00          :  mov R4,#0
co:28e2: 7f 08          :  mov R7,#8
co:28e4: ed             :  mov A,R5
co:28e5: 8f f0          :  mov B,R7
co:28e7: 05 f0          :  inc B
co:28e9: 80 05          :  sjmp ?_2
                        : ?_3:
co:28eb: c3             :  clr C
co:28ec: 33             :  rlc A
co:28ed: cc             :  xch A,R4
co:28ee: 33             :  rlc A
co:28ef: cc             :  xch A,R4
                        : ?_2:
co:28f0: d5 f0 f8       :  djnz B,?_3
co:28f3: fd             :  mov R5,A
co:28f4: af c2          :  mov R7,_sevseg_data1
co:28f6: 7e 00          :  mov R6,#0
co:28f8: ed             :  mov A,R5
co:28f9: 4f             :  orl A,R7
co:28fa: ff             :  mov R7,A
co:28fb: ec             :  mov A,R4
co:28fc: 4e             :  orl A,R6
co:28fd: fe             :  mov R6,A
                        :  ; variable 'tmp' assigned to register 'RW67'
                        :>  unsigned short tmp=((unsigned short)sevseg_data0)<<8|sevseg_data1;
                        :>  sprintf(sevseg,"%x",tmp);
co:28fe: 8e 3d          :  mov _sprintf_formal_near,R6
co:2900: 8f 3e          :  mov _sprintf_formal_near+1,R7
co:2902: 7e 23          :  mov R6,#((?i16)>>8)&255
co:2904: 7f d7          :  mov R7,#(?i16)&255
co:2906: ab 07          :  mov R3,AR7
co:2908: aa 06          :  mov R2,AR6
co:290a: 78 01          :  mov R0,#COS
co:290c: 7e 08          :  mov R6,#((_sevseg)>>8)&255
co:290e: 7f 4a          :  mov R7,#(_sevseg)&255
co:2910: 7c 00          :  mov R4,#XDS
co:2912: 12 33 a6       :  lcall _sprintf
                        :>  set_chkbox(sevseg_en&0x01,En0);
co:2915: 7c 08          :  mov R4,#((_En0)>>8)&255
co:2917: 7d 67          :  mov R5,#(_En0)&255
co:2919: af c5          :  mov R7,_sevseg_en
co:291b: 53 07 01       :  anl AR7,#1
co:291e: 12 29 9a       :  lcall _set_chkbox
                        :>  set_chkbox(sevseg_en&0x02,En1);
co:2921: 7c 08          :  mov R4,#((_En1)>>8)&255
co:2923: 7d 5f          :  mov R5,#(_En1)&255
co:2925: af c5          :  mov R7,_sevseg_en
co:2927: 53 07 02       :  anl AR7,#2
co:292a: 12 29 9a       :  lcall _set_chkbox
                        :>  set_chkbox(sevseg_en&0x04,En2);
co:292d: 7c 08          :  mov R4,#((_En2)>>8)&255
co:292f: 7d 57          :  mov R5,#(_En2)&255
co:2931: af c5          :  mov R7,_sevseg_en
co:2933: 53 07 04       :  anl AR7,#4
co:2936: 12 29 9a       :  lcall _set_chkbox
                        :>  set_chkbox(sevseg_en&0x08,En3);
co:2939: 7c 08          :  mov R4,#((_En3)>>8)&255
co:293b: 7d 4f          :  mov R5,#(_En3)&255
co:293d: af c5          :  mov R7,_sevseg_en
co:293f: 53 07 08       :  anl AR7,#8
co:2942: 12 29 9a       :  lcall _set_chkbox
                        :>  
                        :>  set_chkbox(P1&2,C0);
co:2945: 7c 08          :  mov R4,#((_C0)>>8)&255
co:2947: 7d 42          :  mov R5,#(_C0)&255
co:2949: af 90          :  mov R7,_P1
co:294b: 53 07 02       :  anl AR7,#2
co:294e: 12 29 9a       :  lcall _set_chkbox
                        :>  set_chkbox(P1&4,C1);
co:2951: 7c 08          :  mov R4,#((_C1)>>8)&255
co:2953: 7d 3a          :  mov R5,#(_C1)&255
co:2955: af 90          :  mov R7,_P1
co:2957: 53 07 04       :  anl AR7,#4
co:295a: 12 29 9a       :  lcall _set_chkbox
                        :>  set_chkbox(P1&8,C2);
co:295d: 7c 08          :  mov R4,#((_C2)>>8)&255
co:295f: 7d 32          :  mov R5,#(_C2)&255
co:2961: af 90          :  mov R7,_P1
co:2963: 53 07 08       :  anl AR7,#8
co:2966: 12 29 9a       :  lcall _set_chkbox
                        :>  set_chkbox(P1&0x10,C3);
co:2969: 7c 08          :  mov R4,#((_C3)>>8)&255
co:296b: 7d 2a          :  mov R5,#(_C3)&255
co:296d: af 90          :  mov R7,_P1
co:296f: 53 07 10       :  anl AR7,#16
co:2972: 12 29 9a       :  lcall _set_chkbox
                        :>  set_chkbox(P1&0x20,C4);
co:2975: 7c 08          :  mov R4,#((_C4)>>8)&255
co:2977: 7d 22          :  mov R5,#(_C4)&255
co:2979: af 90          :  mov R7,_P1
co:297b: 53 07 20       :  anl AR7,#32
co:297e: 12 29 9a       :  lcall _set_chkbox
                        :>  set_chkbox(P1&0x40,C5);
co:2981: 7c 08          :  mov R4,#((_C5)>>8)&255
co:2983: 7d 1a          :  mov R5,#(_C5)&255
co:2985: af 90          :  mov R7,_P1
co:2987: 53 07 40       :  anl AR7,#64
co:298a: 12 29 9a       :  lcall _set_chkbox
                        :>  set_chkbox(P1&0x80,C6);
co:298d: 7c 08          :  mov R4,#((_C6)>>8)&255
co:298f: 7d 12          :  mov R5,#(_C6)&255
co:2991: af 90          :  mov R7,_P1
co:2993: 53 07 80       :  anl AR7,#128
co:2996: 12 29 9a       :  lcall _set_chkbox
co:2999: 22             :  ret
                        : ; end of function eval_io
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _atox_chr ; unsigned char atox_chr(char)
                        :  .segment _atox_chr_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _atox_chr_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _atox_chr_formal_near, _atox_chr_local_near, __atox_chr
                        : 
                        :  .segment __atox_chr
                        : _atox_chr: ; (leaf function) unsigned char atox_chr(char)
                        :  ; parameter 'xchr' in 'R7'
                        :>  
                        :>}
                        :>
                        :>unsigned char atox_chr(char xchr) {
co:28ca: 74 d0          :  mov A,#208
co:28cc: 2f             :  add A,R7
co:28cd: fd             :  mov R5,A
                        :  ; variable 'tmp' assigned to register 'R5'
                        :>        unsigned char tmp=xchr-'0';
                        :>        if (tmp>9) tmp-=7;
co:28ce: 7f 09          :  mov R7,#9
co:28d0: d3             :  setb C
co:28d1: ed             :  mov A,R5
co:28d2: 9f             :  subb A,R7
co:28d3: 40 04          :  jc ?18
                        : 
co:28d5: 74 f9          :  mov A,#249
co:28d7: 2d             :  add A,R5
co:28d8: fd             :  mov R5,A
                        : ?18:
                        :>        return tmp;
co:28d9: af 05          :  mov R7,AR5
co:28db: 22             :  ret
                        : ; end of function atox_chr
                        : ; used: R-----5-7 BR-------- ACC PSW
                        : 
                        :  .export _isxdigit ; unsigned char isxdigit(char)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __isxdigit
                        : _isxdigit: ; unsigned char isxdigit(char)
                        :  ; parameter 'xchr' in 'R7'
                        :>}
                        :>
                        :>unsigned char isxdigit(char xchr) {
co:28a2: 12 35 7a       :  lcall _toupper
co:28a5: ad 07          :  mov R5,AR7
                        :  ; variable 'xchr' assigned to register 'R5'
                        :>  xchr=toupper(xchr);
                        :>  if((xchr>='0' && xchr<='9') ||
co:28a7: 7f 30          :  mov R7,#48
co:28a9: c3             :  clr C
co:28aa: ed             :  mov A,R5
co:28ab: 9f             :  subb A,R7
co:28ac: 40 07          :  jc ?24
co:28ae: 7f 39          :  mov R7,#57
co:28b0: d3             :  setb C
co:28b1: ed             :  mov A,R5
co:28b2: 9f             :  subb A,R7
co:28b3: 40 0e          :  jc ?23
                        : ?24:
co:28b5: 7f 41          :  mov R7,#65
co:28b7: c3             :  clr C
co:28b8: ed             :  mov A,R5
co:28b9: 9f             :  subb A,R7
co:28ba: 40 0b          :  jc ?21
co:28bc: 7f 46          :  mov R7,#70
co:28be: d3             :  setb C
co:28bf: ed             :  mov A,R5
co:28c0: 9f             :  subb A,R7
co:28c1: 50 04          :  jnc ?21
                        : ?23:
                        :>    (xchr>='A' && xchr<='F')) return 1;
co:28c3: 7f 01          :  mov R7,#1
co:28c5: 80 02          :  sjmp ?20
                        : ?21:
                        :>  return 0;
co:28c7: e4             :  clr A
co:28c8: ff             :  mov R7,A
                        : ?20:
co:28c9: 22             :  ret
                        : ; end of function isxdigit
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _atox ; unsigned short atox(xdata char *)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __atox
                        : _atox: ; unsigned short atox(xdata char *)
                        :  ; parameter 's' in 'RW67' moved and assigned to local '?atox_s'
co:2837: 8e 33          :  mov ?atox_s,R6
co:2839: 8f 34          :  mov ?atox_s+1,R7
                        :  ; variable 'n' allocated as 'auto'
                        :>}
                        :>
                        :>unsigned short atox(char xdata *s){
co:283b: e4             :  clr A
co:283c: f5 35          :  mov ?atox_n,A
co:283e: f5 36          :  mov ?atox_n+1,A
co:2840: 02 28 90       :  ljmp ?28
                        : ?27:
                        :>  unsigned short n=0;
                        :>  unsigned char tmp;
                        :>
                        :>  while(*s) {
co:2843: 85 33 83       :  mov DPH,?atox_s
co:2846: 85 34 82       :  mov DPL,?atox_s+1
co:2849: e0             :  movx A,@DPTR
co:284a: ff             :  mov R7,A
co:284b: 12 28 a2       :  lcall _isxdigit
co:284e: ef             :  mov A,R7
co:284f: 60 12          :  jz ?30
                        :>    if (isxdigit(*s)) {
co:2851: 85 33 83       :  mov DPH,?atox_s
co:2854: 85 34 82       :  mov DPL,?atox_s+1
co:2857: e0             :  movx A,@DPTR
co:2858: ff             :  mov R7,A
co:2859: 12 35 7a       :  lcall _toupper
co:285c: 12 28 ca       :  lcall _atox_chr
co:285f: ad 07          :  mov R5,AR7
                        :  ; variable 'tmp' assigned to register 'R5'
                        :>      tmp=atox_chr(toupper(*s));
                        :>    }else tmp=0;
co:2861: 80 02          :  sjmp ?31
                        : ?30:
                        : 
co:2863: e4             :  clr A
co:2864: fd             :  mov R5,A
                        : ?31:
                        :>    n=(n<<4)|tmp;
co:2865: ab 05          :  mov R3,AR5
co:2867: 7a 00          :  mov R2,#0
co:2869: 7d 04          :  mov R5,#4
co:286b: ae 35          :  mov R6,?atox_n
co:286d: af 36          :  mov R7,?atox_n+1
co:286f: ef             :  mov A,R7
co:2870: 8d f0          :  mov B,R5
co:2872: 05 f0          :  inc B
co:2874: 80 05          :  sjmp ?_10
                        : ?_11:
co:2876: c3             :  clr C
co:2877: 33             :  rlc A
co:2878: ce             :  xch A,R6
co:2879: 33             :  rlc A
co:287a: ce             :  xch A,R6
                        : ?_10:
co:287b: d5 f0 f8       :  djnz B,?_11
co:287e: ff             :  mov R7,A
co:287f: 4b             :  orl A,R3
co:2880: ff             :  mov R7,A
co:2881: ee             :  mov A,R6
co:2882: 4a             :  orl A,R2
co:2883: fe             :  mov R6,A
co:2884: 8e 35          :  mov ?atox_n,R6
co:2886: 8f 36          :  mov ?atox_n+1,R7
                        :>    s++;
co:2888: 05 34          :  inc ?atox_s+1
co:288a: e5 34          :  mov A,?atox_s+1
co:288c: 70 02          :  jnz ?_12
co:288e: 05 33          :  inc ?atox_s
                        : ?_12:
                        :>  }
                        : ?28:
                        : 
co:2890: 85 33 83       :  mov DPH,?atox_s
co:2893: 85 34 82       :  mov DPL,?atox_s+1
co:2896: e0             :  movx A,@DPTR
co:2897: ff             :  mov R7,A
co:2898: 60 03          :  jz ?_13
co:289a: 02 28 43       :  ljmp ?27
                        : ?_13:
                        :>  return n;
co:289d: ae 35          :  mov R6,?atox_n
co:289f: af 36          :  mov R7,?atox_n+1
co:28a1: 22             :  ret
                        : ; end of function atox
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:4 bytes
                        : 
                        :  .export _main ; void main(void)
                        : 
                        : ; *** RESET POINT ***
                        :  .export __reset
                        :  .segment ___reset, org $0
co:0000: 02 1b 1a       :  __reset: ljmp __startup
                        : 
                        :  .hide
                        :  .show
                        : 
                        :  .segment __main
                        : _main: ; void main(void)
                        :>}
                        :>
                        :>/**********************************************************************************
                        :>*  M A I N
                        :>**********************************************************************************/
                        :>void main(void){
co:1b35: 75 89 01       :  mov _TMOD,#1
                        :> uint res;
                        :> uchar i;
                        :> uchar socket;
                        :> xdata uchar *pc;
                        :> 
                        :>  TMOD = 1;
                        :>  SCON = 0x52;    /* SCON */ 
co:1b38: 75 98 52       :  mov _SCON,#82
                        :>  T2CON=0;
co:1b3b: e4             :  clr A
co:1b3c: f5 c8          :  mov _T2CON,A
                        :>  RCAP2L=0xAE;                     // 9600 Baud @ 25 MHz
co:1b3e: 75 ca ae       :  mov _RCAP2L,#174
                        :>  RCAP2H=0xff;
co:1b41: 75 cb ff       :  mov _RCAP2H,#255
                        :>  T2CON=0x30;
co:1b44: 75 c8 30       :  mov _T2CON,#48
                        :>  TR2=1;
co:1b47: d2 ca          :  setb _TR2
                        :>  TR0=1;
co:1b49: d2 8c          :  setb _TR0
                        :>
                        :> hitcnt=0;
co:1b4b: 90 00 08       :  mov DPTR,#_hitcnt
co:1b4e: e4             :  clr A
co:1b4f: f0             :  movx @DPTR,A
co:1b50: a3             :  inc DPTR
co:1b51: f0             :  movx @DPTR,A
                        :> sevseg_ctrl=01;
co:1b52: 75 c0 01       :  mov _sevseg_ctrl,#1
                        :> sevseg_data0=0;
co:1b55: e4             :  clr A
co:1b56: f5 c1          :  mov _sevseg_data0,A
                        :> sevseg_data1=0;
co:1b58: e4             :  clr A
co:1b59: f5 c2          :  mov _sevseg_data1,A
                        :> sevseg_en=0;
co:1b5b: e4             :  clr A
co:1b5c: f5 c5          :  mov _sevseg_en,A
                        :> P1=0;
co:1b5e: e4             :  clr A
co:1b5f: f5 90          :  mov _P1,A
                        :> I2C_init();
co:1b61: 12 30 0c       :  lcall _I2C_init
                        :> _wait_ms(100);
co:1b64: 7e 00          :  mov R6,#0
co:1b66: 7f 64          :  mov R7,#100
co:1b68: 12 1b 07       :  lcall __wait_ms
                        :> LCD_init();
co:1b6b: 12 01 d5       :  lcall _LCD_init
                        :> 
                        :> // A HTTP-Server with only passive sockets requires only an IP address
                        :>
                        :> if(Init_net()) {
co:1b6e: 12 28 15       :  lcall _Init_net
co:1b71: ef             :  mov A,R7
co:1b72: 60 11          :  jz ?33
                        : 
co:1b74: 7e 23          :  mov R6,#((?i35)>>8)&255
co:1b76: 7f c9          :  mov R7,#(?i35)&255
co:1b78: 7c 01          :  mov R4,#COS
co:1b7a: 12 34 fe       :  lcall _puts
                        :>  puts("<NET FAILURE>"); // Init Variables, Counter, ...
                        :>  sevseg_en=0xff;
co:1b7d: 75 c5 ff       :  mov _sevseg_en,#255
                        :>  sevseg_data0=1;
co:1b80: 75 c1 01       :  mov _sevseg_data0,#1
                        :>  for(;;);
                        : ?36:
                        : 
co:1b83: 80 fe          :  sjmp ?36
                        : ?33:
                        :> }
                        :>
                        :> //COMPOSE_IP(my_ip,192,168,1,156); 
                        :>
                        :>// Capture IP-Adress via DHCP
                        :> COMPOSE_IP(my_ip,0,0,0,0);
co:1b85: 90 07 fa       :  mov DPTR,#_my_ip
co:1b88: e4             :  clr A
co:1b89: f0             :  movx @DPTR,A
                        : 
co:1b8a: 90 07 fb       :  mov DPTR,#_my_ip+1
co:1b8d: e4             :  clr A
co:1b8e: f0             :  movx @DPTR,A
                        : 
co:1b8f: 90 07 fc       :  mov DPTR,#_my_ip+2
co:1b92: e4             :  clr A
co:1b93: f0             :  movx @DPTR,A
                        : 
co:1b94: 90 07 fd       :  mov DPTR,#_my_ip+3
co:1b97: e4             :  clr A
co:1b98: f0             :  movx @DPTR,A
                        : 
co:1b99: 12 2c 78       :  lcall _DHCP_SetIP
                        :  ; variable 'bfr' allocated as 'auto'
                        :> DHCP_SetIP();
                        :> {
co:1b9c: e4             :  clr A
co:1b9d: fb             :  mov R3,A
co:1b9e: 7e 23          :  mov R6,#((?i40)>>8)&255
co:1ba0: 7f b8          :  mov R7,#(?i40)&255
co:1ba2: 7c 01          :  mov R4,#COS
co:1ba4: 12 01 6a       :  lcall _LCD_write_line
                        :>    char bfr[16];
                        :>    LCD_write_line("*FPGA-Webserver*",0);
                        :>    sprintf(bfr,"%u.%u.%u.%u  ",my_ip.bytes[0],my_ip.bytes[1],my_ip.bytes[2],my_ip.bytes[3]);
co:1ba7: 90 07 fd       :  mov DPTR,#_my_ip+3
co:1baa: e0             :  movx A,@DPTR
co:1bab: ff             :  mov R7,A
co:1bac: 7e 00          :  mov R6,#0
co:1bae: 8e 43          :  mov _sprintf_formal_near+6,R6
co:1bb0: 8f 44          :  mov _sprintf_formal_near+7,R7
co:1bb2: 90 07 fc       :  mov DPTR,#_my_ip+2
co:1bb5: e0             :  movx A,@DPTR
co:1bb6: ff             :  mov R7,A
co:1bb7: 7e 00          :  mov R6,#0
co:1bb9: 8e 41          :  mov _sprintf_formal_near+4,R6
co:1bbb: 8f 42          :  mov _sprintf_formal_near+5,R7
co:1bbd: 90 07 fb       :  mov DPTR,#_my_ip+1
co:1bc0: e0             :  movx A,@DPTR
co:1bc1: ff             :  mov R7,A
co:1bc2: 7e 00          :  mov R6,#0
co:1bc4: 8e 3f          :  mov _sprintf_formal_near+2,R6
co:1bc6: 8f 40          :  mov _sprintf_formal_near+3,R7
co:1bc8: 90 07 fa       :  mov DPTR,#_my_ip
co:1bcb: e0             :  movx A,@DPTR
co:1bcc: ff             :  mov R7,A
co:1bcd: 7e 00          :  mov R6,#0
co:1bcf: 8e 3d          :  mov _sprintf_formal_near,R6
co:1bd1: 8f 3e          :  mov _sprintf_formal_near+1,R7
co:1bd3: 7e 23          :  mov R6,#((?i41)>>8)&255
co:1bd5: 7f aa          :  mov R7,#(?i41)&255
co:1bd7: ab 07          :  mov R3,AR7
co:1bd9: aa 06          :  mov R2,AR6
co:1bdb: 78 01          :  mov R0,#COS
co:1bdd: 7f 2d          :  mov R7,#?main_1_bfr
co:1bdf: 7c 02          :  mov R4,#NES
co:1be1: 12 33 a6       :  lcall _sprintf
                        :>    LCD_write_line(bfr,1);
co:1be4: 7b 01          :  mov R3,#1
co:1be6: 7f 2d          :  mov R7,#?main_1_bfr
co:1be8: 7c 02          :  mov R4,#NES
co:1bea: 12 01 6a       :  lcall _LCD_write_line
                        :>//    printf("My MAC: %02x:%02x:%02x:%02x:%02x:%02x\n", my_mac[0],my_mac[1],my_mac[2],my_mac[3],my_mac
                        :> }
co:1bed: e4             :  clr A
co:1bee: fb             :  mov R3,A
                        :  ; variable 'i' assigned to register 'R3'
                        : ?42:
                        :>
                        :>
                        :> // Enable ALL (or less) Sockets  as General Server HTTP at port 80
                        :> for(i=0;i<MAX_SOCK;i++) SOCKET_SETUP(i,SOCKET_TCP,80,FLAG_PASSIVE_OPEN);
co:1bef: af 03          :  mov R7,AR3
co:1bf1: e4             :  clr A
co:1bf2: fe             :  mov R6,A
co:1bf3: fc             :  mov R4,A
co:1bf4: 7d 32          :  mov R5,#50
co:1bf6: 12 34 21       :  lcall __mul_i2
co:1bf9: 74 8a          :  mov A,#(_uc_socket)&255
co:1bfb: 2f             :  add A,R7
co:1bfc: f5 82          :  mov DPL,A
co:1bfe: 74 07          :  mov A,#((_uc_socket)>>8)&255
co:1c00: 3e             :  addc A,R6
co:1c01: f5 83          :  mov DPH,A
co:1c03: 74 02          :  mov A,#2
co:1c05: f0             :  movx @DPTR,A
                        : 
co:1c06: af 03          :  mov R7,AR3
co:1c08: e4             :  clr A
co:1c09: fe             :  mov R6,A
co:1c0a: fc             :  mov R4,A
co:1c0b: 7d 32          :  mov R5,#50
co:1c0d: 12 34 21       :  lcall __mul_i2
co:1c10: 7c 07          :  mov R4,#((_uc_socket+14)>>8)&255
co:1c12: 7d 98          :  mov R5,#(_uc_socket+14)&255
co:1c14: ed             :  mov A,R5
co:1c15: 2f             :  add A,R7
co:1c16: fd             :  mov R5,A
co:1c17: ec             :  mov A,R4
co:1c18: 3e             :  addc A,R6
co:1c19: fc             :  mov R4,A
co:1c1a: 7e 00          :  mov R6,#0
co:1c1c: 7f 50          :  mov R7,#80
co:1c1e: 8c 83          :  mov DPH,R4
co:1c20: 8d 82          :  mov DPL,R5
co:1c22: 12 35 40       :  lcall __st_dptr_r67
                        : 
co:1c25: 0b             :  inc R3
                        : 
co:1c26: bb 02 c6       :  cjne R3,#2,?42
                        : 
                        : ?46:
                        :> // * Now Net is ready to start *
                        :> for(;;){
co:1c29: 12 1e 50       :  lcall _poll_webserver
co:1c2c: ac 06          :  mov R4,AR6
co:1c2e: ad 07          :  mov R5,AR7
                        :  ; variable 'res' assigned to register 'RW45'
                        :>
                        :>  // ENOUGH TIME IN THIS LOOP FOR OTHER JOBS...
                        :>
                        :>  
                        :>  res=poll_webserver();
                        :>  if((res&0xFF00) ==EVENT_HTTP_REQUEST){
co:1c30: 7f 00          :  mov R7,#0
co:1c32: ec             :  mov A,R4
co:1c33: fe             :  mov R6,A
co:1c34: bf 00 f2       :  cjne R7,#0,?46
co:1c37: be 90 ef       :  cjne R6,#144,?46
                        : 
co:1c3a: af 05          :  mov R7,AR5
                        :  ; variable 'socket' allocated as 'auto'
co:1c3c: 8f 2d          :  mov ?main_socket,R7
                        :>   socket=(uchar)res;
                        :>
                        :>   pc=webpage_name(); // get name of requested page
co:1c3e: 12 1e 09       :  lcall _webpage_name
                        :  ; variable 'pc' allocated as 'auto'
co:1c41: 8e 2e          :  mov ?main_pc,R6
co:1c43: 8f 2f          :  mov ?main_pc+1,R7
                        :>
                        :>//   printf("'%s'/%u\n",pc,socket); // Show requested page and socket
                        :>
                        :>   if(*pc=='a') {
co:1c45: 85 2e 83       :  mov DPH,?main_pc
co:1c48: 85 2f 82       :  mov DPL,?main_pc+1
co:1c4b: e0             :  movx A,@DPTR
co:1c4c: ff             :  mov R7,A
co:1c4d: bf 61 0e       :  cjne R7,#97,?52
                        : 
co:1c50: 12 30 16       :  lcall _ad_measure
                        :>    ad_measure();
                        :>    webpage_bind(socket,ad_disp);
co:1c53: 7c 15          :  mov R4,#((_ad_disp)>>8)&255
co:1c55: 7d 9b          :  mov R5,#(_ad_disp)&255
co:1c57: af 2d          :  mov R7,?main_socket
co:1c59: 12 27 4b       :  lcall _webpage_bind
                        :>   }else if(*pc=='i'){
co:1c5c: 80 cb          :  sjmp ?46
                        : ?52:
                        : 
co:1c5e: 85 2e 83       :  mov DPH,?main_pc
co:1c61: 85 2f 82       :  mov DPL,?main_pc+1
co:1c64: e0             :  movx A,@DPTR
co:1c65: ff             :  mov R7,A
co:1c66: bf 69 0e       :  cjne R7,#105,?54
                        : 
co:1c69: 12 28 dc       :  lcall _eval_io
                        :>    eval_io();
                        :>    webpage_bind(socket,io);
co:1c6c: 7c 0b          :  mov R4,#((_io)>>8)&255
co:1c6e: 7d ab          :  mov R5,#(_io)&255
co:1c70: af 2d          :  mov R7,?main_socket
co:1c72: 12 27 4b       :  lcall _webpage_bind
                        :>//   }else if(*pc=='f'){
                        :>//    webpage_bind(socket,form);
                        :>   }else if(*pc=='r'){
co:1c75: 80 b2          :  sjmp ?46
                        : ?54:
                        : 
co:1c77: 85 2e 83       :  mov DPH,?main_pc
co:1c7a: 85 2f 82       :  mov DPL,?main_pc+1
co:1c7d: e0             :  movx A,@DPTR
co:1c7e: ff             :  mov R7,A
co:1c7f: bf 72 02       :  cjne R7,#114,?_23
co:1c82: 80 03          :  sjmp ?_24
                        : ?_23:
co:1c84: 02 1d 7a       :  ljmp ?56
                        : ?_24:
                        :  ; variable 'en_tmp' allocated as 'auto'
                        : 
co:1c87: e4             :  clr A
co:1c88: f5 2e          :  mov ?main_3_en_tmp,A
                        :  ; variable 'p1_tmp' allocated as 'auto'
                        :>    unsigned char en_tmp=0,p1_tmp=0;
co:1c8a: e4             :  clr A
co:1c8b: f5 2f          :  mov ?main_3_p1_tmp,A
                        :>    webpage_bind(socket,reply);
co:1c8d: 7c 00          :  mov R4,#((_reply)>>8)&255
co:1c8f: 7d 26          :  mov R5,#(_reply)&255
co:1c91: af 2d          :  mov R7,?main_socket
co:1c93: 12 27 4b       :  lcall _webpage_bind
                        :>//    sevseg_en=0;
                        :>//    P1=0;
                        :>    //reply.html?A1=ON&A2=ON&A3=ON&A4=ON&A5=1234&A6=ON&A7=ON&A8=ON&A9=ON&A10=ON&A11=ON&A12=ON&A13=Peri
                        :>    for(;;){
                        : ?58:
                        : 
co:1c96: 12 24 02       :  lcall _url_getarg_no
                        :  ; variable 'i' allocated as 'auto'
co:1c99: 8f 30          :  mov ?i75,R7
                        :>      i=url_getarg_no();
                        :>      if(!i) break;
co:1c9b: e5 30          :  mov A,?i75
co:1c9d: 70 03          :  jnz ?62
                        : 
co:1c9f: 02 1d 71       :  ljmp ?60
                        : ?62:
                        :>      pc=url_getarg_str();
co:1ca2: 12 24 7a       :  lcall _url_getarg_str
                        :  ; variable 'pc' allocated as 'auto'
co:1ca5: 8e 31          :  mov ?i76,R6
co:1ca7: 8f 32          :  mov ?i76+1,R7
                        :>//      printf("Arg A%u: '%s'\n",i,pc); // Opt. Show Args...
                        :>      if(i>=1 && i<=4) {
co:1ca9: 7d 01          :  mov R5,#1
co:1cab: af 30          :  mov R7,?i75
co:1cad: c3             :  clr C
co:1cae: ef             :  mov A,R7
co:1caf: 9d             :  subb A,R5
co:1cb0: 40 3e          :  jc ?64
co:1cb2: 7d 04          :  mov R5,#4
co:1cb4: af 30          :  mov R7,?i75
co:1cb6: d3             :  setb C
co:1cb7: ef             :  mov A,R7
co:1cb8: 9d             :  subb A,R5
co:1cb9: 50 35          :  jnc ?64
                        : 
co:1cbb: 7e 23          :  mov R6,#((?i68)>>8)&255
co:1cbd: 7f a7          :  mov R7,#(?i68)&255
co:1cbf: ab 07          :  mov R3,AR7
co:1cc1: aa 06          :  mov R2,AR6
co:1cc3: 78 01          :  mov R0,#COS
co:1cc5: ae 31          :  mov R6,?i76
co:1cc7: af 32          :  mov R7,?i76+1
co:1cc9: 7c 00          :  mov R4,#XDS
co:1ccb: 12 32 34       :  lcall _strcmp
co:1cce: ee             :  mov A,R6
co:1ccf: 4f             :  orl A,R7
co:1cd0: 70 c4          :  jnz ?58
                        :>        if(!strcmp(pc,"ON")) {
co:1cd2: af 30          :  mov R7,?i75
co:1cd4: ad 07          :  mov R5,AR7
co:1cd6: 1d             :  dec R5
co:1cd7: 7f 01          :  mov R7,#1
co:1cd9: ef             :  mov A,R7
co:1cda: 8d f0          :  mov B,R5
co:1cdc: 05 f0          :  inc B
co:1cde: 80 02          :  sjmp ?_29
                        : ?_30:
co:1ce0: c3             :  clr C
co:1ce1: 33             :  rlc A
                        : ?_29:
co:1ce2: d5 f0 fb       :  djnz B,?_30
co:1ce5: fd             :  mov R5,A
co:1ce6: af 2e          :  mov R7,?main_3_en_tmp
co:1ce8: ef             :  mov A,R7
co:1ce9: 4d             :  orl A,R5
co:1cea: ff             :  mov R7,A
co:1ceb: 8f 2e          :  mov ?main_3_en_tmp,R7
                        :>          en_tmp|=1<<(i-1);
                        :>        }
co:1ced: 02 1c 96       :  ljmp ?58
                        : ?64:
                        :>      }else if(i==5){
co:1cf0: 74 05          :  mov A,#5
co:1cf2: 65 30          :  xrl A,?i75
co:1cf4: 70 2a          :  jnz ?69
                        : 
co:1cf6: ae 31          :  mov R6,?i76
co:1cf8: af 32          :  mov R7,?i76+1
co:1cfa: 12 28 37       :  lcall _atox
co:1cfd: ac 06          :  mov R4,AR6
co:1cff: ad 07          :  mov R5,AR7
                        :  ; variable 'tmp' assigned to register 'RW45'
                        :>        unsigned short tmp=atox(pc);
                        :>        sevseg_data0=tmp>>8;
co:1d01: 7f 08          :  mov R7,#8
co:1d03: ae 04          :  mov R6,AR4
co:1d05: ed             :  mov A,R5
co:1d06: 8f f0          :  mov B,R7
co:1d08: 05 f0          :  inc B
co:1d0a: 80 05          :  sjmp ?_32
                        : ?_33:
co:1d0c: ce             :  xch A,R6
co:1d0d: c3             :  clr C
co:1d0e: 13             :  rrc A
co:1d0f: ce             :  xch A,R6
co:1d10: 13             :  rrc A
                        : ?_32:
co:1d11: d5 f0 f8       :  djnz B,?_33
co:1d14: ff             :  mov R7,A
co:1d15: 8f c1          :  mov _sevseg_data0,R7
                        :>        sevseg_data1=tmp&0xff;
co:1d17: ed             :  mov A,R5
co:1d18: ff             :  mov R7,A
co:1d19: 7e 00          :  mov R6,#0
co:1d1b: 8f c2          :  mov _sevseg_data1,R7
                        :>      }else if(i>=6 && i<=12) {
co:1d1d: 02 1c 96       :  ljmp ?58
                        : ?69:
                        : 
co:1d20: 7d 06          :  mov R5,#6
co:1d22: af 30          :  mov R7,?i75
co:1d24: c3             :  clr C
co:1d25: ef             :  mov A,R7
co:1d26: 9d             :  subb A,R5
co:1d27: 50 03          :  jnc ?_34
co:1d29: 02 1c 96       :  ljmp ?58
                        : ?_34:
co:1d2c: 7d 0c          :  mov R5,#12
co:1d2e: af 30          :  mov R7,?i75
co:1d30: d3             :  setb C
co:1d31: ef             :  mov A,R7
co:1d32: 9d             :  subb A,R5
co:1d33: 40 03          :  jc ?_35
co:1d35: 02 1c 96       :  ljmp ?58
                        : ?_35:
                        : 
co:1d38: 7e 23          :  mov R6,#((?i68)>>8)&255
co:1d3a: 7f a7          :  mov R7,#(?i68)&255
co:1d3c: ab 07          :  mov R3,AR7
co:1d3e: aa 06          :  mov R2,AR6
co:1d40: 78 01          :  mov R0,#COS
co:1d42: ae 31          :  mov R6,?i76
co:1d44: af 32          :  mov R7,?i76+1
co:1d46: 7c 00          :  mov R4,#XDS
co:1d48: 12 32 34       :  lcall _strcmp
co:1d4b: ee             :  mov A,R6
co:1d4c: 4f             :  orl A,R7
co:1d4d: 60 03          :  jz ?_36
co:1d4f: 02 1c 96       :  ljmp ?58
                        : ?_36:
                        :>        if(!strcmp(pc,"ON")) {
co:1d52: af 30          :  mov R7,?i75
co:1d54: 74 fb          :  mov A,#251
co:1d56: 2f             :  add A,R7
co:1d57: fd             :  mov R5,A
co:1d58: 7f 01          :  mov R7,#1
co:1d5a: ef             :  mov A,R7
co:1d5b: 8d f0          :  mov B,R5
co:1d5d: 05 f0          :  inc B
co:1d5f: 80 02          :  sjmp ?_37
                        : ?_38:
co:1d61: c3             :  clr C
co:1d62: 33             :  rlc A
                        : ?_37:
co:1d63: d5 f0 fb       :  djnz B,?_38
co:1d66: fd             :  mov R5,A
co:1d67: af 2f          :  mov R7,?main_3_p1_tmp
co:1d69: ef             :  mov A,R7
co:1d6a: 4d             :  orl A,R5
co:1d6b: ff             :  mov R7,A
co:1d6c: 8f 2f          :  mov ?main_3_p1_tmp,R7
                        :>          p1_tmp|=1<<(i-5);
                        :>        }
co:1d6e: 02 1c 96       :  ljmp ?58
                        : ?60:
                        :>      }
                        :>      // ignore other Args...
                        :>    }
                        :>    P1=p1_tmp;
co:1d71: 85 2f 90       :  mov _P1,?main_3_p1_tmp
                        :>    sevseg_en=en_tmp;
co:1d74: 85 2e c5       :  mov _sevseg_en,?main_3_en_tmp
                        :>    
                        :>   }else{
co:1d77: 02 1c 29       :  ljmp ?46
                        : ?56:
                        : 
co:1d7a: 90 00 08       :  mov DPTR,#_hitcnt
co:1d7d: 12 35 4c       :  lcall __ld_dptr_r67
co:1d80: 0f             :  inc R7
co:1d81: ef             :  mov A,R7
co:1d82: 70 01          :  jnz ?__2
co:1d84: 0e             :  inc R6
                        : ?__2:
co:1d85: 90 00 08       :  mov DPTR,#_hitcnt
co:1d88: 12 35 40       :  lcall __st_dptr_r67
                        :>    hitcnt++;
                        :>    sprintf(Hcnt,"%u",hitcnt);
co:1d8b: 90 00 08       :  mov DPTR,#_hitcnt
co:1d8e: 12 35 4c       :  lcall __ld_dptr_r67
co:1d91: 8e 3d          :  mov _sprintf_formal_near,R6
co:1d93: 8f 3e          :  mov _sprintf_formal_near+1,R7
co:1d95: 7e 23          :  mov R6,#((?i9)>>8)&255
co:1d97: 7f e2          :  mov R7,#(?i9)&255
co:1d99: ab 07          :  mov R3,AR7
co:1d9b: aa 06          :  mov R2,AR6
co:1d9d: 78 01          :  mov R0,#COS
co:1d9f: 7e 08          :  mov R6,#((_Hcnt)>>8)&255
co:1da1: 7f 0c          :  mov R7,#(_Hcnt)&255
co:1da3: 7c 00          :  mov R4,#XDS
co:1da5: 12 33 a6       :  lcall _sprintf
                        :>    webpage_bind(socket,home); // HOME
co:1da8: 7c 02          :  mov R4,#((_home)>>8)&255
co:1daa: 7d 45          :  mov R5,#(_home)&255
co:1dac: af 2d          :  mov R7,?main_socket
co:1dae: 12 27 4b       :  lcall _webpage_bind
                        :>   }
co:1db1: 02 1c 29       :  ljmp ?46
                        : ; end of function main
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:16 bytes
                        : 
                        :  .segment bss, sclass xram, notext
                        :  .export _Hcnt ; xdata unsigned char Hcnt[6]
                        : _Hcnt: ; xdata unsigned char Hcnt[6]
xr:080c: xx xx xx xx xx :  .ds.b 6
xr:0811: xx             :
                        :  .export _C6 ; xdata unsigned char C6[8]
                        : _C6: ; xdata unsigned char C6[8]
xr:0812: xx xx xx xx xx :  .ds.b 8
xr:0817: xx xx xx       :
                        :  .export _C5 ; xdata unsigned char C5[8]
                        : _C5: ; xdata unsigned char C5[8]
xr:081a: xx xx xx xx xx :  .ds.b 8
xr:081f: xx xx xx       :
                        :  .export _C4 ; xdata unsigned char C4[8]
                        : _C4: ; xdata unsigned char C4[8]
xr:0822: xx xx xx xx xx :  .ds.b 8
xr:0827: xx xx xx       :
                        :  .export _C3 ; xdata unsigned char C3[8]
                        : _C3: ; xdata unsigned char C3[8]
xr:082a: xx xx xx xx xx :  .ds.b 8
xr:082f: xx xx xx       :
                        :  .export _C2 ; xdata unsigned char C2[8]
                        : _C2: ; xdata unsigned char C2[8]
xr:0832: xx xx xx xx xx :  .ds.b 8
xr:0837: xx xx xx       :
                        :  .export _C1 ; xdata unsigned char C1[8]
                        : _C1: ; xdata unsigned char C1[8]
xr:083a: xx xx xx xx xx :  .ds.b 8
xr:083f: xx xx xx       :
                        :  .export _C0 ; xdata unsigned char C0[8]
                        : _C0: ; xdata unsigned char C0[8]
xr:0842: xx xx xx xx xx :  .ds.b 8
xr:0847: xx xx xx       :
                        :  .export _sevseg ; xdata unsigned char sevseg[5]
                        : _sevseg: ; xdata unsigned char sevseg[5]
xr:084a: xx xx xx xx xx :  .ds.b 5
                        :  .export _En3 ; xdata unsigned char En3[8]
                        : _En3: ; xdata unsigned char En3[8]
xr:084f: xx xx xx xx xx :  .ds.b 8
xr:0854: xx xx xx       :
                        :  .export _En2 ; xdata unsigned char En2[8]
                        : _En2: ; xdata unsigned char En2[8]
xr:0857: xx xx xx xx xx :  .ds.b 8
xr:085c: xx xx xx       :
                        :  .export _En1 ; xdata unsigned char En1[8]
                        : _En1: ; xdata unsigned char En1[8]
xr:085f: xx xx xx xx xx :  .ds.b 8
xr:0864: xx xx xx       :
                        :  .export _En0 ; xdata unsigned char En0[8]
                        : _En0: ; xdata unsigned char En0[8]
xr:0867: xx xx xx xx xx :  .ds.b 8
xr:086c: xx xx xx       :
                        :  .export _aval_3 ; xdata unsigned char aval_3[5]
                        : _aval_3: ; xdata unsigned char aval_3[5]
xr:086f: xx xx xx xx xx :  .ds.b 5
                        :  .export _aval_2 ; xdata unsigned char aval_2[5]
                        : _aval_2: ; xdata unsigned char aval_2[5]
xr:0874: xx xx xx xx xx :  .ds.b 5
                        :  .export _aval_1 ; xdata unsigned char aval_1[5]
                        : _aval_1: ; xdata unsigned char aval_1[5]
xr:0879: xx xx xx xx xx :  .ds.b 5
                        :  .export _aval_0 ; xdata unsigned char aval_0[5]
                        : _aval_0: ; xdata unsigned char aval_0[5]
xr:087e: xx xx xx xx xx :  .ds.b 5
                        :  .import _ad_disp ; code unsigned char ad_disp[]
                        :  .import _reply ; code unsigned char reply[]
                        :  .import _io ; code unsigned char io[]
                        :  .import _home ; code unsigned char home[]
                        :  .import _LCD_write_line ; void LCD_write_line(char *, unsigned char)
                        :  .import _LCD_init ; void LCD_init(void)
                        :  .import _I2C_get ; unsigned char I2C_get(unsigned char)
                        :  .import _I2C_send ; unsigned char I2C_send(unsigned char)
                        :  .import _I2C_init ; void I2C_init(void)
                        :  .import _I2C_stop ; void I2C_stop(void)
                        :  .import _I2C_start ; void I2C_start(void)
                        :  .import _DHCP_SetIP ; char DHCP_SetIP(void)
                        :  .import _webpage_bind ; void webpage_bind(unsigned char, code unsigned char *)
                        :  .import _url_getarg_str ; xdata unsigned char *url_getarg_str(void)
                        :  .import _url_getarg_no ; unsigned char url_getarg_no(void)
                        :  .import _webpage_name ; xdata unsigned char *webpage_name(void)
                        :  .import _poll_webserver ; unsigned int poll_webserver(void)
                        :  .import _Init_net ; unsigned char Init_net(void)
                        :  .import _uc_socket ; xdata UC_SOCKET uc_socket[2]
                        :  .import _my_ip ; xdata IP_ADR my_ip
                        :  .import _sevseg_en ; near unsigned char sevseg_en
                        :  .import _sevseg_data1 ; near unsigned char sevseg_data1
                        :  .import _sevseg_data0 ; near unsigned char sevseg_data0
                        :  .import _sevseg_ctrl ; near unsigned char sevseg_ctrl
                        :  .import _RCAP2H ; near unsigned char RCAP2H
                        :  .import _RCAP2L ; near unsigned char RCAP2L
                        :  .import _TR2 ; bit unsigned char TR2
                        :  .import _T2CON ; near unsigned char T2CON
                        :  .import _P1 ; near unsigned char P1
                        :  .import _TMOD ; near unsigned char TMOD
                        :  .import _TR0 ; bit unsigned char TR0
                        :  .import _SCON ; near unsigned char SCON
                        :  .import _toupper ; char toupper(char)
                        :  .import _strcpy ; far char *strcpy(far char *, far char *)
                        :  .import _strcmp ; int strcmp(far char *, far char *)
                        :  .import __wait_ms ; void _wait_ms(unsigned int) reentrant
                        :  .import _sprintf ; int sprintf(far char *, far char *, ...)
                        :  .import _puts ; int puts(far char *)
                        :  .segment lit
                        : ?i68: ; code char [3]
co:23a7: 4f 4e 00       :  .dc.b "ON",0
                        : ?i41: ; code char [14]
co:23aa: 25 75 2e 25 75 :  .dc.b "%u.%u.%u.%u  ",0
co:23af: 2e 25 75 2e 25 :
co:23b4: 75 20 20 00    :
                        : ?i40: ; code char [17]
co:23b8: 2a 46 50 47 41 :  .dc.b "*FPGA-Webserver*",0
co:23bd: 2d 57 65 62 73 :
co:23c2: 65 72 76 65 72 :
co:23c7: 2a 00          :
                        : ?i35: ; code char [14]
co:23c9: 3c 4e 45 54 20 :  .dc.b "<NET FAILURE>",0
co:23ce: 46 41 49 4c 55 :
co:23d3: 52 45 3e 00    :
                        : ?i16: ; code char [3]
co:23d7: 25 78 00       :  .dc.b "%x",0
                        : ?i13: ; code char [8]
co:23da: 63 68 65 63 6b :  .dc.b "checked",0
co:23df: 65 64 00       :
                        : ?i9: ; code char [3]
co:23e2: 25 75 00       :  .dc.b "%u",0
                        :  .export PRINTF_TYPE_u
                        : PRINTF_TYPE_u=1
                        :  .export PRINTF_TYPE_x
                        : PRINTF_TYPE_x=1
                        :  .end
                        :>
                        :>/*   for(;;){
                        :>    i=url_getarg_no();
                        :>    if(!i) break;
                        :>    pc=url_getarg_str();
                        :>
                        :>    printf("Arg A%u: '%s'\n",i,pc); // Opt. Show Args...
                        :>
                        :>    if(i==1) strcpy(name,pc); // Copy without regarding max. len...
                        :>    else if(i==2) strcpy(cont,pc);
                        :>    else if(i==3) strcpy(adr,pc);    
                        :>   }*/
                        :>
                        :>
                        :>#ifdef LED
                        :>  }else if(res==EVENT_SOCKET_IDLETIMER){
                        :>              LED^=1; // *** BLINK LED ***
                        :>#endif
                        :>  }
                        :>
                        :>     // else{ *** add a user-task here *** }
                        :>
                        :>  } // for(;;)
                        :>
                        :>}
                        :>
                        :>
                        :>// EOF
=             _atox_chr =  28ca (hex),  10442 (dez), text
=           _ad_measure =  3016 (hex),  12310 (dez), text
=              _eval_io =  28dc (hex),  10460 (dez), text
=               _aval_2 =   874 (hex),   2164 (dez), xram
=               _aval_3 =   86f (hex),   2159 (dez), xram
=               _aval_0 =   87e (hex),   2174 (dez), xram
=               _aval_1 =   879 (hex),   2169 (dez), xram
=                 _Hcnt =   80c (hex),   2060 (dez), xram
=               _hitcnt =     8 (hex),      8 (dez), xram
=               _sevseg =   84a (hex),   2122 (dez), xram
=                  _En0 =   867 (hex),   2151 (dez), xram
=                  _En1 =   85f (hex),   2143 (dez), xram
=                  _En2 =   857 (hex),   2135 (dez), xram
=                  _En3 =   84f (hex),   2127 (dez), xram
=         PRINTF_TYPE_x =     1 (hex),      1 (dez)
=         PRINTF_TYPE_u =     1 (hex),      1 (dez)
=               __reset =     0 (hex),      0 (dez), text
=             _isxdigit =  28a2 (hex),  10402 (dez), text
=                 _atox =  2837 (hex),  10295 (dez), text
=                 _main =  1b35 (hex),   6965 (dez), text
=           _set_chkbox =  299a (hex),  10650 (dez), text
=                   _C2 =   832 (hex),   2098 (dez), xram
=                   _C3 =   82a (hex),   2090 (dez), xram
=                   _C0 =   842 (hex),   2114 (dez), xram
=                   _C1 =   83a (hex),   2106 (dez), xram
=                   _C6 =   812 (hex),   2066 (dez), xram
=                   _C4 =   822 (hex),   2082 (dez), xram
=                   _C5 =   81a (hex),   2074 (dez), xram

objectfile:i2c.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'i2c.c', time: Thu Dec 14 11:33:35 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :         .include <reg51.def>
                        : ; **** 8051 standard defs ***
                        : ; common registers to all 8051's
                        :         .hide
                        :         .show
                        :         .include <reg52.def>
                        : ; **** 80C52 (extended) defs ***
                        : 
                        :         .hide
                        :         .show
                        :  .export _I2C_init ; void I2C_init(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __I2C_init
                        : _I2C_init: ; void I2C_init(void)
                        :>#include <stdio.h>
                        :>#include <reg52.h>
                        :>
                        :>
                        :>#define SDA_HIGH {P0_B0=1; I2C_delay();}
                        :>#define SCL_HIGH {P0_B1=1; while (!P0_B1);I2C_delay();}
                        :>#define SDA_LOW  {P0_B0=0; I2C_delay();}
                        :>#define SCL_LOW  {P0_B1=0; I2C_delay();}
                        :>
                        :>// function prototypes
                        :>
                        :>void I2C_start(void);
                        :>void I2C_stop(void);
                        :>
                        :>// functions
                        :>void I2C_init (void)
                        :>{
co:300c: 75 80 ff       :  mov _P0,#255
                        :>        P0=0xff;          // set the port P0 to a know state
                        :>//      I2C_start();                    // reset the I2C-bus.
                        :>        I2C_stop();
co:300f: 12 00 0e       :  lcall _I2C_stop
                        :>        I2C_stop();
co:3012: 12 00 0e       :  lcall _I2C_stop
co:3015: 22             :  ret
                        : ; end of function I2C_init
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _I2C_delay ; void I2C_delay(void)
                        :  .segment _I2C_delay_formal_near, size 0, fill, notext, sclass dram
                        :  .segment _I2C_delay_local_near, size 0, fill, notext, sclass dram
                        :  .sgraph _I2C_delay_formal_near, _I2C_delay_local_near, __I2C_delay
                        : 
                        :  .segment __I2C_delay
                        : _I2C_delay: ; (leaf function) void I2C_delay(void)
                        :>}
                        :>
                        :>void I2C_delay(void)
                        :>{
co:0003: 7f be          :  mov R7,#190
                        : ?3:
                        :>  unsigned char x;
                        :>  for (x=0;x<190;x++){};
co:0005: df fe          :  djnz R7,?3
co:0007: 22             :  ret
                        : ; end of function I2C_delay
                        : ; used: R-------7 BR--------
                        : 
                        :  .export _I2C_start ; void I2C_start(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __I2C_start
                        : _I2C_start: ; void I2C_start(void)
                        :>}
                        :>
                        :>void I2C_start(void)
                        :>{
co:1af2: c2 80          :  clr _P0_B0
                        :>//  SDA_HIGH;           
                        :>//  SCL_HIGH
                        :>  SDA_LOW
co:1af4: 12 00 03       :  lcall _I2C_delay
                        : 
co:1af7: c2 81          :  clr _P0_B1
                        :>  SCL_LOW
co:1af9: 12 00 03       :  lcall _I2C_delay
co:1afc: 22             :  ret
                        : ; end of function I2C_start
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _I2C_stop ; void I2C_stop(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __I2C_stop
                        : _I2C_stop: ; void I2C_stop(void)
                        :>}
                        :>
                        :>void I2C_stop (void)                    // Assumes SCL and SDA are low at entry
                        :>{ 
co:000e: c2 80          :  clr _P0_B0
                        :>//  SCL_LOW;
                        :>  SDA_LOW
co:0010: 12 00 03       :  lcall _I2C_delay
                        : 
co:0013: d2 81          :  setb _P0_B1
                        : ?10:
                        :>  SCL_HIGH
co:0015: 30 81 fd       :  jnb _P0_B1,?10
                        : 
co:0018: 12 00 03       :  lcall _I2C_delay
                        : 
co:001b: d2 80          :  setb _P0_B0
                        :>  SDA_HIGH
co:001d: 12 00 03       :  lcall _I2C_delay
co:0020: 22             :  ret
                        : ; end of function I2C_stop
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _I2C_send ; unsigned char I2C_send(unsigned char)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __I2C_send
                        : _I2C_send: ; unsigned char I2C_send(unsigned char)
                        :  ; parameter 'dat' in 'R7' moved and assigned to local '?I2C_send_dat'
co:1380: 8f 43          :  mov ?I2C_send_dat,R7
                        :>}
                        :>
                        :>unsigned char I2C_send ( unsigned char dat)
                        :>{
co:1382: 75 44 08       :  mov ?I2C_send_i23,#8
                        : ?14:
                        :>  unsigned char x;
                        :>//  bit unsigned char ack;
                        :>  for (x=0;x<8;x++)
                        :>  {
co:1385: af 43          :  mov R7,?I2C_send_dat
co:1387: 53 07 80       :  anl AR7,#128
co:138a: ef             :  mov A,R7
co:138b: 60 07          :  jz ?18
                        :>    if (dat & 0x80) SDA_HIGH else SDA_LOW
co:138d: d2 80          :  setb _P0_B0
                        : 
co:138f: 12 00 03       :  lcall _I2C_delay
                        : 
co:1392: 80 05          :  sjmp ?19
                        : ?18:
                        : 
co:1394: c2 80          :  clr _P0_B0
                        : 
co:1396: 12 00 03       :  lcall _I2C_delay
                        : 
                        : ?19:
                        :>    SCL_HIGH
co:1399: d2 81          :  setb _P0_B1
                        : ?20:
                        : 
co:139b: 30 81 fd       :  jnb _P0_B1,?20
                        : 
co:139e: 12 00 03       :  lcall _I2C_delay
                        : 
co:13a1: c2 81          :  clr _P0_B1
                        :>    SCL_LOW
co:13a3: 12 00 03       :  lcall _I2C_delay
                        : 
co:13a6: af 43          :  mov R7,?I2C_send_dat
co:13a8: ef             :  mov A,R7
co:13a9: 2f             :  add A,R7
co:13aa: ff             :  mov R7,A
co:13ab: 8f 43          :  mov ?I2C_send_dat,R7
                        :>    dat = dat <<1;
                        :>  }
co:13ad: d5 44 d5       :  djnz ?I2C_send_i23,?14
                        :>  SDA_HIGH
co:13b0: d2 80          :  setb _P0_B0
                        : 
co:13b2: 12 00 03       :  lcall _I2C_delay
                        : 
co:13b5: d2 81          :  setb _P0_B1
                        : ?24:
                        :>  SCL_HIGH
co:13b7: 30 81 fd       :  jnb _P0_B1,?24
                        : 
co:13ba: 12 00 03       :  lcall _I2C_delay
                        : 
co:13bd: 30 80 06       :  jnb _P0_B0,?28
co:13c0: 7c 00          :  mov R4,#0
co:13c2: 7d 01          :  mov R5,#1
co:13c4: 80 03          :  sjmp ?29
                        : ?28:
co:13c6: e4             :  clr A
co:13c7: fc             :  mov R4,A
co:13c8: fd             :  mov R5,A
                        : ?29:
co:13c9: af 05          :  mov R7,AR5
                        :  ; variable 'x' allocated as 'auto'
co:13cb: 8f 43          :  mov ?I2C_send_x,R7
                        :>  x=(P0_B0)?1:0;
                        :>//  ack = P0_B0;                        // read the input SDA
                        :>  SCL_LOW
co:13cd: c2 81          :  clr _P0_B1
                        : 
co:13cf: 12 00 03       :  lcall _I2C_delay
                        : 
co:13d2: c2 80          :  clr _P0_B0
                        :>  SDA_LOW
co:13d4: 12 00 03       :  lcall _I2C_delay
                        : 
co:13d7: af 43          :  mov R7,?I2C_send_x
co:13d9: 22             :  ret
                        : ; end of function I2C_send
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:2 bytes
                        : 
                        :  .export _I2C_get ; unsigned char I2C_get(unsigned char)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __I2C_get
                        : _I2C_get: ; unsigned char I2C_get(unsigned char)
                        :  ; parameter 'ack' in 'R7' moved and assigned to local '?I2C_get_ack'
co:1a9c: 8f 30          :  mov ?I2C_get_ack,R7
                        :  ; variable 'dat' allocated as 'auto'
                        :>//  if (ack==0) return 1; else return 0;  
                        :>  return x;
                        :>}
                        :>
                        :>unsigned char I2C_get (unsigned char ack)
                        :>{
co:1a9e: e4             :  clr A
co:1a9f: f5 31          :  mov ?I2C_get_dat,A
                        :>  unsigned char dat=0,x;
                        :>  SDA_HIGH                                                      // SDA goes high (undriven)
co:1aa1: d2 80          :  setb _P0_B0
                        : 
co:1aa3: 12 00 03       :  lcall _I2C_delay
                        : 
co:1aa6: 75 32 08       :  mov ?I2C_get_i40,#8
                        : ?31:
                        :>  for (x=0;x<8;x++)
                        :>  {
co:1aa9: d2 81          :  setb _P0_B1
                        : ?35:
                        :>          SCL_HIGH
co:1aab: 30 81 fd       :  jnb _P0_B1,?35
                        : 
co:1aae: 12 00 03       :  lcall _I2C_delay
                        : 
co:1ab1: 30 80 0a       :  jnb _P0_B0,?38
                        :>//    if ((P0 & 0x40)==0x40) dat=(dat<<1)+1; else dat=dat<<1;
                        :>    if (P0_B0) dat=(dat<<1)+1; else dat=dat<<1;
co:1ab4: af 31          :  mov R7,?I2C_get_dat
co:1ab6: ef             :  mov A,R7
co:1ab7: 2f             :  add A,R7
co:1ab8: ff             :  mov R7,A
co:1ab9: 0f             :  inc R7
co:1aba: 8f 31          :  mov ?I2C_get_dat,R7
co:1abc: 80 07          :  sjmp ?39
                        : ?38:
                        : 
co:1abe: af 31          :  mov R7,?I2C_get_dat
co:1ac0: ef             :  mov A,R7
co:1ac1: 2f             :  add A,R7
co:1ac2: ff             :  mov R7,A
co:1ac3: 8f 31          :  mov ?I2C_get_dat,R7
                        : ?39:
                        :>    SCL_LOW
co:1ac5: c2 81          :  clr _P0_B1
                        : 
co:1ac7: 12 00 03       :  lcall _I2C_delay
                        : 
co:1aca: d5 32 dc       :  djnz ?I2C_get_i40,?31
                        :>  }
                        :>  if (ack) 
co:1acd: e5 30          :  mov A,?I2C_get_ack
co:1acf: 60 07          :  jz ?41
                        :>    SDA_LOW                                                     // if wanted, we will ACK the transmis
co:1ad1: c2 80          :  clr _P0_B0
                        : 
co:1ad3: 12 00 03       :  lcall _I2C_delay
                        : 
co:1ad6: 80 05          :  sjmp ?42
                        : ?41:
                        :>  else
                        :>    SDA_HIGH                                            // else we just don't!!!
co:1ad8: d2 80          :  setb _P0_B0
                        : 
co:1ada: 12 00 03       :  lcall _I2C_delay
                        : 
                        : ?42:
                        :>  SCL_HIGH                                                      // create a last clock-pulse
co:1add: d2 81          :  setb _P0_B1
                        : ?43:
                        : 
co:1adf: 30 81 fd       :  jnb _P0_B1,?43
                        : 
co:1ae2: 12 00 03       :  lcall _I2C_delay
                        : 
co:1ae5: c2 81          :  clr _P0_B1
                        :>  SCL_LOW
co:1ae7: 12 00 03       :  lcall _I2C_delay
                        : 
co:1aea: c2 80          :  clr _P0_B0
                        :>  SDA_LOW                                                       // exit the function with both signals
co:1aec: 12 00 03       :  lcall _I2C_delay
                        : 
co:1aef: af 31          :  mov R7,?I2C_get_dat
co:1af1: 22             :  ret
                        : ; end of function I2C_get
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:3 bytes
                        : 
                        :  .import _P0_B1 ; bit unsigned char P0_B1
                        :  .import _P0_B0 ; bit unsigned char P0_B0
                        :  .import _P0 ; near unsigned char P0
                        :  .end
                        :>  return (dat);    
                        :>}
=            _I2C_start =  1af2 (hex),   6898 (dez), text
=            _I2C_delay =     3 (hex),      3 (dez), text
=             _I2C_send =  1380 (hex),   4992 (dez), text
=             _I2C_stop =     e (hex),     14 (dez), text
=             _I2C_init =  300c (hex),  12300 (dez), text
=              _I2C_get =  1a9c (hex),   6812 (dez), text

objectfile:lcd.obj:
                        : ; *** 'C:\uC51\bin\uc51.exe': uC/51 - ANSI C compiler
                        : ; *** Standard 'i8051', V1.25, Jan 24 2004 (C) WWW.WICKENHAEUSER.COM
                        : ; sourcefile: 'lcd.c', time: Thu Dec 14 11:33:35 2006
                        : 
                        :  .hide
                        :  .show
                        : XDS=0
                        : COS=1
                        : NES=2
                        : INS=2
                        : .macro __line
                        : lcall $0006 ; uC/51 debugger
                        : .endmacro
                        :  .export _LCD_write_dat ; void LCD_write_dat(unsigned char)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __LCD_write_dat
                        : _LCD_write_dat: ; void LCD_write_dat(unsigned char)
                        :  ; parameter 'dat' in 'R7' moved and assigned to local '?LCD_write_dat_dat'
co:1a2a: 8f 42          :  mov ?LCD_write_dat_dat,R7
                        :>#include "i2c.h"
                        :>
                        :>#define LCD_RS   0x20
                        :>#define LCD_R_Wn 0x40
                        :>#define LCD_E 0x80
                        :>
                        :>#define LCD_I2C_DAT_ADR 0x42
                        :>#define LCD_I2C_CTL_ADR 0x40
                        :>
                        :>unsigned char LCD_ctl_reg;
                        :>
                        :>void LCD_init (void);
                        :>
                        :>/*
                        :>void LCD_wait(void)
                        :>{
                        :>        unsigned int x;
                        :>        x=0xfffe;
                        :>        while (x>0) {x--;}
                        :>}*/
                        :>
                        :>#define LCD_wait()
                        :>
                        :>void LCD_write_dat (unsigned char dat)
                        :>{
co:1a2c: 12 1a f2       :  lcall _I2C_start
                        :>        I2C_start();
                        :>        I2C_send (LCD_I2C_DAT_ADR);             // select IC8 to write to LCD-data
co:1a2f: 7f 42          :  mov R7,#66
co:1a31: 12 13 80       :  lcall _I2C_send
                        :>        I2C_send (dat);                         // put data on LCD-data lines
co:1a34: af 42          :  mov R7,?LCD_write_dat_dat
co:1a36: 12 13 80       :  lcall _I2C_send
                        :>        I2C_stop  ();
co:1a39: 12 00 0e       :  lcall _I2C_stop
                        :>        I2C_start();
co:1a3c: 12 1a f2       :  lcall _I2C_start
                        :>        I2C_send (LCD_I2C_CTL_ADR);             // select IC6 to write to control lines
co:1a3f: 7f 40          :  mov R7,#64
co:1a41: 12 13 80       :  lcall _I2C_send
                        :>        LCD_ctl_reg |= LCD_RS;          // Registerselect '1' : select data
co:1a44: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a47: e0             :  movx A,@DPTR
co:1a48: ff             :  mov R7,A
co:1a49: 44 20          :  orl A,#32
co:1a4b: ff             :  mov R7,A
co:1a4c: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a4f: ef             :  mov A,R7
co:1a50: f0             :  movx @DPTR,A
                        :>    I2C_send (LCD_ctl_reg);
co:1a51: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a54: e0             :  movx A,@DPTR
co:1a55: ff             :  mov R7,A
co:1a56: 12 13 80       :  lcall _I2C_send
                        :>        LCD_ctl_reg &= ~LCD_R_Wn;       // R/Wn '0' : write
co:1a59: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a5c: e0             :  movx A,@DPTR
co:1a5d: ff             :  mov R7,A
co:1a5e: 54 bf          :  anl A,#191
co:1a60: ff             :  mov R7,A
co:1a61: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a64: ef             :  mov A,R7
co:1a65: f0             :  movx @DPTR,A
                        :>    I2C_send (LCD_ctl_reg);
co:1a66: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a69: e0             :  movx A,@DPTR
co:1a6a: ff             :  mov R7,A
co:1a6b: 12 13 80       :  lcall _I2C_send
                        :>        LCD_ctl_reg |= LCD_E;           // Enable '1' : validate cycle
co:1a6e: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a71: e0             :  movx A,@DPTR
co:1a72: ff             :  mov R7,A
co:1a73: 44 80          :  orl A,#128
co:1a75: ff             :  mov R7,A
co:1a76: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a79: ef             :  mov A,R7
co:1a7a: f0             :  movx @DPTR,A
                        :>    I2C_send (LCD_ctl_reg);
co:1a7b: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a7e: e0             :  movx A,@DPTR
co:1a7f: ff             :  mov R7,A
co:1a80: 12 13 80       :  lcall _I2C_send
                        :>        LCD_ctl_reg &= ~LCD_E;          // Enable '0' : end of cycle
co:1a83: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a86: e0             :  movx A,@DPTR
co:1a87: ff             :  mov R7,A
co:1a88: 54 7f          :  anl A,#127
co:1a8a: ff             :  mov R7,A
co:1a8b: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a8e: ef             :  mov A,R7
co:1a8f: f0             :  movx @DPTR,A
                        :>    I2C_send (LCD_ctl_reg);
co:1a90: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:1a93: e0             :  movx A,@DPTR
co:1a94: ff             :  mov R7,A
co:1a95: 12 13 80       :  lcall _I2C_send
                        :>        I2C_stop();
co:1a98: 12 00 0e       :  lcall _I2C_stop
co:1a9b: 22             :  ret
                        : ; end of function LCD_write_dat
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:1 bytes
                        : 
                        :  .export _LCD_wait_ready ; void LCD_wait_ready(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __LCD_wait_ready
                        : _LCD_wait_ready: ; void LCD_wait_ready(void)
                        :  ; variable 'dat' allocated as 'auto'
                        :>                
                        :>}
                        :>
                        :>void LCD_wait_ready(void)
                        :>{
co:0a93: 75 2d 80       :  mov ?LCD_wait_ready_dat,#128
co:0a96: 02 0b 25       :  ljmp ?4
                        : ?3:
                        :>        unsigned char dat;
                        :>        dat = 0x80;
                        :>        while ((dat &0x80)!=0)
                        :>        {
co:0a99: 12 1a f2       :  lcall _I2C_start
                        :>                
                        :>                I2C_start();
                        :>                I2C_send (LCD_I2C_DAT_ADR);             // select IC8 to write to LCD-data
co:0a9c: 7f 42          :  mov R7,#66
co:0a9e: 12 13 80       :  lcall _I2C_send
                        :>                I2C_send (0xff);                // set all outputs to high (and input)
co:0aa1: 7f ff          :  mov R7,#255
co:0aa3: 12 13 80       :  lcall _I2C_send
                        :>                I2C_stop  ();
co:0aa6: 12 00 0e       :  lcall _I2C_stop
                        :>
                        :>                I2C_start();
co:0aa9: 12 1a f2       :  lcall _I2C_start
                        :>            I2C_send (LCD_I2C_CTL_ADR);         // select IC6 to write to control lines
co:0aac: 7f 40          :  mov R7,#64
co:0aae: 12 13 80       :  lcall _I2C_send
                        :>                LCD_ctl_reg &= ~LCD_RS;                 // RS '0' : Control register
co:0ab1: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0ab4: e0             :  movx A,@DPTR
co:0ab5: ff             :  mov R7,A
co:0ab6: 54 df          :  anl A,#223
co:0ab8: ff             :  mov R7,A
co:0ab9: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0abc: ef             :  mov A,R7
co:0abd: f0             :  movx @DPTR,A
                        :>        I2C_send (LCD_ctl_reg);
co:0abe: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0ac1: e0             :  movx A,@DPTR
co:0ac2: ff             :  mov R7,A
co:0ac3: 12 13 80       :  lcall _I2C_send
                        :>                LCD_ctl_reg |= LCD_R_Wn;                // R/Wn '1' : read
co:0ac6: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0ac9: e0             :  movx A,@DPTR
co:0aca: ff             :  mov R7,A
co:0acb: 44 40          :  orl A,#64
co:0acd: ff             :  mov R7,A
co:0ace: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0ad1: ef             :  mov A,R7
co:0ad2: f0             :  movx @DPTR,A
                        :>                I2C_send (LCD_ctl_reg);                 // select control register to read
co:0ad3: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0ad6: e0             :  movx A,@DPTR
co:0ad7: ff             :  mov R7,A
co:0ad8: 12 13 80       :  lcall _I2C_send
                        :>                LCD_ctl_reg |= LCD_E;                   // Enable '1' : validate cycle
co:0adb: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0ade: e0             :  movx A,@DPTR
co:0adf: ff             :  mov R7,A
co:0ae0: 44 80          :  orl A,#128
co:0ae2: ff             :  mov R7,A
co:0ae3: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0ae6: ef             :  mov A,R7
co:0ae7: f0             :  movx @DPTR,A
                        :>        I2C_send (LCD_ctl_reg);
co:0ae8: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0aeb: e0             :  movx A,@DPTR
co:0aec: ff             :  mov R7,A
co:0aed: 12 13 80       :  lcall _I2C_send
                        :>                I2C_stop();
co:0af0: 12 00 0e       :  lcall _I2C_stop
                        :>        
                        :>                I2C_start();
co:0af3: 12 1a f2       :  lcall _I2C_start
                        :>                I2C_send (LCD_I2C_DAT_ADR+1);   // select IC8 to read from LCD-data
co:0af6: 7f 43          :  mov R7,#67
co:0af8: 12 13 80       :  lcall _I2C_send
                        :>                dat=I2C_get(1);                                 // read status
co:0afb: 7f 01          :  mov R7,#1
co:0afd: 12 1a 9c       :  lcall _I2C_get
co:0b00: 8f 2d          :  mov ?LCD_wait_ready_dat,R7
                        :>                I2C_stop();
co:0b02: 12 00 0e       :  lcall _I2C_stop
                        :>
                        :>                I2C_start();
co:0b05: 12 1a f2       :  lcall _I2C_start
                        :>            I2C_send (LCD_I2C_CTL_ADR);         // select IC6 to write to control lines
co:0b08: 7f 40          :  mov R7,#64
co:0b0a: 12 13 80       :  lcall _I2C_send
                        :>                LCD_ctl_reg &= ~LCD_E;                  // Enable '0' : end of cycle
co:0b0d: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b10: e0             :  movx A,@DPTR
co:0b11: ff             :  mov R7,A
co:0b12: 54 7f          :  anl A,#127
co:0b14: ff             :  mov R7,A
co:0b15: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b18: ef             :  mov A,R7
co:0b19: f0             :  movx @DPTR,A
                        :>        I2C_send (LCD_ctl_reg);
co:0b1a: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b1d: e0             :  movx A,@DPTR
co:0b1e: ff             :  mov R7,A
co:0b1f: 12 13 80       :  lcall _I2C_send
                        :>                I2C_stop();
co:0b22: 12 00 0e       :  lcall _I2C_stop
                        :>        }               
                        : ?4:
                        : 
co:0b25: af 2d          :  mov R7,?LCD_wait_ready_dat
co:0b27: 53 07 80       :  anl AR7,#128
co:0b2a: ef             :  mov A,R7
co:0b2b: 60 03          :  jz ?_1
co:0b2d: 02 0a 99       :  ljmp ?3
                        : ?_1:
co:0b30: 22             :  ret
                        : ; end of function LCD_wait_ready
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:1 bytes
                        : 
                        :  .export _LCD_write_cmd ; void LCD_write_cmd(unsigned char)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __LCD_write_cmd
                        : _LCD_write_cmd: ; void LCD_write_cmd(unsigned char)
                        :  ; parameter 'dat' in 'R7' moved and assigned to local '?LCD_write_cmd_dat'
co:0b31: 8f 42          :  mov ?LCD_write_cmd_dat,R7
                        :>}
                        :>
                        :>void LCD_write_cmd (unsigned char dat)
                        :>{
co:0b33: 12 1a f2       :  lcall _I2C_start
                        :>        I2C_start();
                        :>        I2C_send (LCD_I2C_DAT_ADR);             // select IC8 to write to LCD-data
co:0b36: 7f 42          :  mov R7,#66
co:0b38: 12 13 80       :  lcall _I2C_send
                        :>        I2C_send (dat);                 // put data on LCD-data lines
co:0b3b: af 42          :  mov R7,?LCD_write_cmd_dat
co:0b3d: 12 13 80       :  lcall _I2C_send
                        :>        I2C_stop  ();
co:0b40: 12 00 0e       :  lcall _I2C_stop
                        :>        I2C_start();
co:0b43: 12 1a f2       :  lcall _I2C_start
                        :>        I2C_send (LCD_I2C_CTL_ADR);             // select IC6 to write to control lines
co:0b46: 7f 40          :  mov R7,#64
co:0b48: 12 13 80       :  lcall _I2C_send
                        :>        LCD_ctl_reg &= ~LCD_RS;                 // RS '0' : Control register
co:0b4b: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b4e: e0             :  movx A,@DPTR
co:0b4f: ff             :  mov R7,A
co:0b50: 54 df          :  anl A,#223
co:0b52: ff             :  mov R7,A
co:0b53: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b56: ef             :  mov A,R7
co:0b57: f0             :  movx @DPTR,A
                        :>    I2C_send (LCD_ctl_reg);
co:0b58: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b5b: e0             :  movx A,@DPTR
co:0b5c: ff             :  mov R7,A
co:0b5d: 12 13 80       :  lcall _I2C_send
                        :>        LCD_ctl_reg &= ~LCD_R_Wn;               // R/Wn '0' : write
co:0b60: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b63: e0             :  movx A,@DPTR
co:0b64: ff             :  mov R7,A
co:0b65: 54 bf          :  anl A,#191
co:0b67: ff             :  mov R7,A
co:0b68: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b6b: ef             :  mov A,R7
co:0b6c: f0             :  movx @DPTR,A
                        :>    I2C_send (LCD_ctl_reg);
co:0b6d: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b70: e0             :  movx A,@DPTR
co:0b71: ff             :  mov R7,A
co:0b72: 12 13 80       :  lcall _I2C_send
                        :>    I2C_send (LCD_ctl_reg);
co:0b75: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b78: e0             :  movx A,@DPTR
co:0b79: ff             :  mov R7,A
co:0b7a: 12 13 80       :  lcall _I2C_send
                        :>        LCD_ctl_reg |= LCD_E;           // Enable '1' : validate cycle
co:0b7d: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b80: e0             :  movx A,@DPTR
co:0b81: ff             :  mov R7,A
co:0b82: 44 80          :  orl A,#128
co:0b84: ff             :  mov R7,A
co:0b85: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b88: ef             :  mov A,R7
co:0b89: f0             :  movx @DPTR,A
                        :>    I2C_send (LCD_ctl_reg);
co:0b8a: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b8d: e0             :  movx A,@DPTR
co:0b8e: ff             :  mov R7,A
co:0b8f: 12 13 80       :  lcall _I2C_send
                        :>        LCD_ctl_reg &= ~LCD_E;          // Enable '0' : end of cycle
co:0b92: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b95: e0             :  movx A,@DPTR
co:0b96: ff             :  mov R7,A
co:0b97: 54 7f          :  anl A,#127
co:0b99: ff             :  mov R7,A
co:0b9a: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0b9d: ef             :  mov A,R7
co:0b9e: f0             :  movx @DPTR,A
                        :>    I2C_send (LCD_ctl_reg);
co:0b9f: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:0ba2: e0             :  movx A,@DPTR
co:0ba3: ff             :  mov R7,A
co:0ba4: 12 13 80       :  lcall _I2C_send
                        :>        I2C_stop();
co:0ba7: 12 00 0e       :  lcall _I2C_stop
co:0baa: 22             :  ret
                        : ; end of function LCD_write_cmd
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:1 bytes
                        : 
                        :  .export _LCD_init ; void LCD_init(void)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __LCD_init
                        : _LCD_init: ; void LCD_init(void)
                        :>        LCD_wait();             // Wait until command is executed
                        :>}
                        :>
                        :>void LCD_init(void)
                        :>{
co:01d5: 90 08 83       :  mov DPTR,#_LCD_ctl_reg
co:01d8: e4             :  clr A
co:01d9: f0             :  movx @DPTR,A
                        :>  LCD_ctl_reg = 0x00;     // initialize control-lines
                        :>  LCD_wait_ready ();
co:01da: 12 0a 93       :  lcall _LCD_wait_ready
                        :>  _wait_ms (35);          // wait for more than 30mSec after Power supply to LCD
co:01dd: 7e 00          :  mov R6,#0
co:01df: 7f 23          :  mov R7,#35
co:01e1: 12 1b 07       :  lcall __wait_ms
                        :>                          // rises above 4,5 volt
                        :>  LCD_write_cmd (0x38);   // Function Set : 8 bit, 2 lines, 5x7 dots
co:01e4: 7f 38          :  mov R7,#56
co:01e6: 12 0b 31       :  lcall _LCD_write_cmd
                        :>  _wait_ms (2);
co:01e9: 7e 00          :  mov R6,#0
co:01eb: 7f 02          :  mov R7,#2
co:01ed: 12 1b 07       :  lcall __wait_ms
                        :>  LCD_write_cmd (0x38);   // Function Set : 8 bit, 2 lines, 5x7 dots
co:01f0: 7f 38          :  mov R7,#56
co:01f2: 12 0b 31       :  lcall _LCD_write_cmd
                        :>  _wait_ms (2);
co:01f5: 7e 00          :  mov R6,#0
co:01f7: 7f 02          :  mov R7,#2
co:01f9: 12 1b 07       :  lcall __wait_ms
                        :>  LCD_write_cmd (0x0c);   // Display ON/OFF : display ON, cursor blink OFF, cursor OFF
co:01fc: 7f 0c          :  mov R7,#12
co:01fe: 12 0b 31       :  lcall _LCD_write_cmd
                        :>  _wait_ms (1);
co:0201: 7e 00          :  mov R6,#0
co:0203: 7f 01          :  mov R7,#1
co:0205: 12 1b 07       :  lcall __wait_ms
                        :>  LCD_write_cmd (0x01);   // Clear Display
co:0208: 7f 01          :  mov R7,#1
co:020a: 12 0b 31       :  lcall _LCD_write_cmd
                        :>  _wait_ms (2);
co:020d: 7e 00          :  mov R6,#0
co:020f: 7f 02          :  mov R7,#2
co:0211: 12 1b 07       :  lcall __wait_ms
                        :>  LCD_write_cmd (0x02);   // Return Home
co:0214: 7f 02          :  mov R7,#2
co:0216: 12 0b 31       :  lcall _LCD_write_cmd
                        :>  _wait_ms (2);
co:0219: 7e 00          :  mov R6,#0
co:021b: 7f 02          :  mov R7,#2
co:021d: 12 1b 07       :  lcall __wait_ms
                        :>  LCD_write_cmd (0x06);   // Entry Mode : Increment, Shift OFF
co:0220: 7f 06          :  mov R7,#6
co:0222: 12 0b 31       :  lcall _LCD_write_cmd
                        :>  _wait_ms(1);
co:0225: 7e 00          :  mov R6,#0
co:0227: 7f 01          :  mov R7,#1
co:0229: 12 1b 07       :  lcall __wait_ms
                        :>  LCD_write_cmd (0x40);
co:022c: 7f 40          :  mov R7,#64
co:022e: 12 0b 31       :  lcall _LCD_write_cmd
                        :>  _wait_ms(1);
co:0231: 7e 00          :  mov R6,#0
co:0233: 7f 01          :  mov R7,#1
co:0235: 12 1b 07       :  lcall __wait_ms
                        :>  LCD_write_cmd (0x80);
co:0238: 7f 80          :  mov R7,#128
co:023a: 12 0b 31       :  lcall _LCD_write_cmd
                        :>  _wait_ms(1);
co:023d: 7e 00          :  mov R6,#0
co:023f: 7f 01          :  mov R7,#1
co:0241: 12 1b 07       :  lcall __wait_ms
co:0244: 22             :  ret
                        : ; end of function LCD_init
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B
                        : 
                        :  .export _LCD_write_line ; void LCD_write_line(char *, unsigned char)
                        :  .hide
                        :  .show
                        : 
                        :  .segment __LCD_write_line
                        : _LCD_write_line: ; void LCD_write_line(char *, unsigned char)
                        :  ; parameter 'str' in 'RL4567' moved and assigned to local '?LCD_write_line_str'
                        :  ; parameter 'line' in 'R3'
co:016a: 74 3d          :  mov A,#?LCD_write_line_str
co:016c: 12 32 9c       :  lcall __st_a_r47
                        :  ; variable 'nr' allocated as 'auto'
                        :>
                        :>}
                        :>
                        :>void LCD_write_line(char *str,unsigned char line)
                        :>{
co:016f: e4             :  clr A
co:0170: f5 41          :  mov ?LCD_write_line_nr,A
                        :>        unsigned char nr=0;
                        :>        if (line==0) LCD_write_cmd (0x80);      // DDRAM pointer 0   (first line)
co:0172: eb             :  mov A,R3
co:0173: 70 07          :  jnz ?9
                        : 
co:0175: 7f 80          :  mov R7,#128
co:0177: 12 0b 31       :  lcall _LCD_write_cmd
co:017a: 80 2f          :  sjmp ?12
                        : ?9:
                        :>        else LCD_write_cmd (0xc0);                      // DDRAM pointer x40 (line nr 1)
co:017c: 7f c0          :  mov R7,#192
co:017e: 12 0b 31       :  lcall _LCD_write_cmd
co:0181: 80 28          :  sjmp ?12
                        : ?11:
                        :>        while ((*str!=0)&&(nr<16)) {LCD_write_dat (*str++);nr++;} // write to the LCD-data register as
co:0183: 85 3d 08       :  mov AR8,?LCD_write_line_str
co:0186: 85 3e 09       :  mov AR9,?LCD_write_line_str+1
co:0189: 85 3f 0a       :  mov AR10,?LCD_write_line_str+2
co:018c: 85 40 0b       :  mov AR11,?LCD_write_line_str+3
co:018f: e4             :  clr A
co:0190: f8             :  mov R0,A
co:0191: f9             :  mov R1,A
co:0192: fa             :  mov R2,A
co:0193: 7b 01          :  mov R3,#1
co:0195: 12 33 ff       :  lcall __movel_8_4
co:0198: 12 35 9e       :  lcall __add_i4
co:019b: 74 3d          :  mov A,#?LCD_write_line_str
co:019d: 12 32 9c       :  lcall __st_a_r47
co:01a0: 12 33 ff       :  lcall __movel_8_4
co:01a3: 12 32 16       :  lcall __gen_read32_i1
co:01a6: 12 1a 2a       :  lcall _LCD_write_dat
                        : 
co:01a9: 05 41          :  inc ?LCD_write_line_nr
                        : 
                        : ?12:
                        : 
co:01ab: 74 3d          :  mov A,#?LCD_write_line_str
co:01ad: 12 33 44       :  lcall __ld_a_r47
co:01b0: 12 32 16       :  lcall __gen_read32_i1
co:01b3: ef             :  mov A,R7
co:01b4: 60 09          :  jz ?14
co:01b6: 7d 10          :  mov R5,#16
co:01b8: af 41          :  mov R7,?LCD_write_line_nr
co:01ba: c3             :  clr C
co:01bb: ef             :  mov A,R7
co:01bc: 9d             :  subb A,R5
co:01bd: 40 c4          :  jc ?11
                        : ?14:
co:01bf: 80 05          :  sjmp ?16
                        : ?15:
                        :>                                                                                // long as the string 
                        :>        while (nr++<16) {LCD_write_dat (' ');} // fill the rest of the line with ' '
co:01c1: 7f 20          :  mov R7,#32
co:01c3: 12 1a 2a       :  lcall _LCD_write_dat
                        : 
                        : ?16:
                        : 
co:01c6: ad 41          :  mov R5,?LCD_write_line_nr
co:01c8: af 05          :  mov R7,AR5
co:01ca: 0f             :  inc R7
co:01cb: 8f 41          :  mov ?LCD_write_line_nr,R7
co:01cd: 7f 10          :  mov R7,#16
co:01cf: c3             :  clr C
co:01d0: ed             :  mov A,R5
co:01d1: 9f             :  subb A,R7
co:01d2: 40 ed          :  jc ?15
co:01d4: 22             :  ret
                        : ; end of function LCD_write_line
                        : ; used: R01234567 BR01234567 DPTR ACC PSW B locals:5 bytes
                        : 
                        :  .import __wait_ms ; int _wait_ms()
                        :  .segment bss, sclass xram, notext
                        :  .export _LCD_ctl_reg ; xdata unsigned char LCD_ctl_reg
                        : _LCD_ctl_reg: ; xdata unsigned char LCD_ctl_reg
xr:0883: xx             :  .ds.b 1
                        :  .import _I2C_get ; unsigned char I2C_get(unsigned char)
                        :  .import _I2C_send ; unsigned char I2C_send(unsigned char)
                        :  .import _I2C_stop ; void I2C_stop(void)
                        :  .import _I2C_start ; void I2C_start(void)
                        :  .end
                        :>}
=          _LCD_ctl_reg =   883 (hex),   2179 (dez), xram
=       _LCD_wait_ready =   a93 (hex),   2707 (dez), text
=       _LCD_write_line =   16a (hex),    362 (dez), text
=        _LCD_write_dat =  1a2a (hex),   6698 (dez), text
=        _LCD_write_cmd =   b31 (hex),   2865 (dez), text
=             _LCD_init =   1d5 (hex),    469 (dez), text

objectfile:home.obj:
                        : ; ********************************************************
                        : ; * home.s51 (Source: home.html)
                        : ; * generated by WEBCODE 2004 (C) www.wickenhaeuser.de
                        : ; ********************************************************
                        : ; * extern code unsigned char home[];
                        : 
                        :   .segment __home
                        :   .export _home
                        :   .import ____home_size__
                        : _home: 
co:0245: 08 4b          :   .dc.w ____home_size__-3
co:0247: 01             :   .dc.b 1
co:0248: 48 54 54 50 2f :   .dc.b "HTTP/1.0 200 OK",13,10
co:024d: 31 2e 30 20 32 :
co:0252: 30 30 20 4f 4b :
co:0257: 0d 0a          :
co:0259: 43 6f 6e 74 65 :   .dc.b "Content-type: text/html",13,10
co:025e: 6e 74 2d 74 79 :
co:0263: 70 65 3a 20 74 :
co:0268: 65 78 74 2f 68 :
co:026d: 74 6d 6c 0d 0a :
co:0272: 43 6f 6e 6e 65 :   .dc.b "Connection: close",13,10,13,10
co:0277: 63 74 69 6f 6e :
co:027c: 3a 20 63 6c 6f :
co:0281: 73 65 0d 0a 0d :
co:0286: 0a             :
                        : 
co:0287: 3c 68 74 6d 6c :   .dc.b "<html><head><title>Home</title></head>",13,10
co:028c: 3e 3c 68 65 61 :
co:0291: 64 3e 3c 74 69 :
co:0296: 74 6c 65 3e 48 :
co:029b: 6f 6d 65 3c 2f :
co:02a0: 74 69 74 6c 65 :
co:02a5: 3e 3c 2f 68 65 :
co:02aa: 61 64 3e 0d 0a :
co:02af: 3c 62 6f 64 79 :   .dc.b "<body bgcolor=#505050 text=#FFFF00 vlink=#80FFFF link=#FF80FF al"
co:02b4: 20 62 67 63 6f :
co:02b9: 6c 6f 72 3d 23 :
co:02be: 35 30 35 30 35 :
co:02c3: 30 20 74 65 78 :
co:02c8: 74 3d 23 46 46 :
co:02cd: 46 46 30 30 20 :
co:02d2: 76 6c 69 6e 6b :
co:02d7: 3d 23 38 30 46 :
co:02dc: 46 46 46 20 6c :
co:02e1: 69 6e 6b 3d 23 :
co:02e6: 46 46 38 30 46 :
co:02eb: 46 20 61 6c    :
co:02ef: 69 6e 6b 3d 23 :   .dc.b "ink=#FF80FF>",13,10
co:02f4: 46 46 38 30 46 :
co:02f9: 46 3e 0d 0a    :
co:02fd: 3c 70 3e 3c 62 :   .dc.b "<p><b><h2 align=",34,"center",34,"><font color=",34,"#00FF00",34
co:0302: 3e 3c 68 32 20 :
co:0307: 61 6c 69 67 6e :
co:030c: 3d 22 63 65 6e :
co:0311: 74 65 72 22 3e :
co:0316: 3c 66 6f 6e 74 :
co:031b: 20 63 6f 6c 6f :
co:0320: 72 3d 22 23 30 :
co:0325: 30 46 46 30 30 :
co:032a: 22             :
co:032b: 3e 3c 69 3e 45 :   .dc.b "><i>Elektor FPGA Webserver - Home </i>",13,10
co:0330: 6c 65 6b 74 6f :
co:0335: 72 20 46 50 47 :
co:033a: 41 20 57 65 62 :
co:033f: 73 65 72 76 65 :
co:0344: 72 20 2d 20 48 :
co:0349: 6f 6d 65 20 3c :
co:034e: 2f 69 3e 0d 0a :
co:0353: 3c 2f 66 6f 6e :   .dc.b "</font></h2>",13,10
co:0358: 74 3e 3c 2f 68 :
co:035d: 32 3e 0d 0a    :
co:0361: 3c 74 61 62 6c :   .dc.b "<table style=",34,"BORDER-COLLAPSE: collapse",34," borderColor=#"
co:0366: 65 20 73 74 79 :
co:036b: 6c 65 3d 22 42 :
co:0370: 4f 52 44 45 52 :
co:0375: 2d 43 4f 4c 4c :
co:037a: 41 50 53 45 3a :
co:037f: 20 63 6f 6c 6c :
co:0384: 61 70 73 65 22 :
co:0389: 20 62 6f 72 64 :
co:038e: 65 72 43 6f 6c :
co:0393: 6f 72 3d 23    :
co:0397: 31 31 31 31 31 :   .dc.b "111111 cellspacing=0 cellpadding=0 width=873 border=0>",13,10
co:039c: 31 20 63 65 6c :
co:03a1: 6c 73 70 61 63 :
co:03a6: 69 6e 67 3d 30 :
co:03ab: 20 63 65 6c 6c :
co:03b0: 70 61 64 64 69 :
co:03b5: 6e 67 3d 30 20 :
co:03ba: 77 69 64 74 68 :
co:03bf: 3d 38 37 33 20 :
co:03c4: 62 6f 72 64 65 :
co:03c9: 72 3d 30 3e 0d :
co:03ce: 0a             :
co:03cf: 3c 74 72 3e 3c :   .dc.b "<tr><td valign=top width=873 colspan=4><br> <br>Elektor Embedded"
co:03d4: 74 64 20 76 61 :
co:03d9: 6c 69 67 6e 3d :
co:03de: 74 6f 70 20 77 :
co:03e3: 69 64 74 68 3d :
co:03e8: 38 37 33 20 63 :
co:03ed: 6f 6c 73 70 61 :
co:03f2: 6e 3d 34 3e 3c :
co:03f7: 62 72 3e 20 3c :
co:03fc: 62 72 3e 45 6c :
co:0401: 65 6b 74 6f 72 :
co:0406: 20 45 6d 62 65 :
co:040b: 64 64 65 64    :
co:040f: 20 46 50 47 41 :   .dc.b " FPGA Webserver - ",13,10
co:0414: 20 57 65 62 73 :
co:0419: 65 72 76 65 72 :
co:041e: 20 2d 20 0d 0a :
co:0423: 20 20 61 20 76 :   .dc.b "  a versatile FPGA-solution with Altera Cyclone EP1C12<sup>TM</s"
co:0428: 65 72 73 61 74 :
co:042d: 69 6c 65 20 46 :
co:0432: 50 47 41 2d 73 :
co:0437: 6f 6c 75 74 69 :
co:043c: 6f 6e 20 77 69 :
co:0441: 74 68 20 41 6c :
co:0446: 74 65 72 61 20 :
co:044b: 43 79 63 6c 6f :
co:0450: 6e 65 20 45 50 :
co:0455: 31 43 31 32 3c :
co:045a: 73 75 70 3e 54 :
co:045f: 4d 3c 2f 73    :
co:0463: 75 70 3e 20 46 :   .dc.b "up> FPGA and OpenCores Ethernet Controller<br> ",13,10
co:0468: 50 47 41 20 61 :
co:046d: 6e 64 20 4f 70 :
co:0472: 65 6e 43 6f 72 :
co:0477: 65 73 20 45 74 :
co:047c: 68 65 72 6e 65 :
co:0481: 74 20 43 6f 6e :
co:0486: 74 72 6f 6c 6c :
co:048b: 65 72 3c 62 72 :
co:0490: 3e 20 0d 0a    :
co:0494: 20 20 3c 62 3e :   .dc.b "  <b>"
co:0499: ff             :   .dc.b 255
                        :   .import _Hcnt ;  (char xdata*)Hcnt
co:049a: 08 0c          :   .dc.w _Hcnt
co:049c: 20 3c 2f 62 3e :   .dc.b " </b>Hits since Powerup<br>",13,10
co:04a1: 48 69 74 73 20 :
co:04a6: 73 69 6e 63 65 :
co:04ab: 20 50 6f 77 65 :
co:04b0: 72 75 70 3c 62 :
co:04b5: 72 3e 0d 0a    :
co:04b9: 20 20 3c 62 72 :   .dc.b "  <br></td></tr><tr><td valign=top width=31>&nbsp;</td>",13,10
co:04be: 3e 3c 2f 74 64 :
co:04c3: 3e 3c 2f 74 72 :
co:04c8: 3e 3c 74 72 3e :
co:04cd: 3c 74 64 20 76 :
co:04d2: 61 6c 69 67 6e :
co:04d7: 3d 74 6f 70 20 :
co:04dc: 77 69 64 74 68 :
co:04e1: 3d 33 31 3e 26 :
co:04e6: 6e 62 73 70 3b :
co:04eb: 3c 2f 74 64 3e :
co:04f0: 0d 0a          :
co:04f2: 3c 74 64 20 76 :   .dc.b "<td valign=top width=403><b>Board Features:</b><br><br>",13,10
co:04f7: 61 6c 69 67 6e :
co:04fc: 3d 74 6f 70 20 :
co:0501: 77 69 64 74 68 :
co:0506: 3d 34 30 33 3e :
co:050b: 3c 62 3e 42 6f :
co:0510: 61 72 64 20 46 :
co:0515: 65 61 74 75 72 :
co:051a: 65 73 3a 3c 2f :
co:051f: 62 3e 3c 62 72 :
co:0524: 3e 3c 62 72 3e :
co:0529: 0d 0a          :
co:052b: 3c 6c 69 3e 41 :   .dc.b "<li>Altera EP1C12 FPGA (12060 Logic Elements)<br>",13,10
co:0530: 6c 74 65 72 61 :
co:0535: 20 45 50 31 43 :
co:053a: 31 32 20 46 50 :
co:053f: 47 41 20 28 31 :
co:0544: 32 30 36 30 20 :
co:0549: 4c 6f 67 69 63 :
co:054e: 20 45 6c 65 6d :
co:0553: 65 6e 74 73 29 :
co:0558: 3c 62 72 3e 0d :
co:055d: 0a             :
co:055e: 3c 6c 69 3e 45 :   .dc.b "<li>EPCS4 Configuration memory - Flash <br>",13,10
co:0563: 50 43 53 34 20 :
co:0568: 43 6f 6e 66 69 :
co:056d: 67 75 72 61 74 :
co:0572: 69 6f 6e 20 6d :
co:0577: 65 6d 6f 72 79 :
co:057c: 20 2d 20 46 6c :
co:0581: 61 73 68 20 3c :
co:0586: 62 72 3e 0d 0a :
co:058b: 3c 6c 69 3e 31 :   .dc.b "<li>128 kB User Flash<br>",13,10
co:0590: 32 38 20 6b 42 :
co:0595: 20 55 73 65 72 :
co:059a: 20 46 6c 61 73 :
co:059f: 68 3c 62 72 3e :
co:05a4: 0d 0a          :
co:05a6: 3c 6c 69 3e 31 :   .dc.b "<li>1 MB User SRAM (2 * 256k * 16)  <br>",13,10
co:05ab: 20 4d 42 20 55 :
co:05b0: 73 65 72 20 53 :
co:05b5: 52 41 4d 20 28 :
co:05ba: 32 20 2a 20 32 :
co:05bf: 35 36 6b 20 2a :
co:05c4: 20 31 36 29 20 :
co:05c9: 20 3c 62 72 3e :
co:05ce: 0d 0a          :
co:05d0: 3c 6c 69 3e 35 :   .dc.b "<li>50MHz On-board oscillator<li>JTAG- Interface (Byteblaster co"
co:05d5: 30 4d 48 7a 20 :
co:05da: 4f 6e 2d 62 6f :
co:05df: 61 72 64 20 6f :
co:05e4: 73 63 69 6c 6c :
co:05e9: 61 74 6f 72 3c :
co:05ee: 6c 69 3e 4a 54 :
co:05f3: 41 47 2d 20 49 :
co:05f8: 6e 74 65 72 66 :
co:05fd: 61 63 65 20 28 :
co:0602: 42 79 74 65 62 :
co:0607: 6c 61 73 74 65 :
co:060c: 72 20 63 6f    :
co:0610: 6d 70 61 74 69 :   .dc.b "mpatible)<br>",13,10
co:0615: 62 6c 65 29 3c :
co:061a: 62 72 3e 0d 0a :
co:061f: 3c 6c 69 3e 38 :   .dc.b "<li>80 User I/O signals<li>Integrated Powersupply</td>",13,10
co:0624: 30 20 55 73 65 :
co:0629: 72 20 49 2f 4f :
co:062e: 20 73 69 67 6e :
co:0633: 61 6c 73 3c 6c :
co:0638: 69 3e 49 6e 74 :
co:063d: 65 67 72 61 74 :
co:0642: 65 64 20 50 6f :
co:0647: 77 65 72 73 75 :
co:064c: 70 70 6c 79 3c :
co:0651: 2f 74 64 3e 0d :
co:0656: 0a             :
co:0657: 3c 74 64 20 77 :   .dc.b "<td width=12>&nbsp;</td>",13,10
co:065c: 69 64 74 68 3d :
co:0661: 31 32 3e 26 6e :
co:0666: 62 73 70 3b 3c :
co:066b: 2f 74 64 3e 0d :
co:0670: 0a             :
co:0671: 3c 74 64 20 76 :   .dc.b "<td valign=top width=427><b>Design Features:</b><br><br>",13,10
co:0676: 61 6c 69 67 6e :
co:067b: 3d 74 6f 70 20 :
co:0680: 77 69 64 74 68 :
co:0685: 3d 34 32 37 3e :
co:068a: 3c 62 3e 44 65 :
co:068f: 73 69 67 6e 20 :
co:0694: 46 65 61 74 75 :
co:0699: 72 65 73 3a 3c :
co:069e: 2f 62 3e 3c 62 :
co:06a3: 72 3e 3c 62 72 :
co:06a8: 3e 0d 0a       :
co:06ab: 3c 6c 69 3e 38 :   .dc.b "<li>8052 Microcontroller (25 MHz) with optimized instructionset<"
co:06b0: 30 35 32 20 4d :
co:06b5: 69 63 72 6f 63 :
co:06ba: 6f 6e 74 72 6f :
co:06bf: 6c 6c 65 72 20 :
co:06c4: 28 32 35 20 4d :
co:06c9: 48 7a 29 20 77 :
co:06ce: 69 74 68 20 6f :
co:06d3: 70 74 69 6d 69 :
co:06d8: 7a 65 64 20 69 :
co:06dd: 6e 73 74 72 75 :
co:06e2: 63 74 69 6f 6e :
co:06e7: 73 65 74 3c    :
co:06eb: 62 72 3e 0d 0a :   .dc.b "br>",13,10
co:06f0: 3c 6c 69 3e 31 :   .dc.b "<li>10/100 Mb Ethernet Controller",13,10
co:06f5: 30 2f 31 30 30 :
co:06fa: 20 4d 62 20 45 :
co:06ff: 74 68 65 72 6e :
co:0704: 65 74 20 43 6f :
co:0709: 6e 74 72 6f 6c :
co:070e: 6c 65 72 0d 0a :
co:0713: 3c 6c 69 3e 45 :   .dc.b "<li>Ethernet-Bootloader<br>",13,10
co:0718: 74 68 65 72 6e :
co:071d: 65 74 2d 42 6f :
co:0722: 6f 74 6c 6f 61 :
co:0727: 64 65 72 3c 62 :
co:072c: 72 3e 0d 0a    :
co:0730: 3c 6c 69 3e 35 :   .dc.b "<li>56 kB ROM",13,10
co:0735: 36 20 6b 42 20 :
co:073a: 52 4f 4d 0d 0a :
co:073f: 3c 6c 69 3e 32 :   .dc.b "<li>256 kB RAM<li>128 kB Flash<br>",13,10
co:0744: 35 36 20 6b 42 :
co:0749: 20 52 41 4d 3c :
co:074e: 6c 69 3e 31 32 :
co:0753: 38 20 6b 42 20 :
co:0758: 46 6c 61 73 68 :
co:075d: 3c 62 72 3e 0d :
co:0762: 0a             :
co:0763: 3c 6c 69 3e 56 :   .dc.b "<li>VGA-interface</li>",13,10
co:0768: 47 41 2d 69 6e :
co:076d: 74 65 72 66 61 :
co:0772: 63 65 3c 2f 6c :
co:0777: 69 3e 0d 0a    :
co:077b: 3c 6c 69 3e 54 :   .dc.b "<li>TCP / IP Stack <br></li></td>",13,10
co:0780: 43 50 20 2f 20 :
co:0785: 49 50 20 53 74 :
co:078a: 61 63 6b 20 3c :
co:078f: 62 72 3e 3c 2f :
co:0794: 6c 69 3e 3c 2f :
co:0799: 74 64 3e 0d 0a :
co:079e: 3c 2f 74 72 3e :   .dc.b "</tr><tr><td valign=top width=31>&nbsp;</td>",13,10
co:07a3: 3c 74 72 3e 3c :
co:07a8: 74 64 20 76 61 :
co:07ad: 6c 69 67 6e 3d :
co:07b2: 74 6f 70 20 77 :
co:07b7: 69 64 74 68 3d :
co:07bc: 33 31 3e 26 6e :
co:07c1: 62 73 70 3b 3c :
co:07c6: 2f 74 64 3e 0d :
co:07cb: 0a             :
co:07cc: 3c 74 64 20 76 :   .dc.b "<td valign=top width=403>&nbsp;<p><b>Eval-Board Features:</b><br"
co:07d1: 61 6c 69 67 6e :
co:07d6: 3d 74 6f 70 20 :
co:07db: 77 69 64 74 68 :
co:07e0: 3d 34 30 33 3e :
co:07e5: 26 6e 62 73 70 :
co:07ea: 3b 3c 70 3e 3c :
co:07ef: 62 3e 45 76 61 :
co:07f4: 6c 2d 42 6f 61 :
co:07f9: 72 64 20 46 65 :
co:07fe: 61 74 75 72 65 :
co:0803: 73 3a 3c 2f 62 :
co:0808: 3e 3c 62 72    :
co:080c: 3e 0d 0a       :   .dc.b ">",13,10
co:080f: 3c 2f 70 3e 0d :   .dc.b "</p>",13,10
co:0814: 0a             :
co:0815: 3c 6c 69 3e 31 :   .dc.b "<li>10/100 Mb Ethernet Phy<li>Full-Speed USB<li>VGA-output<li>An"
co:081a: 30 2f 31 30 30 :
co:081f: 20 4d 62 20 45 :
co:0824: 74 68 65 72 6e :
co:0829: 65 74 20 50 68 :
co:082e: 79 3c 6c 69 3e :
co:0833: 46 75 6c 6c 2d :
co:0838: 53 70 65 65 64 :
co:083d: 20 55 53 42 3c :
co:0842: 6c 69 3e 56 47 :
co:0847: 41 2d 6f 75 74 :
co:084c: 70 75 74 3c 6c :
co:0851: 69 3e 41 6e    :
co:0855: 61 6c 6f 67 20 :   .dc.b "alog I/O<li>",13,10
co:085a: 49 2f 4f 3c 6c :
co:085f: 69 3e 0d 0a    :
co:0863: 44 69 67 69 74 :   .dc.b "Digital I/O<li>LCD-Display<li>PS/2 Interface (2 pcs.)<li>16 bit "
co:0868: 61 6c 20 49 2f :
co:086d: 4f 3c 6c 69 3e :
co:0872: 4c 43 44 2d 44 :
co:0877: 69 73 70 6c 61 :
co:087c: 79 3c 6c 69 3e :
co:0881: 50 53 2f 32 20 :
co:0886: 49 6e 74 65 72 :
co:088b: 66 61 63 65 20 :
co:0890: 28 32 20 70 63 :
co:0895: 73 2e 29 3c 6c :
co:089a: 69 3e 31 36 20 :
co:089f: 62 69 74 20    :
co:08a3: 53 74 65 72 65 :   .dc.b "Stereo Audio ",13,10
co:08a8: 6f 20 41 75 64 :
co:08ad: 69 6f 20 0d 0a :
co:08b2: 43 6f 64 65 63 :   .dc.b "Codec (48 kHz)<li>8 Leds and 4 7-Segmentdisplays<li>I2C Interfac"
co:08b7: 20 28 34 38 20 :
co:08bc: 6b 48 7a 29 3c :
co:08c1: 6c 69 3e 38 20 :
co:08c6: 4c 65 64 73 20 :
co:08cb: 61 6e 64 20 34 :
co:08d0: 20 37 2d 53 65 :
co:08d5: 67 6d 65 6e 74 :
co:08da: 64 69 73 70 6c :
co:08df: 61 79 73 3c 6c :
co:08e4: 69 3e 49 32 43 :
co:08e9: 20 49 6e 74 65 :
co:08ee: 72 66 61 63    :
co:08f2: 65 3c 62 72 3e :   .dc.b "e<br>",13,10
co:08f7: 0d 0a          :
co:08f9: 0d 0a          :   .dc.b 13,10
co:08fb: 3c 2f 74 64 3e :   .dc.b "</td>",13,10
co:0900: 0d 0a          :
co:0902: 3c 74 64 20 77 :   .dc.b "<td width=12>&nbsp;</td>",13,10
co:0907: 69 64 74 68 3d :
co:090c: 31 32 3e 26 6e :
co:0911: 62 73 70 3b 3c :
co:0916: 2f 74 64 3e 0d :
co:091b: 0a             :
co:091c: 3c 74 64 20 76 :   .dc.b "<td valign=top width=427>&nbsp;</td>",13,10
co:0921: 61 6c 69 67 6e :
co:0926: 3d 74 6f 70 20 :
co:092b: 77 69 64 74 68 :
co:0930: 3d 34 32 37 3e :
co:0935: 26 6e 62 73 70 :
co:093a: 3b 3c 2f 74 64 :
co:093f: 3e 0d 0a       :
co:0942: 3c 2f 74 72 3e :   .dc.b "</tr></table><p>&nbsp;</p><p>Links:</p></b></p>",13,10
co:0947: 3c 2f 74 61 62 :
co:094c: 6c 65 3e 3c 70 :
co:0951: 3e 26 6e 62 73 :
co:0956: 70 3b 3c 2f 70 :
co:095b: 3e 3c 70 3e 4c :
co:0960: 69 6e 6b 73 3a :
co:0965: 3c 2f 70 3e 3c :
co:096a: 2f 62 3e 3c 2f :
co:096f: 70 3e 0d 0a    :
co:0973: 3c 74 61 62 6c :   .dc.b "<table border=0>",13,10
co:0978: 65 20 62 6f 72 :
co:097d: 64 65 72 3d 30 :
co:0982: 3e 0d 0a       :
co:0985: 3c 74 72 3e 3c :   .dc.b "<tr><td><a href=",34,"io.html",34,">IO-Form demo:</a></td><td>Dy"
co:098a: 74 64 3e 3c 61 :
co:098f: 20 68 72 65 66 :
co:0994: 3d 22 69 6f 2e :
co:0999: 68 74 6d 6c 22 :
co:099e: 3e 49 4f 2d 46 :
co:09a3: 6f 72 6d 20 64 :
co:09a8: 65 6d 6f 3a 3c :
co:09ad: 2f 61 3e 3c 2f :
co:09b2: 74 64 3e 3c 74 :
co:09b7: 64 3e 44 79    :
co:09bb: 6e 61 6d 69 63 :   .dc.b "namic forms</td></tr>",13,10
co:09c0: 20 66 6f 72 6d :
co:09c5: 73 3c 2f 74 64 :
co:09ca: 3e 3c 2f 74 72 :
co:09cf: 3e 0d 0a       :
co:09d2: 3c 74 72 3e 3c :   .dc.b "<tr><td><a href=",34,"ad_disp.html",34,">A/D demo:</a></td><td>D"
co:09d7: 74 64 3e 3c 61 :
co:09dc: 20 68 72 65 66 :
co:09e1: 3d 22 61 64 5f :
co:09e6: 64 69 73 70 2e :
co:09eb: 68 74 6d 6c 22 :
co:09f0: 3e 41 2f 44 20 :
co:09f5: 64 65 6d 6f 3a :
co:09fa: 3c 2f 61 3e 3c :
co:09ff: 2f 74 64 3e 3c :
co:0a04: 74 64 3e 44    :
co:0a08: 79 6e 61 6d 69 :   .dc.b "ynamic HTML</td></tr>",13,10
co:0a0d: 63 20 48 54 4d :
co:0a12: 4c 3c 2f 74 64 :
co:0a17: 3e 3c 2f 74 72 :
co:0a1c: 3e 0d 0a       :
co:0a1f: 3c 74 72 3e 3c :   .dc.b "<tr><td><a href=",34,"http:\\www.elektor.com",34,">Elektor Homep"
co:0a24: 74 64 3e 3c 61 :
co:0a29: 20 68 72 65 66 :
co:0a2e: 3d 22 68 74 74 :
co:0a33: 70 3a 5c 5c 77 :
co:0a38: 77 77 2e 65 6c :
co:0a3d: 65 6b 74 6f 72 :
co:0a42: 2e 63 6f 6d 22 :
co:0a47: 3e 45 6c 65 6b :
co:0a4c: 74 6f 72 20 48 :
co:0a51: 6f 6d 65 70    :
co:0a55: 61 67 65 3c 2f :   .dc.b "age</a>:</td><td>Visit us!</td></tr>",13,10
co:0a5a: 61 3e 3a 3c 2f :
co:0a5f: 74 64 3e 3c 74 :
co:0a64: 64 3e 56 69 73 :
co:0a69: 69 74 20 75 73 :
co:0a6e: 21 3c 2f 74 64 :
co:0a73: 3e 3c 2f 74 72 :
co:0a78: 3e 0d 0a       :
co:0a7b: 3c 2f 74 61 62 :   .dc.b "</table>",13,10
co:0a80: 6c 65 3e 0d 0a :
co:0a85: 3c 2f 62 6f 64 :   .dc.b "</body></html>"
co:0a8a: 79 3e 3c 2f 68 :
co:0a8f: 74 6d 6c 3e    :
                        : ; End
=                 _home =   245 (hex),    581 (dez), text

objectfile:reply.obj:
                        : ; ********************************************************
                        : ; * reply.s51 (Source: reply.html)
                        : ; * generated by WEBCODE 2004 (C) www.wickenhaeuser.de
                        : ; ********************************************************
                        : ; * extern code unsigned char reply[];
                        : 
                        :   .segment __reply
                        :   .export _reply
                        :   .import ____reply_size__
                        : _reply: 
co:0026: 01 41          :   .dc.w ____reply_size__-3
co:0028: 01             :   .dc.b 1
co:0029: 48 54 54 50 2f :   .dc.b "HTTP/1.0 200 OK",13,10
co:002e: 31 2e 30 20 32 :
co:0033: 30 30 20 4f 4b :
co:0038: 0d 0a          :
co:003a: 43 6f 6e 74 65 :   .dc.b "Content-type: text/html",13,10
co:003f: 6e 74 2d 74 79 :
co:0044: 70 65 3a 20 74 :
co:0049: 65 78 74 2f 68 :
co:004e: 74 6d 6c 0d 0a :
co:0053: 43 6f 6e 6e 65 :   .dc.b "Connection: close",13,10,13,10
co:0058: 63 74 69 6f 6e :
co:005d: 3a 20 63 6c 6f :
co:0062: 73 65 0d 0a 0d :
co:0067: 0a             :
                        : 
co:0068: 3c 68 74 6d 6c :   .dc.b "<html><head><title>Reply</title></head>",13,10
co:006d: 3e 3c 68 65 61 :
co:0072: 64 3e 3c 74 69 :
co:0077: 74 6c 65 3e 52 :
co:007c: 65 70 6c 79 3c :
co:0081: 2f 74 69 74 6c :
co:0086: 65 3e 3c 2f 68 :
co:008b: 65 61 64 3e 0d :
co:0090: 0a             :
co:0091: 3c 62 6f 64 79 :   .dc.b "<body bgcolor=#505050 text=#FFFF00 vlink=#80FFFF link=#FF80FF al"
co:0096: 20 62 67 63 6f :
co:009b: 6c 6f 72 3d 23 :
co:00a0: 35 30 35 30 35 :
co:00a5: 30 20 74 65 78 :
co:00aa: 74 3d 23 46 46 :
co:00af: 46 46 30 30 20 :
co:00b4: 76 6c 69 6e 6b :
co:00b9: 3d 23 38 30 46 :
co:00be: 46 46 46 20 6c :
co:00c3: 69 6e 6b 3d 23 :
co:00c8: 46 46 38 30 46 :
co:00cd: 46 20 61 6c    :
co:00d1: 69 6e 6b 3d 23 :   .dc.b "ink=#FF80FF>",13,10
co:00d6: 46 46 38 30 46 :
co:00db: 46 3e 0d 0a    :
co:00df: 3c 70 3e 3c 62 :   .dc.b "<p><b><h2><i>Elektor FPGA Webserver - IO Form</i></h2></b></p>",13
co:00e4: 3e 3c 68 32 3e :
co:00e9: 3c 69 3e 45 6c :
co:00ee: 65 6b 74 6f 72 :
co:00f3: 20 46 50 47 41 :
co:00f8: 20 57 65 62 73 :
co:00fd: 65 72 76 65 72 :
co:0102: 20 2d 20 49 4f :
co:0107: 20 46 6f 72 6d :
co:010c: 3c 2f 69 3e 3c :
co:0111: 2f 68 32 3e 3c :
co:0116: 2f 62 3e 3c 2f :
co:011b: 70 3e 0d       :
co:011e: 0a             :   .dc.b 10
co:011f: 4e 65 77 20 76 :   .dc.b "New values accepted.<br><br>",13,10
co:0124: 61 6c 75 65 73 :
co:0129: 20 61 63 63 65 :
co:012e: 70 74 65 64 2e :
co:0133: 3c 62 72 3e 3c :
co:0138: 62 72 3e 0d 0a :
co:013d: 3c 61 20 68 72 :   .dc.b "<a href=",34,"io.html",34,">back...</a>",13,10
co:0142: 65 66 3d 22 69 :
co:0147: 6f 2e 68 74 6d :
co:014c: 6c 22 3e 62 61 :
co:0151: 63 6b 2e 2e 2e :
co:0156: 3c 2f 61 3e 0d :
co:015b: 0a             :
co:015c: 3c 2f 62 6f 64 :   .dc.b "</body></html>"
co:0161: 79 3e 3c 2f 68 :
co:0166: 74 6d 6c 3e    :
                        : ; End
=                _reply =    26 (hex),     38 (dez), text

objectfile:io.obj:
                        : ; ********************************************************
                        : ; * io.s51 (Source: io.html)
                        : ; * generated by WEBCODE 2004 (C) www.wickenhaeuser.de
                        : ; ********************************************************
                        : ; * extern code unsigned char io[];
                        : 
                        :   .segment __io
                        :   .export _io
                        :   .import ____io_size__
                        : _io: 
co:0bab: 07 d2          :   .dc.w ____io_size__-3
co:0bad: 01             :   .dc.b 1
co:0bae: 48 54 54 50 2f :   .dc.b "HTTP/1.0 200 OK",13,10
co:0bb3: 31 2e 30 20 32 :
co:0bb8: 30 30 20 4f 4b :
co:0bbd: 0d 0a          :
co:0bbf: 43 6f 6e 74 65 :   .dc.b "Content-type: text/html",13,10
co:0bc4: 6e 74 2d 74 79 :
co:0bc9: 70 65 3a 20 74 :
co:0bce: 65 78 74 2f 68 :
co:0bd3: 74 6d 6c 0d 0a :
co:0bd8: 43 6f 6e 6e 65 :   .dc.b "Connection: close",13,10,13,10
co:0bdd: 63 74 69 6f 6e :
co:0be2: 3a 20 63 6c 6f :
co:0be7: 73 65 0d 0a 0d :
co:0bec: 0a             :
                        : 
co:0bed: 3c 68 74 6d 6c :   .dc.b "<html>",13,10
co:0bf2: 3e 0d 0a       :
co:0bf5: 3c 68 65 61 64 :   .dc.b "<head>",13,10
co:0bfa: 3e 0d 0a       :
co:0bfd: 3c 74 69 74 6c :   .dc.b "<title>HPE_mini Peripherals</title></head>",13,10
co:0c02: 65 3e 48 50 45 :
co:0c07: 5f 6d 69 6e 69 :
co:0c0c: 20 50 65 72 69 :
co:0c11: 70 68 65 72 61 :
co:0c16: 6c 73 3c 2f 74 :
co:0c1b: 69 74 6c 65 3e :
co:0c20: 3c 2f 68 65 61 :
co:0c25: 64 3e 0d 0a    :
co:0c29: 3c 62 6f 64 79 :   .dc.b "<body bgcolor=",34,"#505050",34," text=#FFFF00>",13,10
co:0c2e: 20 62 67 63 6f :
co:0c33: 6c 6f 72 3d 22 :
co:0c38: 23 35 30 35 30 :
co:0c3d: 35 30 22 20 74 :
co:0c42: 65 78 74 3d 23 :
co:0c47: 46 46 46 46 30 :
co:0c4c: 30 3e 0d 0a    :
co:0c50: 3c 70 20 61 6c :   .dc.b "<p align=",34,"center",34,"><u><font size=",34,"6",34,"><b>FPGA "
co:0c55: 69 67 6e 3d 22 :
co:0c5a: 63 65 6e 74 65 :
co:0c5f: 72 22 3e 3c 75 :
co:0c64: 3e 3c 66 6f 6e :
co:0c69: 74 20 73 69 7a :
co:0c6e: 65 3d 22 36 22 :
co:0c73: 3e 3c 62 3e 46 :
co:0c78: 50 47 41 20    :
co:0c7c: 50 65 72 69 70 :   .dc.b "Peripherals</font></u></b>",13,10
co:0c81: 68 65 72 61 6c :
co:0c86: 73 3c 2f 66 6f :
co:0c8b: 6e 74 3e 3c 2f :
co:0c90: 75 3e 3c 2f 62 :
co:0c95: 3e 0d 0a       :
co:0c98: 3c 70 3e 26 6e :   .dc.b "<p>&nbsp;</p>",13,10
co:0c9d: 62 73 70 3b 3c :
co:0ca2: 2f 70 3e 0d 0a :
co:0ca7: 3c 66 6f 72 6d :   .dc.b "<form method=",34,"GET",34," action=",34,"reply.html",34,">",13,10
co:0cac: 20 6d 65 74 68 :
co:0cb1: 6f 64 3d 22 47 :
co:0cb6: 45 54 22 20 61 :
co:0cbb: 63 74 69 6f 6e :
co:0cc0: 3d 22 72 65 70 :
co:0cc5: 6c 79 2e 68 74 :
co:0cca: 6d 6c 22 3e 0d :
co:0ccf: 0a             :
co:0cd0: 3c 74 61 62 6c :   .dc.b "<table border=",34,"0",34," width=",34,"100%",34,"><tr>",13,10
co:0cd5: 65 20 62 6f 72 :
co:0cda: 64 65 72 3d 22 :
co:0cdf: 30 22 20 77 69 :
co:0ce4: 64 74 68 3d 22 :
co:0ce9: 31 30 30 25 22 :
co:0cee: 3e 3c 74 72 3e :
co:0cf3: 0d 0a          :
co:0cf5: 3c 74 64 20 77 :   .dc.b "<td width=",34,"16%",34,"><table border=",34,"0",34," width=",34
co:0cfa: 69 64 74 68 3d :
co:0cff: 22 31 36 25 22 :
co:0d04: 3e 3c 74 61 62 :
co:0d09: 6c 65 20 62 6f :
co:0d0e: 72 64 65 72 3d :
co:0d13: 22 30 22 20 77 :
co:0d18: 69 64 74 68 3d :
co:0d1d: 22             :
co:0d1e: 38 32 25 22 20 :   .dc.b "82%",34," cellspacing=",34,"3",34,">",13,10
co:0d23: 63 65 6c 6c 73 :
co:0d28: 70 61 63 69 6e :
co:0d2d: 67 3d 22 33 22 :
co:0d32: 3e 0d 0a       :
co:0d35: 3c 74 72 3e 3c :   .dc.b "<tr><td width=",34,"55%",34," rowspan=",34,"7",34,">",13,10
co:0d3a: 74 64 20 77 69 :
co:0d3f: 64 74 68 3d 22 :
co:0d44: 35 35 25 22 20 :
co:0d49: 72 6f 77 73 70 :
co:0d4e: 61 6e 3d 22 37 :
co:0d53: 22 3e 0d 0a    :
co:0d57: 3c 70 20 61 6c :   .dc.b "<p align=",34,"center",34,"><font size=",34,"4",34,"><b>7-Segmen"
co:0d5c: 69 67 6e 3d 22 :
co:0d61: 63 65 6e 74 65 :
co:0d66: 72 22 3e 3c 66 :
co:0d6b: 6f 6e 74 20 73 :
co:0d70: 69 7a 65 3d 22 :
co:0d75: 34 22 3e 3c 62 :
co:0d7a: 3e 37 2d 53 65 :
co:0d7f: 67 6d 65 6e    :
co:0d83: 74 64 69 73 70 :   .dc.b "tdisplay :</b></font></p>",13,10
co:0d88: 6c 61 79 20 3a :
co:0d8d: 3c 2f 62 3e 3c :
co:0d92: 2f 66 6f 6e 74 :
co:0d97: 3e 3c 2f 70 3e :
co:0d9c: 0d 0a          :
co:0d9e: 3c 70 20 61 6c :   .dc.b "<p align=",34,"center",34,">Enable <input type=",34,"checkbox",34
co:0da3: 69 67 6e 3d 22 :
co:0da8: 63 65 6e 74 65 :
co:0dad: 72 22 3e 45 6e :
co:0db2: 61 62 6c 65 20 :
co:0db7: 3c 69 6e 70 75 :
co:0dbc: 74 20 74 79 70 :
co:0dc1: 65 3d 22 63 68 :
co:0dc6: 65 63 6b 62 6f :
co:0dcb: 78 22          :
co:0dcd: 20 6e 61 6d 65 :   .dc.b " name=A1 value=",34,"ON",34," "
co:0dd2: 3d 41 31 20 76 :
co:0dd7: 61 6c 75 65 3d :
co:0ddc: 22 4f 4e 22 20 :
co:0de1: ff             :   .dc.b 255
                        :   .import _En0 ;  (char xdata*)En0
co:0de2: 08 67          :   .dc.w _En0
co:0de4: 3e 3c 69 6e 70 :   .dc.b "><input type=",34,"checkbox",34," name=A2 value=",34,"ON",34," "
co:0de9: 75 74 20 74 79 :
co:0dee: 70 65 3d 22 63 :
co:0df3: 68 65 63 6b 62 :
co:0df8: 6f 78 22 20 6e :
co:0dfd: 61 6d 65 3d 41 :
co:0e02: 32 20 76 61 6c :
co:0e07: 75 65 3d 22 4f :
co:0e0c: 4e 22 20       :
co:0e0f: ff             :   .dc.b 255
                        :   .import _En1 ;  (char xdata*)En1
co:0e10: 08 5f          :   .dc.w _En1
co:0e12: 3e 0d 0a       :   .dc.b ">",13,10
co:0e15: 3c 69 6e 70 75 :   .dc.b "<input type=",34,"checkbox",34," name=A3 value=",34,"ON",34," "
co:0e1a: 74 20 74 79 70 :
co:0e1f: 65 3d 22 63 68 :
co:0e24: 65 63 6b 62 6f :
co:0e29: 78 22 20 6e 61 :
co:0e2e: 6d 65 3d 41 33 :
co:0e33: 20 76 61 6c 75 :
co:0e38: 65 3d 22 4f 4e :
co:0e3d: 22 20          :
co:0e3f: ff             :   .dc.b 255
                        :   .import _En2 ;  (char xdata*)En2
co:0e40: 08 57          :   .dc.w _En2
co:0e42: 3e 3c 69 6e 70 :   .dc.b "><input type=",34,"checkbox",34," name=A4 value=",34,"ON",34," "
co:0e47: 75 74 20 74 79 :
co:0e4c: 70 65 3d 22 63 :
co:0e51: 68 65 63 6b 62 :
co:0e56: 6f 78 22 20 6e :
co:0e5b: 61 6d 65 3d 41 :
co:0e60: 34 20 76 61 6c :
co:0e65: 75 65 3d 22 4f :
co:0e6a: 4e 22 20       :
co:0e6d: ff             :   .dc.b 255
                        :   .import _En3 ;  (char xdata*)En3
co:0e6e: 08 4f          :   .dc.w _En3
co:0e70: 3e 3c 2f 70 3e :   .dc.b "></p>",13,10
co:0e75: 0d 0a          :
co:0e77: 3c 70 20 61 6c :   .dc.b "<p align=",34,"center",34,">Value (hex)&nbsp; <input type=",34,"t"
co:0e7c: 69 67 6e 3d 22 :
co:0e81: 63 65 6e 74 65 :
co:0e86: 72 22 3e 56 61 :
co:0e8b: 6c 75 65 20 28 :
co:0e90: 68 65 78 29 26 :
co:0e95: 6e 62 73 70 3b :
co:0e9a: 20 3c 69 6e 70 :
co:0e9f: 75 74 20 74 79 :
co:0ea4: 70 65 3d 22 74 :
co:0ea9: 65 78 74 22 20 :   .dc.b "ext",34," name=A5 size=",34,"4",34," value=",34
co:0eae: 6e 61 6d 65 3d :
co:0eb3: 41 35 20 73 69 :
co:0eb8: 7a 65 3d 22 34 :
co:0ebd: 22 20 76 61 6c :
co:0ec2: 75 65 3d 22    :
co:0ec6: ff             :   .dc.b 255
                        :   .import _sevseg ;  (char xdata*)sevseg
co:0ec7: 08 4a          :   .dc.w _sevseg
co:0ec9: 22 3e 3c 2f 70 :   .dc.b 34,"></p>",13,10
co:0ece: 3e 0d 0a       :
co:0ed1: 3c 70 3e 26 6e :   .dc.b "<p>&nbsp;</td><td width=",34,"145%",34," align=",34,"left",34,">"
co:0ed6: 62 73 70 3b 3c :
co:0edb: 2f 74 64 3e 3c :
co:0ee0: 74 64 20 77 69 :
co:0ee5: 64 74 68 3d 22 :
co:0eea: 31 34 35 25 22 :
co:0eef: 20 61 6c 69 67 :
co:0ef4: 6e 3d 22 6c 65 :
co:0ef9: 66 74 22 3e    :
co:0efd: 0d 0a          :   .dc.b 13,10
co:0eff: 3c 70 20 61 6c :   .dc.b "<p align=",34,"center",34,">Led 7 <input type=",34,"checkbox",34
co:0f04: 69 67 6e 3d 22 :
co:0f09: 63 65 6e 74 65 :
co:0f0e: 72 22 3e 4c 65 :
co:0f13: 64 20 37 20 3c :
co:0f18: 69 6e 70 75 74 :
co:0f1d: 20 74 79 70 65 :
co:0f22: 3d 22 63 68 65 :
co:0f27: 63 6b 62 6f 78 :
co:0f2c: 22             :
co:0f2d: 20 6e 61 6d 65 :   .dc.b " name=A6 value=",34,"ON",34," "
co:0f32: 3d 41 36 20 76 :
co:0f37: 61 6c 75 65 3d :
co:0f3c: 22 4f 4e 22 20 :
co:0f41: ff             :   .dc.b 255
                        :   .import _C0 ;  (char xdata*)C0
co:0f42: 08 42          :   .dc.w _C0
co:0f44: 3e 3c 2f 74 64 :   .dc.b "></td></tr>",13,10
co:0f49: 3e 3c 2f 74 72 :
co:0f4e: 3e 0d 0a       :
co:0f51: 3c 74 72 3e 3c :   .dc.b "<tr><td width=",34,"145%",34," align=",34,"left",34,"><p align=",34
co:0f56: 74 64 20 77 69 :
co:0f5b: 64 74 68 3d 22 :
co:0f60: 31 34 35 25 22 :
co:0f65: 20 61 6c 69 67 :
co:0f6a: 6e 3d 22 6c 65 :
co:0f6f: 66 74 22 3e 3c :
co:0f74: 70 20 61 6c 69 :
co:0f79: 67 6e 3d 22    :
co:0f7d: 63 65 6e 74 65 :   .dc.b "center",34,">Led 6 <input type=",34,"checkbox",34," name=A7 valu"
co:0f82: 72 22 3e 4c 65 :
co:0f87: 64 20 36 20 3c :
co:0f8c: 69 6e 70 75 74 :
co:0f91: 20 74 79 70 65 :
co:0f96: 3d 22 63 68 65 :
co:0f9b: 63 6b 62 6f 78 :
co:0fa0: 22 20 6e 61 6d :
co:0fa5: 65 3d 41 37 20 :
co:0faa: 76 61 6c 75    :
co:0fae: 65 3d 22 4f 4e :   .dc.b "e=",34,"ON",34," "
co:0fb3: 22 20          :
co:0fb5: ff             :   .dc.b 255
                        :   .import _C1 ;  (char xdata*)C1
co:0fb6: 08 3a          :   .dc.w _C1
co:0fb8: 3e 3c 2f 74 64 :   .dc.b "></td></tr>",13,10
co:0fbd: 3e 3c 2f 74 72 :
co:0fc2: 3e 0d 0a       :
co:0fc5: 3c 74 72 3e 3c :   .dc.b "<tr><td width=",34,"145%",34," align=",34,"left",34,"><p align=",34
co:0fca: 74 64 20 77 69 :
co:0fcf: 64 74 68 3d 22 :
co:0fd4: 31 34 35 25 22 :
co:0fd9: 20 61 6c 69 67 :
co:0fde: 6e 3d 22 6c 65 :
co:0fe3: 66 74 22 3e 3c :
co:0fe8: 70 20 61 6c 69 :
co:0fed: 67 6e 3d 22    :
co:0ff1: 63 65 6e 74 65 :   .dc.b "center",34,">Led 5 <input type=",34,"checkbox",34," name=A8 valu"
co:0ff6: 72 22 3e 4c 65 :
co:0ffb: 64 20 35 20 3c :
co:1000: 69 6e 70 75 74 :
co:1005: 20 74 79 70 65 :
co:100a: 3d 22 63 68 65 :
co:100f: 63 6b 62 6f 78 :
co:1014: 22 20 6e 61 6d :
co:1019: 65 3d 41 38 20 :
co:101e: 76 61 6c 75    :
co:1022: 65 3d 22 4f 4e :   .dc.b "e=",34,"ON",34," "
co:1027: 22 20          :
co:1029: ff             :   .dc.b 255
                        :   .import _C2 ;  (char xdata*)C2
co:102a: 08 32          :   .dc.w _C2
co:102c: 3e 3c 2f 74 64 :   .dc.b "></td></tr>",13,10
co:1031: 3e 3c 2f 74 72 :
co:1036: 3e 0d 0a       :
co:1039: 3c 74 72 3e 3c :   .dc.b "<tr><td width=",34,"145%",34," align=",34,"left",34,"><p align=",34
co:103e: 74 64 20 77 69 :
co:1043: 64 74 68 3d 22 :
co:1048: 31 34 35 25 22 :
co:104d: 20 61 6c 69 67 :
co:1052: 6e 3d 22 6c 65 :
co:1057: 66 74 22 3e 3c :
co:105c: 70 20 61 6c 69 :
co:1061: 67 6e 3d 22    :
co:1065: 63 65 6e 74 65 :   .dc.b "center",34,">Led 4 <input type=",34,"checkbox",34," name=A9 valu"
co:106a: 72 22 3e 4c 65 :
co:106f: 64 20 34 20 3c :
co:1074: 69 6e 70 75 74 :
co:1079: 20 74 79 70 65 :
co:107e: 3d 22 63 68 65 :
co:1083: 63 6b 62 6f 78 :
co:1088: 22 20 6e 61 6d :
co:108d: 65 3d 41 39 20 :
co:1092: 76 61 6c 75    :
co:1096: 65 3d 22 4f 4e :   .dc.b "e=",34,"ON",34," "
co:109b: 22 20          :
co:109d: ff             :   .dc.b 255
                        :   .import _C3 ;  (char xdata*)C3
co:109e: 08 2a          :   .dc.w _C3
co:10a0: 3e 3c 2f 74 64 :   .dc.b "></td></tr>",13,10
co:10a5: 3e 3c 2f 74 72 :
co:10aa: 3e 0d 0a       :
co:10ad: 3c 74 72 3e 3c :   .dc.b "<tr><td width=",34,"145%",34," align=",34,"left",34,"><p align=",34
co:10b2: 74 64 20 77 69 :
co:10b7: 64 74 68 3d 22 :
co:10bc: 31 34 35 25 22 :
co:10c1: 20 61 6c 69 67 :
co:10c6: 6e 3d 22 6c 65 :
co:10cb: 66 74 22 3e 3c :
co:10d0: 70 20 61 6c 69 :
co:10d5: 67 6e 3d 22    :
co:10d9: 63 65 6e 74 65 :   .dc.b "center",34,">Led 3 <input type=",34,"checkbox",34," name=A10 val"
co:10de: 72 22 3e 4c 65 :
co:10e3: 64 20 33 20 3c :
co:10e8: 69 6e 70 75 74 :
co:10ed: 20 74 79 70 65 :
co:10f2: 3d 22 63 68 65 :
co:10f7: 63 6b 62 6f 78 :
co:10fc: 22 20 6e 61 6d :
co:1101: 65 3d 41 31 30 :
co:1106: 20 76 61 6c    :
co:110a: 75 65 3d 22 4f :   .dc.b "ue=",34,"ON",34," "
co:110f: 4e 22 20       :
co:1112: ff             :   .dc.b 255
                        :   .import _C4 ;  (char xdata*)C4
co:1113: 08 22          :   .dc.w _C4
co:1115: 3e 3c 2f 74 64 :   .dc.b "></td></tr>",13,10
co:111a: 3e 3c 2f 74 72 :
co:111f: 3e 0d 0a       :
co:1122: 3c 74 72 3e 3c :   .dc.b "<tr><td width=",34,"145%",34," align=",34,"left",34,"><p align=",34
co:1127: 74 64 20 77 69 :
co:112c: 64 74 68 3d 22 :
co:1131: 31 34 35 25 22 :
co:1136: 20 61 6c 69 67 :
co:113b: 6e 3d 22 6c 65 :
co:1140: 66 74 22 3e 3c :
co:1145: 70 20 61 6c 69 :
co:114a: 67 6e 3d 22    :
co:114e: 63 65 6e 74 65 :   .dc.b "center",34,">Led 2 <input type=",34,"checkbox",34," name=A11 val"
co:1153: 72 22 3e 4c 65 :
co:1158: 64 20 32 20 3c :
co:115d: 69 6e 70 75 74 :
co:1162: 20 74 79 70 65 :
co:1167: 3d 22 63 68 65 :
co:116c: 63 6b 62 6f 78 :
co:1171: 22 20 6e 61 6d :
co:1176: 65 3d 41 31 31 :
co:117b: 20 76 61 6c    :
co:117f: 75 65 3d 22 4f :   .dc.b "ue=",34,"ON",34," "
co:1184: 4e 22 20       :
co:1187: ff             :   .dc.b 255
                        :   .import _C5 ;  (char xdata*)C5
co:1188: 08 1a          :   .dc.w _C5
co:118a: 3e 3c 2f 74 64 :   .dc.b "></td></tr>",13,10
co:118f: 3e 3c 2f 74 72 :
co:1194: 3e 0d 0a       :
co:1197: 3c 74 72 3e 3c :   .dc.b "<tr><td width=",34,"145%",34," align=",34,"left",34,"><p align=",34
co:119c: 74 64 20 77 69 :
co:11a1: 64 74 68 3d 22 :
co:11a6: 31 34 35 25 22 :
co:11ab: 20 61 6c 69 67 :
co:11b0: 6e 3d 22 6c 65 :
co:11b5: 66 74 22 3e 3c :
co:11ba: 70 20 61 6c 69 :
co:11bf: 67 6e 3d 22    :
co:11c3: 63 65 6e 74 65 :   .dc.b "center",34,">Led 1 <input type=",34,"checkbox",34," name=A12 val"
co:11c8: 72 22 3e 4c 65 :
co:11cd: 64 20 31 20 3c :
co:11d2: 69 6e 70 75 74 :
co:11d7: 20 74 79 70 65 :
co:11dc: 3d 22 63 68 65 :
co:11e1: 63 6b 62 6f 78 :
co:11e6: 22 20 6e 61 6d :
co:11eb: 65 3d 41 31 32 :
co:11f0: 20 76 61 6c    :
co:11f4: 75 65 3d 22 4f :   .dc.b "ue=",34,"ON",34," "
co:11f9: 4e 22 20       :
co:11fc: ff             :   .dc.b 255
                        :   .import _C6 ;  (char xdata*)C6
co:11fd: 08 12          :   .dc.w _C6
co:11ff: 3e 3c 2f 74 64 :   .dc.b "></td></tr>",13,10
co:1204: 3e 3c 2f 74 72 :
co:1209: 3e 0d 0a       :
co:120c: 3c 2f 74 61 62 :   .dc.b "</table></td></tr></table>",13,10
co:1211: 6c 65 3e 3c 2f :
co:1216: 74 64 3e 3c 2f :
co:121b: 74 72 3e 3c 2f :
co:1220: 74 61 62 6c 65 :
co:1225: 3e 0d 0a       :
co:1228: 3c 70 3e 26 6e :   .dc.b "<p>&nbsp;</p>",13,10
co:122d: 62 73 70 3b 3c :
co:1232: 2f 70 3e 0d 0a :
co:1237: 3c 70 3e 3c 69 :   .dc.b "<p><input type=",34,"submit",34," value=",34,"Set Peripherals",34
co:123c: 6e 70 75 74 20 :
co:1241: 74 79 70 65 3d :
co:1246: 22 73 75 62 6d :
co:124b: 69 74 22 20 76 :
co:1250: 61 6c 75 65 3d :
co:1255: 22 53 65 74 20 :
co:125a: 50 65 72 69 70 :
co:125f: 68 65 72 61 6c :
co:1264: 73 22          :
co:1266: 20 6e 61 6d 65 :   .dc.b " name=A14></p>",13,10
co:126b: 3d 41 31 34 3e :
co:1270: 3c 2f 70 3e 0d :
co:1275: 0a             :
co:1276: 3c 2f 66 6f 72 :   .dc.b "</form>",13,10
co:127b: 6d 3e 0d 0a    :
co:127f: 0d 0a          :   .dc.b 13,10
co:1281: 3c 2f 74 72 3e :   .dc.b "</tr></table><p>&nbsp;</p><p>Links:</p></b></p>",13,10
co:1286: 3c 2f 74 61 62 :
co:128b: 6c 65 3e 3c 70 :
co:1290: 3e 26 6e 62 73 :
co:1295: 70 3b 3c 2f 70 :
co:129a: 3e 3c 70 3e 4c :
co:129f: 69 6e 6b 73 3a :
co:12a4: 3c 2f 70 3e 3c :
co:12a9: 2f 62 3e 3c 2f :
co:12ae: 70 3e 0d 0a    :
co:12b2: 3c 74 61 62 6c :   .dc.b "<table border=0>",13,10
co:12b7: 65 20 62 6f 72 :
co:12bc: 64 65 72 3d 30 :
co:12c1: 3e 0d 0a       :
co:12c4: 3c 74 72 3e 3c :   .dc.b "<tr><td><a href=",34,"io.html",34,">Update Page:</a></td><td>Rel"
co:12c9: 74 64 3e 3c 61 :
co:12ce: 20 68 72 65 66 :
co:12d3: 3d 22 69 6f 2e :
co:12d8: 68 74 6d 6c 22 :
co:12dd: 3e 55 70 64 61 :
co:12e2: 74 65 20 50 61 :
co:12e7: 67 65 3a 3c 2f :
co:12ec: 61 3e 3c 2f 74 :
co:12f1: 64 3e 3c 74 64 :
co:12f6: 3e 52 65 6c    :
co:12fa: 6f 61 64 20 70 :   .dc.b "oad page with current settings</td></tr>",13,10
co:12ff: 61 67 65 20 77 :
co:1304: 69 74 68 20 63 :
co:1309: 75 72 72 65 6e :
co:130e: 74 20 73 65 74 :
co:1313: 74 69 6e 67 73 :
co:1318: 3c 2f 74 64 3e :
co:131d: 3c 2f 74 72 3e :
co:1322: 0d 0a          :
co:1324: 3c 74 72 3e 3c :   .dc.b "<tr><td><a href=",34,"home.html",34,">Back</a></td><td>To homepa"
co:1329: 74 64 3e 3c 61 :
co:132e: 20 68 72 65 66 :
co:1333: 3d 22 68 6f 6d :
co:1338: 65 2e 68 74 6d :
co:133d: 6c 22 3e 42 61 :
co:1342: 63 6b 3c 2f 61 :
co:1347: 3e 3c 2f 74 64 :
co:134c: 3e 3c 74 64 3e :
co:1351: 54 6f 20 68 6f :
co:1356: 6d 65 70 61    :
co:135a: 67 65 3c 2f 74 :   .dc.b "ge</td></tr>",13,10
co:135f: 64 3e 3c 2f 74 :
co:1364: 72 3e 0d 0a    :
co:1368: 3c 2f 74 61 62 :   .dc.b "</table>",13,10
co:136d: 6c 65 3e 0d 0a :
co:1372: 3c 2f 62 6f 64 :   .dc.b "</body></html>"
co:1377: 79 3e 3c 2f 68 :
co:137c: 74 6d 6c 3e    :
                        : ; End
=                   _io =   bab (hex),   2987 (dez), text

objectfile:ad_disp.obj:
                        : ; ********************************************************
                        : ; * ad_disp.s51 (Source: ad_disp.html)
                        : ; * generated by WEBCODE 2004 (C) www.wickenhaeuser.de
                        : ; ********************************************************
                        : ; * extern code unsigned char ad_disp[];
                        : 
                        :   .segment __ad_disp
                        :   .export _ad_disp
                        :   .import ____ad_disp_size__
                        : _ad_disp: 
co:159b: 04 8c          :   .dc.w ____ad_disp_size__-3
co:159d: 01             :   .dc.b 1
co:159e: 48 54 54 50 2f :   .dc.b "HTTP/1.0 200 OK",13,10
co:15a3: 31 2e 30 20 32 :
co:15a8: 30 30 20 4f 4b :
co:15ad: 0d 0a          :
co:15af: 43 6f 6e 74 65 :   .dc.b "Content-type: text/html",13,10
co:15b4: 6e 74 2d 74 79 :
co:15b9: 70 65 3a 20 74 :
co:15be: 65 78 74 2f 68 :
co:15c3: 74 6d 6c 0d 0a :
co:15c8: 43 6f 6e 6e 65 :   .dc.b "Connection: close",13,10,13,10
co:15cd: 63 74 69 6f 6e :
co:15d2: 3a 20 63 6c 6f :
co:15d7: 73 65 0d 0a 0d :
co:15dc: 0a             :
                        : 
co:15dd: 3c 68 74 6d 6c :   .dc.b "<html>",13,10
co:15e2: 3e 0d 0a       :
co:15e5: 3c 68 65 61 64 :   .dc.b "<head>",13,10
co:15ea: 3e 0d 0a       :
co:15ed: 3c 6d 65 74 61 :   .dc.b "<meta http-equiv=refresh content=2>",13,10
co:15f2: 20 68 74 74 70 :
co:15f7: 2d 65 71 75 69 :
co:15fc: 76 3d 72 65 66 :
co:1601: 72 65 73 68 20 :
co:1606: 63 6f 6e 74 65 :
co:160b: 6e 74 3d 32 3e :
co:1610: 0d 0a          :
co:1612: 3c 74 69 74 6c :   .dc.b "<title>Dynamic HTML</title>",13,10
co:1617: 65 3e 44 79 6e :
co:161c: 61 6d 69 63 20 :
co:1621: 48 54 4d 4c 3c :
co:1626: 2f 74 69 74 6c :
co:162b: 65 3e 0d 0a    :
co:162f: 3c 2f 68 65 61 :   .dc.b "</head>",13,10
co:1634: 64 3e 0d 0a    :
co:1638: 3c 62 6f 64 79 :   .dc.b "<body bgcolor=#505050 text=#FFFF00 vlink=#80FFFF link=#FF80FF al"
co:163d: 20 62 67 63 6f :
co:1642: 6c 6f 72 3d 23 :
co:1647: 35 30 35 30 35 :
co:164c: 30 20 74 65 78 :
co:1651: 74 3d 23 46 46 :
co:1656: 46 46 30 30 20 :
co:165b: 76 6c 69 6e 6b :
co:1660: 3d 23 38 30 46 :
co:1665: 46 46 46 20 6c :
co:166a: 69 6e 6b 3d 23 :
co:166f: 46 46 38 30 46 :
co:1674: 46 20 61 6c    :
co:1678: 69 6e 6b 3d 23 :   .dc.b "ink=#FF80FF>",13,10
co:167d: 46 46 38 30 46 :
co:1682: 46 3e 0d 0a    :
co:1686: 3c 70 3e 3c 62 :   .dc.b "<p><b><h2><i>Elektor FPGA Webserver - Dynamic HTML</i></h2></b><"
co:168b: 3e 3c 68 32 3e :
co:1690: 3c 69 3e 45 6c :
co:1695: 65 6b 74 6f 72 :
co:169a: 20 46 50 47 41 :
co:169f: 20 57 65 62 73 :
co:16a4: 65 72 76 65 72 :
co:16a9: 20 2d 20 44 79 :
co:16ae: 6e 61 6d 69 63 :
co:16b3: 20 48 54 4d 4c :
co:16b8: 3c 2f 69 3e 3c :
co:16bd: 2f 68 32 3e 3c :
co:16c2: 2f 62 3e 3c    :
co:16c6: 2f 70 3e 0d 0a :   .dc.b "/p>",13,10
co:16cb: 3c 70 3e 3c 62 :   .dc.b "<p><b>A/D Converters AD0-AD3:</b></p>",13,10
co:16d0: 3e 41 2f 44 20 :
co:16d5: 43 6f 6e 76 65 :
co:16da: 72 74 65 72 73 :
co:16df: 20 41 44 30 2d :
co:16e4: 41 44 33 3a 3c :
co:16e9: 2f 62 3e 3c 2f :
co:16ee: 70 3e 0d 0a    :
co:16f2: 3c 74 61 62 6c :   .dc.b "<table bgcolor=#ffff80 border=1 cellpadding=0 cellspacing=0 widt"
co:16f7: 65 20 62 67 63 :
co:16fc: 6f 6c 6f 72 3d :
co:1701: 23 66 66 66 66 :
co:1706: 38 30 20 62 6f :
co:170b: 72 64 65 72 3d :
co:1710: 31 20 63 65 6c :
co:1715: 6c 70 61 64 64 :
co:171a: 69 6e 67 3d 30 :
co:171f: 20 63 65 6c 6c :
co:1724: 73 70 61 63 69 :
co:1729: 6e 67 3d 30 20 :
co:172e: 77 69 64 74    :
co:1732: 68 3d 35 31 34 :   .dc.b "h=514>",13,10
co:1737: 3e 0d 0a       :
co:173a: 3c 74 72 3e 3c :   .dc.b "<tr><td><table width="
co:173f: 74 64 3e 3c 74 :
co:1744: 61 62 6c 65 20 :
co:1749: 77 69 64 74 68 :
co:174e: 3d             :
co:174f: ff             :   .dc.b 255
                        :   .import _aval_0 ;  (char xdata*)aval_0
co:1750: 08 7e          :   .dc.w _aval_0
co:1752: 20 62 6f 72 64 :   .dc.b " border=0 cellpadding=0 cellspacing=0><tr><td bgcolor=#0000ff>&n"
co:1757: 65 72 3d 30 20 :
co:175c: 63 65 6c 6c 70 :
co:1761: 61 64 64 69 6e :
co:1766: 67 3d 30 20 63 :
co:176b: 65 6c 6c 73 70 :
co:1770: 61 63 69 6e 67 :
co:1775: 3d 30 3e 3c 74 :
co:177a: 72 3e 3c 74 64 :
co:177f: 20 62 67 63 6f :
co:1784: 6c 6f 72 3d 23 :
co:1789: 30 30 30 30 66 :
co:178e: 66 3e 26 6e    :
co:1792: 62 73 70 3b 3c :   .dc.b "bsp;</td></tr></table></td></tr>",13,10
co:1797: 2f 74 64 3e 3c :
co:179c: 2f 74 72 3e 3c :
co:17a1: 2f 74 61 62 6c :
co:17a6: 65 3e 3c 2f 74 :
co:17ab: 64 3e 3c 2f 74 :
co:17b0: 72 3e 0d 0a    :
co:17b4: 3c 74 72 3e 3c :   .dc.b "<tr><td><table width="
co:17b9: 74 64 3e 3c 74 :
co:17be: 61 62 6c 65 20 :
co:17c3: 77 69 64 74 68 :
co:17c8: 3d             :
co:17c9: ff             :   .dc.b 255
                        :   .import _aval_1 ;  (char xdata*)aval_1
co:17ca: 08 79          :   .dc.w _aval_1
co:17cc: 20 62 6f 72 64 :   .dc.b " border=0 cellpadding=0 cellspacing=0><tr><td bgcolor=#0000ff>&n"
co:17d1: 65 72 3d 30 20 :
co:17d6: 63 65 6c 6c 70 :
co:17db: 61 64 64 69 6e :
co:17e0: 67 3d 30 20 63 :
co:17e5: 65 6c 6c 73 70 :
co:17ea: 61 63 69 6e 67 :
co:17ef: 3d 30 3e 3c 74 :
co:17f4: 72 3e 3c 74 64 :
co:17f9: 20 62 67 63 6f :
co:17fe: 6c 6f 72 3d 23 :
co:1803: 30 30 30 30 66 :
co:1808: 66 3e 26 6e    :
co:180c: 62 73 70 3b 3c :   .dc.b "bsp;</td></tr></table></td></tr>",13,10
co:1811: 2f 74 64 3e 3c :
co:1816: 2f 74 72 3e 3c :
co:181b: 2f 74 61 62 6c :
co:1820: 65 3e 3c 2f 74 :
co:1825: 64 3e 3c 2f 74 :
co:182a: 72 3e 0d 0a    :
co:182e: 3c 74 72 3e 3c :   .dc.b "<tr><td><table width="
co:1833: 74 64 3e 3c 74 :
co:1838: 61 62 6c 65 20 :
co:183d: 77 69 64 74 68 :
co:1842: 3d             :
co:1843: ff             :   .dc.b 255
                        :   .import _aval_2 ;  (char xdata*)aval_2
co:1844: 08 74          :   .dc.w _aval_2
co:1846: 20 62 6f 72 64 :   .dc.b " border=0 cellpadding=0 cellspacing=0><tr><td bgcolor=#0000ff>&n"
co:184b: 65 72 3d 30 20 :
co:1850: 63 65 6c 6c 70 :
co:1855: 61 64 64 69 6e :
co:185a: 67 3d 30 20 63 :
co:185f: 65 6c 6c 73 70 :
co:1864: 61 63 69 6e 67 :
co:1869: 3d 30 3e 3c 74 :
co:186e: 72 3e 3c 74 64 :
co:1873: 20 62 67 63 6f :
co:1878: 6c 6f 72 3d 23 :
co:187d: 30 30 30 30 66 :
co:1882: 66 3e 26 6e    :
co:1886: 62 73 70 3b 3c :   .dc.b "bsp;</td></tr></table></td></tr>",13,10
co:188b: 2f 74 64 3e 3c :
co:1890: 2f 74 72 3e 3c :
co:1895: 2f 74 61 62 6c :
co:189a: 65 3e 3c 2f 74 :
co:189f: 64 3e 3c 2f 74 :
co:18a4: 72 3e 0d 0a    :
co:18a8: 3c 74 72 3e 3c :   .dc.b "<tr><td><table width="
co:18ad: 74 64 3e 3c 74 :
co:18b2: 61 62 6c 65 20 :
co:18b7: 77 69 64 74 68 :
co:18bc: 3d             :
co:18bd: ff             :   .dc.b 255
                        :   .import _aval_3 ;  (char xdata*)aval_3
co:18be: 08 6f          :   .dc.w _aval_3
co:18c0: 20 62 6f 72 64 :   .dc.b " border=0 cellpadding=0 cellspacing=0><tr><td bgcolor=#0000ff>&n"
co:18c5: 65 72 3d 30 20 :
co:18ca: 63 65 6c 6c 70 :
co:18cf: 61 64 64 69 6e :
co:18d4: 67 3d 30 20 63 :
co:18d9: 65 6c 6c 73 70 :
co:18de: 61 63 69 6e 67 :
co:18e3: 3d 30 3e 3c 74 :
co:18e8: 72 3e 3c 74 64 :
co:18ed: 20 62 67 63 6f :
co:18f2: 6c 6f 72 3d 23 :
co:18f7: 30 30 30 30 66 :
co:18fc: 66 3e 26 6e    :
co:1900: 62 73 70 3b 3c :   .dc.b "bsp;</td></tr></table></td></tr>",13,10
co:1905: 2f 74 64 3e 3c :
co:190a: 2f 74 72 3e 3c :
co:190f: 2f 74 61 62 6c :
co:1914: 65 3e 3c 2f 74 :
co:1919: 64 3e 3c 2f 74 :
co:191e: 72 3e 0d 0a    :
co:1922: 3c 2f 74 61 62 :   .dc.b "</table>",13,10
co:1927: 6c 65 3e 0d 0a :
co:192c: 3c 74 61 62 6c :   .dc.b "<table border=0 width=514>",13,10
co:1931: 65 20 62 6f 72 :
co:1936: 64 65 72 3d 30 :
co:193b: 20 77 69 64 74 :
co:1940: 68 3d 35 31 34 :
co:1945: 3e 0d 0a       :
co:1948: 3c 74 72 3e 0d :   .dc.b "<tr>",13,10
co:194d: 0a             :
co:194e: 3c 74 64 20 77 :   .dc.b "<td width=",34,"20%",34,">0.0V</td>",13,10
co:1953: 69 64 74 68 3d :
co:1958: 22 32 30 25 22 :
co:195d: 3e 30 2e 30 56 :
co:1962: 3c 2f 74 64 3e :
co:1967: 0d 0a          :
co:1969: 3c 74 64 20 77 :   .dc.b "<td width=",34,"20%",34,">1.0V</td>",13,10
co:196e: 69 64 74 68 3d :
co:1973: 22 32 30 25 22 :
co:1978: 3e 31 2e 30 56 :
co:197d: 3c 2f 74 64 3e :
co:1982: 0d 0a          :
co:1984: 3c 74 64 20 77 :   .dc.b "<td width=",34,"20%",34,">2.0V</td>",13,10
co:1989: 69 64 74 68 3d :
co:198e: 22 32 30 25 22 :
co:1993: 3e 32 2e 30 56 :
co:1998: 3c 2f 74 64 3e :
co:199d: 0d 0a          :
co:199f: 3c 74 64 20 77 :   .dc.b "<td width=",34,"20%",34,">3.0V</td>",13,10
co:19a4: 69 64 74 68 3d :
co:19a9: 22 32 30 25 22 :
co:19ae: 3e 33 2e 30 56 :
co:19b3: 3c 2f 74 64 3e :
co:19b8: 0d 0a          :
co:19ba: 3c 74 64 20 77 :   .dc.b "<td width=",34,"20%",34,">4.0V</td>",13,10
co:19bf: 69 64 74 68 3d :
co:19c4: 22 32 30 25 22 :
co:19c9: 3e 34 2e 30 56 :
co:19ce: 3c 2f 74 64 3e :
co:19d3: 0d 0a          :
co:19d5: 3c 2f 74 72 3e :   .dc.b "</tr>",13,10
co:19da: 0d 0a          :
co:19dc: 3c 2f 74 61 62 :   .dc.b "</table><br>",13,10
co:19e1: 6c 65 3e 3c 62 :
co:19e6: 72 3e 0d 0a    :
co:19ea: 3c 61 20 68 72 :   .dc.b "<a href=",34,"home.html",34,">Exit and Home...</a>",13,10
co:19ef: 65 66 3d 22 68 :
co:19f4: 6f 6d 65 2e 68 :
co:19f9: 74 6d 6c 22 3e :
co:19fe: 45 78 69 74 20 :
co:1a03: 61 6e 64 20 48 :
co:1a08: 6f 6d 65 2e 2e :
co:1a0d: 2e 3c 2f 61 3e :
co:1a12: 0d 0a          :
co:1a14: 3c 2f 62 6f 64 :   .dc.b "</body>",13,10
co:1a19: 79 3e 0d 0a    :
co:1a1d: 3c 2f 68 74 6d :   .dc.b "</html>",13,10
co:1a22: 6c 3e 0d 0a    :
co:1a26: 0d 0a          :   .dc.b 13,10
co:1a28: 0d 0a          :   .dc.b 13,10
                        : 
                        : ; End
=              _ad_disp =  159b (hex),   5531 (dez), text

objectfile:_doprnt.obj:

objectfile:_startup.obj:

objectfile:peep.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:puts.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:ind_call.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:strlen.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:add_i4.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:strcpy.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:ctype.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:bxor_i4.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:copy_l.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:bmove.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:band_i4.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:strcmp.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:mem32.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:mul_i2.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:cmp_i4.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:dimo_2.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:sprintf.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:cmp_u4.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:sub_i4.obj: (in C:\uC51\lib\small\stdlib.lib):

objectfile:ser_iod.obj: (in C:\uC51\lib\small\ser_ioD.lib):

